// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace PiersKarsenbarg.Sdm.Outputs
{

    [OutputType]
    public sealed class SecretStoreKeyfactorSshStore
    {
        /// <summary>
        /// Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        /// </summary>
        public readonly string? CaFilePath;
        /// <summary>
        /// Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        /// </summary>
        public readonly string CertificateFilePath;
        /// <summary>
        /// Name of EJBCA certificate authority that will enroll CSR.
        /// </summary>
        public readonly string DefaultCertificateAuthorityName;
        /// <summary>
        /// Certificate profile name that EJBCA will enroll the CSR with.
        /// </summary>
        public readonly string DefaultCertificateProfileName;
        /// <summary>
        /// End entity profile that EJBCA will enroll the CSR with.
        /// </summary>
        public readonly string DefaultEndEntityProfileName;
        /// <summary>
        /// code used by EJBCA during enrollment. May be left blank if no code is required.
        /// </summary>
        public readonly string? EnrollmentCodeEnvVar;
        /// <summary>
        /// username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        /// </summary>
        public readonly string? EnrollmentUsernameEnvVar;
        /// <summary>
        /// Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        /// </summary>
        public readonly string? KeyFilePath;
        /// <summary>
        /// Unique human-readable name of the SecretStore.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// The URL of the Vault to target
        /// </summary>
        public readonly string ServerAddress;
        /// <summary>
        /// Tags is a map of key, value pairs.
        /// </summary>
        public readonly ImmutableDictionary<string, string>? Tags;

        [OutputConstructor]
        private SecretStoreKeyfactorSshStore(
            string? caFilePath,

            string certificateFilePath,

            string defaultCertificateAuthorityName,

            string defaultCertificateProfileName,

            string defaultEndEntityProfileName,

            string? enrollmentCodeEnvVar,

            string? enrollmentUsernameEnvVar,

            string? keyFilePath,

            string name,

            string serverAddress,

            ImmutableDictionary<string, string>? tags)
        {
            CaFilePath = caFilePath;
            CertificateFilePath = certificateFilePath;
            DefaultCertificateAuthorityName = defaultCertificateAuthorityName;
            DefaultCertificateProfileName = defaultCertificateProfileName;
            DefaultEndEntityProfileName = defaultEndEntityProfileName;
            EnrollmentCodeEnvVar = enrollmentCodeEnvVar;
            EnrollmentUsernameEnvVar = enrollmentUsernameEnvVar;
            KeyFilePath = keyFilePath;
            Name = name;
            ServerAddress = serverAddress;
            Tags = tags;
        }
    }
}
