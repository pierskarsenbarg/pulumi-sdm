# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AccountService',
    'AccountUser',
    'ApprovalWorkflowApprovalStep',
    'ApprovalWorkflowApprovalStepApprover',
    'NodeGateway',
    'NodeGatewayMaintenanceWindow',
    'NodeProxyCluster',
    'NodeProxyClusterMaintenanceWindow',
    'NodeRelay',
    'NodeRelayMaintenanceWindow',
    'ResourceAerospike',
    'ResourceAks',
    'ResourceAksBasicAuth',
    'ResourceAksServiceAccount',
    'ResourceAksServiceAccountUserImpersonation',
    'ResourceAksUserImpersonation',
    'ResourceAmazonEks',
    'ResourceAmazonEksInstanceProfile',
    'ResourceAmazonEksInstanceProfileUserImpersonation',
    'ResourceAmazonEksUserImpersonation',
    'ResourceAmazonEs',
    'ResourceAmazonEsiam',
    'ResourceAmazonmqAmqp091',
    'ResourceAmazonmqAmqp',
    'ResourceAthena',
    'ResourceAthenaIam',
    'ResourceAuroraMysql',
    'ResourceAuroraMysqlIam',
    'ResourceAuroraPostgres',
    'ResourceAuroraPostgresIam',
    'ResourceAws',
    'ResourceAwsConsole',
    'ResourceAwsConsoleStaticKeyPair',
    'ResourceAwsInstanceProfile',
    'ResourceAzure',
    'ResourceAzureCertificate',
    'ResourceAzureConsole',
    'ResourceAzureMysql',
    'ResourceAzureMysqlManagedIdentity',
    'ResourceAzurePostgres',
    'ResourceAzurePostgresManagedIdentity',
    'ResourceBigQuery',
    'ResourceCassandra',
    'ResourceCitus',
    'ResourceClickHouseHttp',
    'ResourceClickHouseMySql',
    'ResourceClickHouseTcp',
    'ResourceClustrix',
    'ResourceCockroach',
    'ResourceCouchbaseDatabase',
    'ResourceCouchbaseWebUi',
    'ResourceDb2I',
    'ResourceDb2Luw',
    'ResourceDocumentDbHost',
    'ResourceDocumentDbHostIam',
    'ResourceDocumentDbReplicaSet',
    'ResourceDocumentDbReplicaSetIam',
    'ResourceDruid',
    'ResourceDynamoDb',
    'ResourceDynamoDbiam',
    'ResourceElastic',
    'ResourceElasticacheRedis',
    'ResourceGcp',
    'ResourceGcpConsole',
    'ResourceGcpwif',
    'ResourceGoogleGke',
    'ResourceGoogleGkeUserImpersonation',
    'ResourceGreenplum',
    'ResourceHttpAuth',
    'ResourceHttpBasicAuth',
    'ResourceHttpNoAuth',
    'ResourceKubernetes',
    'ResourceKubernetesBasicAuth',
    'ResourceKubernetesPodIdentity',
    'ResourceKubernetesServiceAccount',
    'ResourceKubernetesServiceAccountUserImpersonation',
    'ResourceKubernetesUserImpersonation',
    'ResourceMaria',
    'ResourceMemcached',
    'ResourceMemsql',
    'ResourceMongoHost',
    'ResourceMongoLegacyHost',
    'ResourceMongoLegacyReplicaset',
    'ResourceMongoReplicaSet',
    'ResourceMongoShardedCluster',
    'ResourceMtlsMysql',
    'ResourceMtlsPostgres',
    'ResourceMysql',
    'ResourceNeptune',
    'ResourceNeptuneIam',
    'ResourceOracle',
    'ResourceOracleNne',
    'ResourcePostgres',
    'ResourcePresto',
    'ResourceRabbitmqAmqp091',
    'ResourceRawTcp',
    'ResourceRdp',
    'ResourceRdpCert',
    'ResourceRdsPostgresIam',
    'ResourceRedis',
    'ResourceRedisCluster',
    'ResourceRedshift',
    'ResourceRedshiftIam',
    'ResourceRedshiftServerlessIam',
    'ResourceSingleStore',
    'ResourceSnowflake',
    'ResourceSnowsight',
    'ResourceSqlServer',
    'ResourceSqlServerAzureAd',
    'ResourceSqlServerKerberosAd',
    'ResourceSsh',
    'ResourceSshCert',
    'ResourceSshCustomerKey',
    'ResourceSshPassword',
    'ResourceSybase',
    'ResourceSybaseIq',
    'ResourceTeradata',
    'ResourceTrino',
    'ResourceVertica',
    'SecretEngineActiveDirectory',
    'SecretEngineKeyValue',
    'SecretStoreActiveDirectoryStore',
    'SecretStoreAws',
    'SecretStoreAwsCertX509',
    'SecretStoreAzureStore',
    'SecretStoreCyberarkConjur',
    'SecretStoreCyberarkPam',
    'SecretStoreCyberarkPamExperimental',
    'SecretStoreDelineaStore',
    'SecretStoreGcpCertX509Store',
    'SecretStoreGcpStore',
    'SecretStoreKeyfactorSshStore',
    'SecretStoreKeyfactorX509Store',
    'SecretStoreVaultApprole',
    'SecretStoreVaultApproleCertSsh',
    'SecretStoreVaultApproleCertX509',
    'SecretStoreVaultAwsEc2',
    'SecretStoreVaultAwsIam',
    'SecretStoreVaultTls',
    'SecretStoreVaultTlsCertSsh',
    'SecretStoreVaultTlsCertX509',
    'SecretStoreVaultToken',
    'SecretStoreVaultTokenCertSsh',
    'SecretStoreVaultTokenCertX509',
    'GetAccountAccountResult',
    'GetAccountAccountServiceResult',
    'GetAccountAccountTokenResult',
    'GetAccountAccountUserResult',
    'GetAccountAttachmentAccountAttachmentResult',
    'GetApprovalWorkflowApprovalStepResult',
    'GetApprovalWorkflowApprovalStepApproverResult',
    'GetApprovalWorkflowApprovalWorkflowResult',
    'GetApprovalWorkflowApprovalWorkflowApprovalStepResult',
    'GetApprovalWorkflowApprovalWorkflowApprovalStepApproverResult',
    'GetIdentityAliasIdentityAliasResult',
    'GetIdentitySetIdentitySetResult',
    'GetManagedSecretManagedSecretResult',
    'GetNodeNodeResult',
    'GetNodeNodeGatewayResult',
    'GetNodeNodeGatewayMaintenanceWindowResult',
    'GetNodeNodeProxyClusterResult',
    'GetNodeNodeProxyClusterMaintenanceWindowResult',
    'GetNodeNodeRelayResult',
    'GetNodeNodeRelayMaintenanceWindowResult',
    'GetPeeringGroupNodePeeringGroupNodeResult',
    'GetPeeringGroupPeerPeeringGroupPeerResult',
    'GetPeeringGroupPeeringGroupResult',
    'GetPeeringGroupResourcePeeringGroupResourceResult',
    'GetPolicyPolicyResult',
    'GetProxyClusterKeyProxyClusterKeyResult',
    'GetRemoteIdentityGroupRemoteIdentityGroupResult',
    'GetRemoteIdentityRemoteIdentityResult',
    'GetResourceResourceResult',
    'GetResourceResourceAerospikeResult',
    'GetResourceResourceAkResult',
    'GetResourceResourceAksBasicAuthResult',
    'GetResourceResourceAksServiceAccountResult',
    'GetResourceResourceAksServiceAccountUserImpersonationResult',
    'GetResourceResourceAksUserImpersonationResult',
    'GetResourceResourceAmazonEResult',
    'GetResourceResourceAmazonEkResult',
    'GetResourceResourceAmazonEksInstanceProfileResult',
    'GetResourceResourceAmazonEksInstanceProfileUserImpersonationResult',
    'GetResourceResourceAmazonEksUserImpersonationResult',
    'GetResourceResourceAmazonEsiamResult',
    'GetResourceResourceAmazonmqAmqp091Result',
    'GetResourceResourceAmazonmqAmqpResult',
    'GetResourceResourceAthenaResult',
    'GetResourceResourceAthenaIamResult',
    'GetResourceResourceAuroraMysqlResult',
    'GetResourceResourceAuroraMysqlIamResult',
    'GetResourceResourceAuroraPostgreResult',
    'GetResourceResourceAuroraPostgresIamResult',
    'GetResourceResourceAwResult',
    'GetResourceResourceAwsConsoleResult',
    'GetResourceResourceAwsConsoleStaticKeyPairResult',
    'GetResourceResourceAwsInstanceProfileResult',
    'GetResourceResourceAzureResult',
    'GetResourceResourceAzureCertificateResult',
    'GetResourceResourceAzureConsoleResult',
    'GetResourceResourceAzureMysqlResult',
    'GetResourceResourceAzureMysqlManagedIdentityResult',
    'GetResourceResourceAzurePostgreResult',
    'GetResourceResourceAzurePostgresManagedIdentityResult',
    'GetResourceResourceBigQueryResult',
    'GetResourceResourceCassandraResult',
    'GetResourceResourceCitusResult',
    'GetResourceResourceClickHouseHttpResult',
    'GetResourceResourceClickHouseMySqlResult',
    'GetResourceResourceClickHouseTcpResult',
    'GetResourceResourceClustrixResult',
    'GetResourceResourceCockroachResult',
    'GetResourceResourceCouchbaseDatabaseResult',
    'GetResourceResourceCouchbaseWebUiResult',
    'GetResourceResourceDb2IResult',
    'GetResourceResourceDb2LuwResult',
    'GetResourceResourceDocumentDbHostResult',
    'GetResourceResourceDocumentDbHostIamResult',
    'GetResourceResourceDocumentDbReplicaSetResult',
    'GetResourceResourceDocumentDbReplicaSetIamResult',
    'GetResourceResourceDruidResult',
    'GetResourceResourceDynamoDbResult',
    'GetResourceResourceDynamoDbiamResult',
    'GetResourceResourceElasticResult',
    'GetResourceResourceElasticacheRediResult',
    'GetResourceResourceGcpResult',
    'GetResourceResourceGcpConsoleResult',
    'GetResourceResourceGcpwifResult',
    'GetResourceResourceGoogleGkeResult',
    'GetResourceResourceGoogleGkeUserImpersonationResult',
    'GetResourceResourceGreenplumResult',
    'GetResourceResourceHttpAuthResult',
    'GetResourceResourceHttpBasicAuthResult',
    'GetResourceResourceHttpNoAuthResult',
    'GetResourceResourceKuberneteResult',
    'GetResourceResourceKubernetesBasicAuthResult',
    'GetResourceResourceKubernetesPodIdentityResult',
    'GetResourceResourceKubernetesServiceAccountResult',
    'GetResourceResourceKubernetesServiceAccountUserImpersonationResult',
    'GetResourceResourceKubernetesUserImpersonationResult',
    'GetResourceResourceMariaResult',
    'GetResourceResourceMemcachedResult',
    'GetResourceResourceMemsqlResult',
    'GetResourceResourceMongoHostResult',
    'GetResourceResourceMongoLegacyHostResult',
    'GetResourceResourceMongoLegacyReplicasetResult',
    'GetResourceResourceMongoReplicaSetResult',
    'GetResourceResourceMongoShardedClusterResult',
    'GetResourceResourceMtlsMysqlResult',
    'GetResourceResourceMtlsPostgreResult',
    'GetResourceResourceMysqlResult',
    'GetResourceResourceNeptuneResult',
    'GetResourceResourceNeptuneIamResult',
    'GetResourceResourceOracleResult',
    'GetResourceResourceOracleNneResult',
    'GetResourceResourcePostgreResult',
    'GetResourceResourcePrestoResult',
    'GetResourceResourceRabbitmqAmqp091Result',
    'GetResourceResourceRawTcpResult',
    'GetResourceResourceRdpResult',
    'GetResourceResourceRdpCertResult',
    'GetResourceResourceRdsPostgresIamResult',
    'GetResourceResourceRediResult',
    'GetResourceResourceRedisClusterResult',
    'GetResourceResourceRedshiftResult',
    'GetResourceResourceRedshiftIamResult',
    'GetResourceResourceRedshiftServerlessIamResult',
    'GetResourceResourceSingleStoreResult',
    'GetResourceResourceSnowflakeResult',
    'GetResourceResourceSnowsightResult',
    'GetResourceResourceSqlServerResult',
    'GetResourceResourceSqlServerAzureAdResult',
    'GetResourceResourceSqlServerKerberosAdResult',
    'GetResourceResourceSshResult',
    'GetResourceResourceSshCertResult',
    'GetResourceResourceSshCustomerKeyResult',
    'GetResourceResourceSshPasswordResult',
    'GetResourceResourceSybaseResult',
    'GetResourceResourceSybaseIqResult',
    'GetResourceResourceTeradataResult',
    'GetResourceResourceTrinoResult',
    'GetResourceResourceVerticaResult',
    'GetRoleRoleResult',
    'GetSecretEngineSecretEngineResult',
    'GetSecretEngineSecretEngineActiveDirectoryResult',
    'GetSecretEngineSecretEngineKeyValueResult',
    'GetSecretStoreSecretStoreResult',
    'GetSecretStoreSecretStoreActiveDirectoryStoreResult',
    'GetSecretStoreSecretStoreAwResult',
    'GetSecretStoreSecretStoreAwsCertX509Result',
    'GetSecretStoreSecretStoreAzureStoreResult',
    'GetSecretStoreSecretStoreCyberarkConjurResult',
    'GetSecretStoreSecretStoreCyberarkPamResult',
    'GetSecretStoreSecretStoreCyberarkPamExperimentalResult',
    'GetSecretStoreSecretStoreDelineaStoreResult',
    'GetSecretStoreSecretStoreGcpCertX509StoreResult',
    'GetSecretStoreSecretStoreGcpStoreResult',
    'GetSecretStoreSecretStoreKeyfactorSshStoreResult',
    'GetSecretStoreSecretStoreKeyfactorX509StoreResult',
    'GetSecretStoreSecretStoreVaultApproleResult',
    'GetSecretStoreSecretStoreVaultApproleCertSshResult',
    'GetSecretStoreSecretStoreVaultApproleCertX509Result',
    'GetSecretStoreSecretStoreVaultAwsEc2Result',
    'GetSecretStoreSecretStoreVaultAwsIamResult',
    'GetSecretStoreSecretStoreVaultTlResult',
    'GetSecretStoreSecretStoreVaultTlsCertSshResult',
    'GetSecretStoreSecretStoreVaultTlsCertX509Result',
    'GetSecretStoreSecretStoreVaultTokenResult',
    'GetSecretStoreSecretStoreVaultTokenCertSshResult',
    'GetSecretStoreSecretStoreVaultTokenCertX509Result',
    'GetWorkflowApproverWorkflowApproverResult',
    'GetWorkflowRoleWorkflowRoleResult',
    'GetWorkflowWorkflowResult',
]

@pulumi.output_type
class AccountService(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 suspended: Optional[_builtins.bool] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Service.
        :param _builtins.bool suspended: The Service's suspended state.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Service.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def suspended(self) -> Optional[_builtins.bool]:
        """
        The Service's suspended state.
        """
        return pulumi.get(self, "suspended")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "token")


@pulumi.output_type
class AccountUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "managedBy":
            suggest = "managed_by"
        elif key == "managerId":
            suggest = "manager_id"
        elif key == "permissionLevel":
            suggest = "permission_level"
        elif key == "resolvedManagerId":
            suggest = "resolved_manager_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 external_id: Optional[_builtins.str] = None,
                 managed_by: Optional[_builtins.str] = None,
                 manager_id: Optional[_builtins.str] = None,
                 permission_level: Optional[_builtins.str] = None,
                 resolved_manager_id: Optional[_builtins.str] = None,
                 scim: Optional[_builtins.str] = None,
                 suspended: Optional[_builtins.bool] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str email: The User's email address. Must be unique.
        :param _builtins.str first_name: The User's first name.
        :param _builtins.str last_name: The User's last name.
        :param _builtins.str external_id: External ID is an alternative unique ID this user is represented by within an external service.
        :param _builtins.str managed_by: Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        :param _builtins.str manager_id: Manager ID is the ID of the user's manager. This field is empty when the user has no manager.
        :param _builtins.str permission_level: PermissionLevel is the user's permission level e.g. admin, DBA, user.
        :param _builtins.str resolved_manager_id: Resolved Manager ID is the ID of the user's manager derived from the manager_id, if present, or from the SCIM metadata. This is a read-only field that's only populated for get and list.
        :param _builtins.str scim: SCIM contains the raw SCIM metadata for the user. This is a read-only field.
        :param _builtins.bool suspended: The Service's suspended state.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if managed_by is not None:
            pulumi.set(__self__, "managed_by", managed_by)
        if manager_id is not None:
            pulumi.set(__self__, "manager_id", manager_id)
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if resolved_manager_id is not None:
            pulumi.set(__self__, "resolved_manager_id", resolved_manager_id)
        if scim is not None:
            pulumi.set(__self__, "scim", scim)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The User's email address. Must be unique.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        The User's first name.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        The User's last name.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID is an alternative unique ID this user is represented by within an external service.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="managedBy")
    def managed_by(self) -> Optional[_builtins.str]:
        """
        Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        """
        return pulumi.get(self, "managed_by")

    @_builtins.property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> Optional[_builtins.str]:
        """
        Manager ID is the ID of the user's manager. This field is empty when the user has no manager.
        """
        return pulumi.get(self, "manager_id")

    @_builtins.property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[_builtins.str]:
        """
        PermissionLevel is the user's permission level e.g. admin, DBA, user.
        """
        return pulumi.get(self, "permission_level")

    @_builtins.property
    @pulumi.getter(name="resolvedManagerId")
    def resolved_manager_id(self) -> Optional[_builtins.str]:
        """
        Resolved Manager ID is the ID of the user's manager derived from the manager_id, if present, or from the SCIM metadata. This is a read-only field that's only populated for get and list.
        """
        return pulumi.get(self, "resolved_manager_id")

    @_builtins.property
    @pulumi.getter
    def scim(self) -> Optional[_builtins.str]:
        """
        SCIM contains the raw SCIM metadata for the user. This is a read-only field.
        """
        return pulumi.get(self, "scim")

    @_builtins.property
    @pulumi.getter
    def suspended(self) -> Optional[_builtins.bool]:
        """
        The Service's suspended state.
        """
        return pulumi.get(self, "suspended")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ApprovalWorkflowApprovalStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipAfter":
            suggest = "skip_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApprovalWorkflowApprovalStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApprovalWorkflowApprovalStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApprovalWorkflowApprovalStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approvers: Sequence['outputs.ApprovalWorkflowApprovalStepApprover'],
                 quantifier: Optional[_builtins.str] = None,
                 skip_after: Optional[_builtins.str] = None):
        """
        :param Sequence['ApprovalWorkflowApprovalStepApproverArgs'] approvers: The approvers for this approval step
        :param _builtins.str quantifier: Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        :param _builtins.str skip_after: Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        pulumi.set(__self__, "approvers", approvers)
        if quantifier is not None:
            pulumi.set(__self__, "quantifier", quantifier)
        if skip_after is not None:
            pulumi.set(__self__, "skip_after", skip_after)

    @_builtins.property
    @pulumi.getter
    def approvers(self) -> Sequence['outputs.ApprovalWorkflowApprovalStepApprover']:
        """
        The approvers for this approval step
        """
        return pulumi.get(self, "approvers")

    @_builtins.property
    @pulumi.getter
    def quantifier(self) -> Optional[_builtins.str]:
        """
        Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        """
        return pulumi.get(self, "quantifier")

    @_builtins.property
    @pulumi.getter(name="skipAfter")
    def skip_after(self) -> Optional[_builtins.str]:
        """
        Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        return pulumi.get(self, "skip_after")


@pulumi.output_type
class ApprovalWorkflowApprovalStepApprover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "roleId":
            suggest = "role_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApprovalWorkflowApprovalStepApprover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApprovalWorkflowApprovalStepApprover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApprovalWorkflowApprovalStepApprover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 reference: Optional[_builtins.str] = None,
                 role_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_id: The account id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        :param _builtins.str reference: A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, or reference may be present for one approver)
        :param _builtins.str role_id: The role id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        The account id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def reference(self) -> Optional[_builtins.str]:
        """
        A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, or reference may be present for one approver)
        """
        return pulumi.get(self, "reference")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        The role id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class NodeGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listenAddress":
            suggest = "listen_address"
        elif key == "bindAddress":
            suggest = "bind_address"
        elif key == "gatewayFilter":
            suggest = "gateway_filter"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 listen_address: _builtins.str,
                 bind_address: Optional[_builtins.str] = None,
                 device: Optional[_builtins.str] = None,
                 gateway_filter: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 maintenance_windows: Optional[Sequence['outputs.NodeGatewayMaintenanceWindow']] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str listen_address: The public hostname/port tuple at which the gateway will be accessible to clients.
        :param _builtins.str bind_address: The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        :param _builtins.str device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param _builtins.str gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param _builtins.str location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param Sequence['NodeGatewayMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param _builtins.str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        pulumi.set(__self__, "listen_address", listen_address)
        if bind_address is not None:
            pulumi.set(__self__, "bind_address", bind_address)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> _builtins.str:
        """
        The public hostname/port tuple at which the gateway will be accessible to clients.
        """
        return pulumi.get(self, "listen_address")

    @_builtins.property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> Optional[_builtins.str]:
        """
        The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        """
        return pulumi.get(self, "bind_address")

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[_builtins.str]:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[_builtins.str]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.NodeGatewayMaintenanceWindow']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class NodeGatewayMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronSchedule":
            suggest = "cron_schedule"
        elif key == "requireIdleness":
            suggest = "require_idleness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeGatewayMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeGatewayMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeGatewayMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_schedule: _builtins.str,
                 require_idleness: _builtins.bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @_builtins.property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> _builtins.str:
        return pulumi.get(self, "cron_schedule")

    @_builtins.property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> _builtins.bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class NodeProxyCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeProxyCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeProxyCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeProxyCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 maintenance_windows: Optional[Sequence['outputs.NodeProxyClusterMaintenanceWindow']] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str address: The public hostname/port tuple at which the proxy cluster will be accessible to clients.
        :param Sequence['NodeProxyClusterMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param _builtins.str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "address", address)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The public hostname/port tuple at which the proxy cluster will be accessible to clients.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.NodeProxyClusterMaintenanceWindow']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class NodeProxyClusterMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronSchedule":
            suggest = "cron_schedule"
        elif key == "requireIdleness":
            suggest = "require_idleness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeProxyClusterMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeProxyClusterMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeProxyClusterMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_schedule: _builtins.str,
                 require_idleness: _builtins.bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @_builtins.property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> _builtins.str:
        return pulumi.get(self, "cron_schedule")

    @_builtins.property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> _builtins.bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class NodeRelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayFilter":
            suggest = "gateway_filter"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeRelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeRelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeRelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: Optional[_builtins.str] = None,
                 gateway_filter: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 maintenance_windows: Optional[Sequence['outputs.NodeRelayMaintenanceWindow']] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param _builtins.str gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param _builtins.str location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param Sequence['NodeRelayMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param _builtins.str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        if device is not None:
            pulumi.set(__self__, "device", device)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[_builtins.str]:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[_builtins.str]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.NodeRelayMaintenanceWindow']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class NodeRelayMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronSchedule":
            suggest = "cron_schedule"
        elif key == "requireIdleness":
            suggest = "require_idleness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeRelayMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeRelayMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeRelayMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_schedule: _builtins.str,
                 require_idleness: _builtins.bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @_builtins.property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> _builtins.str:
        return pulumi.get(self, "cron_schedule")

    @_builtins.property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> _builtins.bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class ResourceAerospike(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useServicesAlternate":
            suggest = "use_services_alternate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAerospike. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAerospike.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAerospike.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_services_alternate: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_services_alternate: If true, uses UseServicesAlternates directive for Aerospike connection
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_services_alternate is not None:
            pulumi.set(__self__, "use_services_alternate", use_services_alternate)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useServicesAlternate")
    def use_services_alternate(self) -> Optional[_builtins.bool]:
        """
        If true, uses UseServicesAlternates directive for Aerospike connection
        """
        return pulumi.get(self, "use_services_alternate")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowResourceRoleBypass":
            suggest = "allow_resource_role_bypass"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAksBasicAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAksBasicAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAksBasicAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAksBasicAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAksServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowResourceRoleBypass":
            suggest = "allow_resource_role_bypass"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAksServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAksServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAksServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ResourceAksServiceAccountUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAksServiceAccountUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAksServiceAccountUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAksServiceAccountUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ResourceAksUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAksUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAksUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAksUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "allowResourceRoleBypass":
            suggest = "allow_resource_role_bypass"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str cluster_name: The name of the cluster to connect to.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEksInstanceProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "allowResourceRoleBypass":
            suggest = "allow_resource_role_bypass"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEksInstanceProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEksInstanceProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEksInstanceProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str cluster_name: The name of the cluster to connect to.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEksInstanceProfileUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEksInstanceProfileUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEksInstanceProfileUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEksInstanceProfileUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str cluster_name: The name of the cluster to connect to.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEksUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEksUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEksUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEksUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str cluster_name: The name of the cluster to connect to.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 region: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEsiam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEsiam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEsiam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEsiam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None):
        """
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")


@pulumi.output_type
class ResourceAmazonmqAmqp091(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonmqAmqp091. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonmqAmqp091.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonmqAmqp091.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAmazonmqAmqp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonmqAmqp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonmqAmqp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonmqAmqp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAthena(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "athenaOutput":
            suggest = "athena_output"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAthena. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAthena.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAthena.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 athena_output: _builtins.str,
                 name: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str athena_output: The AWS S3 output location.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "athena_output", athena_output)
        pulumi.set(__self__, "name", name)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="athenaOutput")
    def athena_output(self) -> _builtins.str:
        """
        The AWS S3 output location.
        """
        return pulumi.get(self, "athena_output")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAthenaIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAthenaIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAthenaIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAthenaIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 output: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str output: The AWS S3 output location.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output", output)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def output(self) -> _builtins.str:
        """
        The AWS S3 output location.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAuroraMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAuroraMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAuroraMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAuroraMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAuroraMysqlIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleAssumptionArn":
            suggest = "role_assumption_arn"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAuroraMysqlIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAuroraMysqlIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAuroraMysqlIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAuroraPostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAuroraPostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAuroraPostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAuroraPostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAuroraPostgresIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleAssumptionArn":
            suggest = "role_assumption_arn"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAuroraPostgresIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAuroraPostgresIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAuroraPostgresIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckRegion":
            suggest = "healthcheck_region"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_region: _builtins.str,
                 name: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str healthcheck_region: The AWS region healthcheck requests should attempt to connect to.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_region", healthcheck_region)
        pulumi.set(__self__, "name", name)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="healthcheckRegion")
    def healthcheck_region(self) -> _builtins.str:
        """
        The AWS region healthcheck requests should attempt to connect to.
        """
        return pulumi.get(self, "healthcheck_region")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAwsConsole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "enableEnvVariables":
            suggest = "enable_env_variables"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "sessionExpiry":
            suggest = "session_expiry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAwsConsole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAwsConsole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAwsConsole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 region: _builtins.str,
                 subdomain: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 enable_env_variables: Optional[_builtins.bool] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 session_expiry: Optional[_builtins.int] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool enable_env_variables: If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.int session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "subdomain", subdomain)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if enable_env_variables is not None:
            pulumi.set(__self__, "enable_env_variables", enable_env_variables)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> _builtins.str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="enableEnvVariables")
    def enable_env_variables(self) -> Optional[_builtins.bool]:
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        return pulumi.get(self, "enable_env_variables")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[_builtins.int]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAwsConsoleStaticKeyPair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "sessionExpiry":
            suggest = "session_expiry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAwsConsoleStaticKeyPair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAwsConsoleStaticKeyPair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAwsConsoleStaticKeyPair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 region: _builtins.str,
                 subdomain: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 session_expiry: Optional[_builtins.int] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.int session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "subdomain", subdomain)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> _builtins.str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[_builtins.int]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAwsInstanceProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "enableEnvVariables":
            suggest = "enable_env_variables"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAwsInstanceProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAwsInstanceProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAwsInstanceProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 enable_env_variables: Optional[_builtins.bool] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool enable_env_variables: If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if enable_env_variables is not None:
            pulumi.set(__self__, "enable_env_variables", enable_env_variables)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="enableEnvVariables")
    def enable_env_variables(self) -> Optional[_builtins.bool]:
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        return pulumi.get(self, "enable_env_variables")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 app_id: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str app_id: The application ID to authenticate with.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        pulumi.set(__self__, "name", name)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ResourceAzureCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzureCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzureCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzureCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 app_id: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str app_id: The application ID to authenticate with.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        pulumi.set(__self__, "name", name)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ResourceAzureConsole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorId":
            suggest = "connector_id"
        elif key == "privilegeLevels":
            suggest = "privilege_levels"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "managementGroupId":
            suggest = "management_group_id"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzureConsole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzureConsole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzureConsole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_id: _builtins.str,
                 name: _builtins.str,
                 privilege_levels: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 management_group_id: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 subscription_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str connector_id: The connector ID to authenticate through.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str privilege_levels: The privilege levels specify which Groups are managed externally
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str management_group_id: The management group ID to authenticate scope Privileges to.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str subscription_id: The subscription ID to authenticate scope Privileges to.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "connector_id", connector_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "privilege_levels", privilege_levels)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if management_group_id is not None:
            pulumi.set(__self__, "management_group_id", management_group_id)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> _builtins.str:
        """
        The connector ID to authenticate through.
        """
        return pulumi.get(self, "connector_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privilegeLevels")
    def privilege_levels(self) -> _builtins.str:
        """
        The privilege levels specify which Groups are managed externally
        """
        return pulumi.get(self, "privilege_levels")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="managementGroupId")
    def management_group_id(self) -> Optional[_builtins.str]:
        """
        The management group ID to authenticate scope Privileges to.
        """
        return pulumi.get(self, "management_group_id")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        """
        The subscription ID to authenticate scope Privileges to.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAzureMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzureMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzureMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzureMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAzureMysqlManagedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzureMysqlManagedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzureMysqlManagedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzureMysqlManagedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAzurePostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzurePostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzurePostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzurePostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAzurePostgresManagedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzurePostgresManagedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzurePostgresManagedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzurePostgresManagedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceBigQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceBigQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceBigQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceBigQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 project: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 private_key: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str project: The project to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str private_key: The private key used to authenticate with the server.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The project to connect to.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceCassandra(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceCassandra. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceCassandra.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceCassandra.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceCitus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceCitus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceCitus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceCitus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceClickHouseHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceClickHouseHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceClickHouseHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceClickHouseHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 url: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceClickHouseMySql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceClickHouseMySql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceClickHouseMySql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceClickHouseMySql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceClickHouseTcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceClickHouseTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceClickHouseTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceClickHouseTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceClustrix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceClustrix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceClustrix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceClustrix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceCockroach(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceCockroach. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceCockroach.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceCockroach.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceCouchbaseDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "n1QlPort":
            suggest = "n1_ql_port"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceCouchbaseDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceCouchbaseDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceCouchbaseDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 n1_ql_port: _builtins.int,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int n1_ql_port: The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "n1_ql_port", n1_ql_port)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="n1QlPort")
    def n1_ql_port(self) -> _builtins.int:
        """
        The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.
        """
        return pulumi.get(self, "n1_ql_port")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceCouchbaseWebUi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceCouchbaseWebUi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceCouchbaseWebUi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceCouchbaseWebUi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subdomain: _builtins.str,
                 url: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> _builtins.str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDb2I(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDb2I. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDb2I.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDb2I.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDb2Luw(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDb2Luw. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDb2Luw.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDb2Luw.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDocumentDbHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDocumentDbHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDocumentDbHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDocumentDbHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> _builtins.str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDocumentDbHostIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDocumentDbHostIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDocumentDbHostIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDocumentDbHostIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceDocumentDbReplicaSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "replicaSet":
            suggest = "replica_set"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "connectToReplica":
            suggest = "connect_to_replica"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDocumentDbReplicaSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDocumentDbReplicaSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDocumentDbReplicaSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 replica_set: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 connect_to_replica: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str replica_set: The name of the mongo replicaset.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replica_set", replica_set)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> _builtins.str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> _builtins.str:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[_builtins.bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDocumentDbReplicaSetIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "connectToReplica":
            suggest = "connect_to_replica"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDocumentDbReplicaSetIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDocumentDbReplicaSetIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDocumentDbReplicaSetIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 connect_to_replica: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[_builtins.bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceDruid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDruid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDruid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDruid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDynamoDb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDynamoDb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDynamoDb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDynamoDb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceDynamoDbiam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDynamoDbiam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDynamoDbiam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDynamoDbiam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceElastic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceElastic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceElastic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceElastic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceElasticacheRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceElasticacheRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceElasticacheRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceElasticacheRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 scopes: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 keyfile: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str scopes: Space separated scopes that this login should assume into when authenticating.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str keyfile: The service account keyfile to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> _builtins.str:
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def keyfile(self) -> Optional[_builtins.str]:
        """
        The service account keyfile to authenticate with.
        """
        return pulumi.get(self, "keyfile")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceGcpConsole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workforcePoolId":
            suggest = "workforce_pool_id"
        elif key == "workforceProviderId":
            suggest = "workforce_provider_id"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "sessionExpiry":
            suggest = "session_expiry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGcpConsole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGcpConsole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGcpConsole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subdomain: _builtins.str,
                 workforce_pool_id: _builtins.str,
                 workforce_provider_id: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 session_expiry: Optional[_builtins.int] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str workforce_pool_id: The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        :param _builtins.str workforce_provider_id: The ID of the Workforce Identity Provider in GCP to use for federated authentication.
               * google_gke:
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.int session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "workforce_pool_id", workforce_pool_id)
        pulumi.set(__self__, "workforce_provider_id", workforce_provider_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> _builtins.str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter(name="workforcePoolId")
    def workforce_pool_id(self) -> _builtins.str:
        """
        The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        """
        return pulumi.get(self, "workforce_pool_id")

    @_builtins.property
    @pulumi.getter(name="workforceProviderId")
    def workforce_provider_id(self) -> _builtins.str:
        """
        The ID of the Workforce Identity Provider in GCP to use for federated authentication.
        * google_gke:
        """
        return pulumi.get(self, "workforce_provider_id")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[_builtins.int]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceGcpwif(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workforcePoolId":
            suggest = "workforce_pool_id"
        elif key == "workforceProviderId":
            suggest = "workforce_provider_id"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "sessionExpiry":
            suggest = "session_expiry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGcpwif. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGcpwif.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGcpwif.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 scopes: _builtins.str,
                 workforce_pool_id: _builtins.str,
                 workforce_provider_id: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 project_id: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 session_expiry: Optional[_builtins.int] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str scopes: Space separated scopes that this login should assume into when authenticating.
        :param _builtins.str workforce_pool_id: The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        :param _builtins.str workforce_provider_id: The ID of the Workforce Identity Provider in GCP to use for federated authentication.
               * google_gke:
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str project_id: When specified, all project scoped requests will use this Project ID, overriding the project ID specified by clients
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.int session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "workforce_pool_id", workforce_pool_id)
        pulumi.set(__self__, "workforce_provider_id", workforce_provider_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> _builtins.str:
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="workforcePoolId")
    def workforce_pool_id(self) -> _builtins.str:
        """
        The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        """
        return pulumi.get(self, "workforce_pool_id")

    @_builtins.property
    @pulumi.getter(name="workforceProviderId")
    def workforce_provider_id(self) -> _builtins.str:
        """
        The ID of the Workforce Identity Provider in GCP to use for federated authentication.
        * google_gke:
        """
        return pulumi.get(self, "workforce_provider_id")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        When specified, all project scoped requests will use this Project ID, overriding the project ID specified by clients
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[_builtins.int]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceGoogleGke(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowResourceRoleBypass":
            suggest = "allow_resource_role_bypass"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "serviceAccountKey":
            suggest = "service_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGoogleGke. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGoogleGke.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGoogleGke.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 service_account_key: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str service_account_key: The service account key to authenticate with.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[_builtins.str]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceGoogleGkeUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "serviceAccountKey":
            suggest = "service_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGoogleGkeUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGoogleGkeUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGoogleGkeUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 service_account_key: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str service_account_key: The service account key to authenticate with.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[_builtins.str]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceGreenplum(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGreenplum. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGreenplum.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGreenplum.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceHttpAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckPath":
            suggest = "healthcheck_path"
        elif key == "authHeader":
            suggest = "auth_header"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "defaultPath":
            suggest = "default_path"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "headersBlacklist":
            suggest = "headers_blacklist"
        elif key == "hostOverride":
            suggest = "host_override"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceHttpAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceHttpAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceHttpAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_path: _builtins.str,
                 name: _builtins.str,
                 subdomain: _builtins.str,
                 url: _builtins.str,
                 auth_header: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 default_path: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 headers_blacklist: Optional[_builtins.str] = None,
                 host_override: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str healthcheck_path: This path will be used to check the health of your site.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        :param _builtins.str auth_header: The content to set as the authorization header.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str default_path: Automatically redirect to this path upon connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param _builtins.str host_override: The host header will be overwritten with this field if provided.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if auth_header is not None:
            pulumi.set(__self__, "auth_header", auth_header)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> _builtins.str:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> _builtins.str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="authHeader")
    def auth_header(self) -> Optional[_builtins.str]:
        """
        The content to set as the authorization header.
        """
        return pulumi.get(self, "auth_header")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[_builtins.str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[_builtins.str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @_builtins.property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[_builtins.str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceHttpBasicAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckPath":
            suggest = "healthcheck_path"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "defaultPath":
            suggest = "default_path"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "headersBlacklist":
            suggest = "headers_blacklist"
        elif key == "hostOverride":
            suggest = "host_override"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceHttpBasicAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceHttpBasicAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceHttpBasicAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_path: _builtins.str,
                 name: _builtins.str,
                 subdomain: _builtins.str,
                 url: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 default_path: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 headers_blacklist: Optional[_builtins.str] = None,
                 host_override: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str healthcheck_path: This path will be used to check the health of your site.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str default_path: Automatically redirect to this path upon connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param _builtins.str host_override: The host header will be overwritten with this field if provided.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> _builtins.str:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> _builtins.str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[_builtins.str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[_builtins.str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @_builtins.property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[_builtins.str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceHttpNoAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckPath":
            suggest = "healthcheck_path"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "defaultPath":
            suggest = "default_path"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "headersBlacklist":
            suggest = "headers_blacklist"
        elif key == "hostOverride":
            suggest = "host_override"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceHttpNoAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceHttpNoAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceHttpNoAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_path: _builtins.str,
                 name: _builtins.str,
                 subdomain: _builtins.str,
                 url: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 default_path: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 headers_blacklist: Optional[_builtins.str] = None,
                 host_override: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str healthcheck_path: This path will be used to check the health of your site.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str default_path: Automatically redirect to this path upon connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param _builtins.str host_override: The host header will be overwritten with this field if provided.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> _builtins.str:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> _builtins.str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[_builtins.str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[_builtins.str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @_builtins.property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[_builtins.str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceKubernetes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowResourceRoleBypass":
            suggest = "allow_resource_role_bypass"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceKubernetesBasicAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetesBasicAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetesBasicAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetesBasicAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceKubernetesPodIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowResourceRoleBypass":
            suggest = "allow_resource_role_bypass"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetesPodIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetesPodIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetesPodIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceKubernetesServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowResourceRoleBypass":
            suggest = "allow_resource_role_bypass"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetesServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetesServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetesServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ResourceKubernetesServiceAccountUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetesServiceAccountUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetesServiceAccountUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetesServiceAccountUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ResourceKubernetesUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetesUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetesUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetesUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceMaria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMaria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMaria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMaria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMemcached(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMemcached. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMemcached.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMemcached.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceMemsql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMemsql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMemsql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMemsql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> _builtins.str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoLegacyHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoLegacyHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoLegacyHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoLegacyHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> _builtins.str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoLegacyReplicaset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "replicaSet":
            suggest = "replica_set"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "connectToReplica":
            suggest = "connect_to_replica"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoLegacyReplicaset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoLegacyReplicaset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoLegacyReplicaset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 replica_set: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 connect_to_replica: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str replica_set: The name of the mongo replicaset.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replica_set", replica_set)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> _builtins.str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> _builtins.str:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[_builtins.bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoReplicaSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "replicaSet":
            suggest = "replica_set"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "connectToReplica":
            suggest = "connect_to_replica"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoReplicaSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoReplicaSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoReplicaSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 replica_set: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 connect_to_replica: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str replica_set: The name of the mongo replicaset.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replica_set", replica_set)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> _builtins.str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> _builtins.str:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[_builtins.bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoShardedCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoShardedCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoShardedCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoShardedCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> _builtins.str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMtlsMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMtlsMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMtlsMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMtlsMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMtlsPostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMtlsPostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMtlsPostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMtlsPostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceNeptune(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceNeptune. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceNeptune.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceNeptune.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceNeptuneIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceNeptuneIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceNeptuneIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceNeptuneIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceOracle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceOracle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceOracle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceOracle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceOracleNne(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceOracleNne. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceOracleNne.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceOracleNne.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourcePostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourcePresto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePresto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePresto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePresto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRabbitmqAmqp091(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRabbitmqAmqp091. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRabbitmqAmqp091.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRabbitmqAmqp091.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRawTcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRawTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRawTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRawTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceRdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "downgradeNlaConnections":
            suggest = "downgrade_nla_connections"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "lockRequired":
            suggest = "lock_required"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 downgrade_nla_connections: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 lock_required: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool downgrade_nla_connections: When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if downgrade_nla_connections is not None:
            pulumi.set(__self__, "downgrade_nla_connections", downgrade_nla_connections)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="downgradeNlaConnections")
    def downgrade_nla_connections(self) -> Optional[_builtins.bool]:
        """
        When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        """
        return pulumi.get(self, "downgrade_nla_connections")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[_builtins.bool]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRdpCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "lockRequired":
            suggest = "lock_required"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRdpCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRdpCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRdpCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 lock_required: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.bool lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[_builtins.bool]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRdsPostgresIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleAssumptionArn":
            suggest = "role_assumption_arn"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRdsPostgresIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRdsPostgresIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRdsPostgresIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRedisCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRedisCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRedisCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRedisCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRedshiftIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleAssumptionArn":
            suggest = "role_assumption_arn"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRedshiftIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRedshiftIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRedshiftIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str cluster_id: Cluster Identified of Redshift cluster
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        Cluster Identified of Redshift cluster
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceRedshiftServerlessIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "roleAssumptionArn":
            suggest = "role_assumption_arn"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRedshiftServerlessIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRedshiftServerlessIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRedshiftServerlessIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 workgroup: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str workgroup: Workgroup name in the serverless Redshift
               * single_store:
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "workgroup", workgroup)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def workgroup(self) -> _builtins.str:
        """
        Workgroup name in the serverless Redshift
        * single_store:
        """
        return pulumi.get(self, "workgroup")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceSingleStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSingleStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSingleStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSingleStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSnowflake(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSnowflake. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSnowflake.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSnowflake.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 private_key: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str private_key: The private key used to authenticate with the server.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str schema: The Schema to use to direct initial requests.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSnowsight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckUsername":
            suggest = "healthcheck_username"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "samlMetadata":
            suggest = "saml_metadata"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSnowsight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSnowsight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSnowsight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_username: _builtins.str,
                 name: _builtins.str,
                 subdomain: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 saml_metadata: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str healthcheck_username: The StrongDM user email to use for healthchecks.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str saml_metadata: The Metadata for your snowflake IDP integration
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_username", healthcheck_username)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if saml_metadata is not None:
            pulumi.set(__self__, "saml_metadata", saml_metadata)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="healthcheckUsername")
    def healthcheck_username(self) -> _builtins.str:
        """
        The StrongDM user email to use for healthchecks.
        """
        return pulumi.get(self, "healthcheck_username")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> _builtins.str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="samlMetadata")
    def saml_metadata(self) -> Optional[_builtins.str]:
        """
        The Metadata for your snowflake IDP integration
        """
        return pulumi.get(self, "saml_metadata")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceSqlServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedEncryption":
            suggest = "allow_deprecated_encryption"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSqlServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSqlServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSqlServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 allow_deprecated_encryption: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str schema: The Schema to use to direct initial requests.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[_builtins.bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSqlServerAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedEncryption":
            suggest = "allow_deprecated_encryption"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSqlServerAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSqlServerAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSqlServerAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 allow_deprecated_encryption: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str client_id: The Azure AD application (client) ID with which to authenticate.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str schema: The Schema to use to direct initial requests.
        :param _builtins.str secret: The Azure AD client secret (application password) with which to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[_builtins.bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Azure AD application (client) ID with which to authenticate.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        The Azure AD client secret (application password) with which to authenticate.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ResourceSqlServerKerberosAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverSpn":
            suggest = "server_spn"
        elif key == "allowDeprecatedEncryption":
            suggest = "allow_deprecated_encryption"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "krbConfig":
            suggest = "krb_config"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSqlServerKerberosAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSqlServerKerberosAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSqlServerKerberosAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 server_spn: _builtins.str,
                 allow_deprecated_encryption: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 keytab: Optional[_builtins.str] = None,
                 krb_config: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 realm: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str server_spn: The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        :param _builtins.bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str keytab: The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        :param _builtins.str krb_config: The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str realm: The Active Directory domain (realm) to which the configured username belongs.
        :param _builtins.str schema: The Schema to use to direct initial requests.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_spn", server_spn)
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if keytab is not None:
            pulumi.set(__self__, "keytab", keytab)
        if krb_config is not None:
            pulumi.set(__self__, "krb_config", krb_config)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverSpn")
    def server_spn(self) -> _builtins.str:
        """
        The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        """
        return pulumi.get(self, "server_spn")

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[_builtins.bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def keytab(self) -> Optional[_builtins.str]:
        """
        The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        """
        return pulumi.get(self, "keytab")

    @_builtins.property
    @pulumi.getter(name="krbConfig")
    def krb_config(self) -> Optional[_builtins.str]:
        """
        The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        """
        return pulumi.get(self, "krb_config")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def realm(self) -> Optional[_builtins.str]:
        """
        The Active Directory domain (realm) to which the configured username belongs.
        """
        return pulumi.get(self, "realm")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedKeyExchanges":
            suggest = "allow_deprecated_key_exchanges"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "keyType":
            suggest = "key_type"
        elif key == "portForwarding":
            suggest = "port_forwarding"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 allow_deprecated_key_exchanges: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 key_type: Optional[_builtins.str] = None,
                 port_forwarding: Optional[_builtins.bool] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 public_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str key_type: The key type to use e.g. rsa-2048 or ed25519
        :param _builtins.bool port_forwarding: Whether port forwarding is allowed through this server.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str public_key: The public key to append to a server's authorized keys. This will be generated after resource creation.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[_builtins.bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[_builtins.str]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[_builtins.bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[_builtins.str]:
        """
        The public key to append to a server's authorized keys. This will be generated after resource creation.
        """
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSshCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedKeyExchanges":
            suggest = "allow_deprecated_key_exchanges"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "keyType":
            suggest = "key_type"
        elif key == "portForwarding":
            suggest = "port_forwarding"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSshCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSshCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSshCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 allow_deprecated_key_exchanges: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 key_type: Optional[_builtins.str] = None,
                 port_forwarding: Optional[_builtins.bool] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str key_type: The key type to use e.g. rsa-2048 or ed25519
        :param _builtins.bool port_forwarding: Whether port forwarding is allowed through this server.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[_builtins.bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[_builtins.str]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[_builtins.bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSshCustomerKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedKeyExchanges":
            suggest = "allow_deprecated_key_exchanges"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portForwarding":
            suggest = "port_forwarding"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSshCustomerKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSshCustomerKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSshCustomerKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 allow_deprecated_key_exchanges: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 port_forwarding: Optional[_builtins.bool] = None,
                 port_override: Optional[_builtins.int] = None,
                 private_key: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.bool port_forwarding: Whether port forwarding is allowed through this server.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str private_key: The private key used to authenticate with the server.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[_builtins.bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[_builtins.bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSshPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedKeyExchanges":
            suggest = "allow_deprecated_key_exchanges"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portForwarding":
            suggest = "port_forwarding"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSshPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSshPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSshPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 allow_deprecated_key_exchanges: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_forwarding: Optional[_builtins.bool] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.bool port_forwarding: Whether port forwarding is allowed through this server.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[_builtins.bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[_builtins.bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSybase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSybase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSybase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSybase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSybaseIq(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSybaseIq. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSybaseIq.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSybaseIq.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceTeradata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTeradata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTeradata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTeradata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceTrino(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTrino. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTrino.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTrino.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceVertica(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "proxyClusterId":
            suggest = "proxy_cluster_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceVertica. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceVertica.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceVertica.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 name: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SecretEngineActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "secretStoreRootPath":
            suggest = "secret_store_root_path"
        elif key == "afterReadTtl":
            suggest = "after_read_ttl"
        elif key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "doNotValidateTimestamps":
            suggest = "do_not_validate_timestamps"
        elif key == "insecureTls":
            suggest = "insecure_tls"
        elif key == "keyRotationIntervalDays":
            suggest = "key_rotation_interval_days"
        elif key == "maxBackoffDuration":
            suggest = "max_backoff_duration"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "requestTimeout":
            suggest = "request_timeout"
        elif key == "startTls":
            suggest = "start_tls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretEngineActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretEngineActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretEngineActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 binddn: _builtins.str,
                 bindpass: _builtins.str,
                 name: _builtins.str,
                 secret_store_id: _builtins.str,
                 secret_store_root_path: _builtins.str,
                 url: _builtins.str,
                 after_read_ttl: Optional[_builtins.str] = None,
                 certificate: Optional[_builtins.str] = None,
                 connection_timeout: Optional[_builtins.int] = None,
                 do_not_validate_timestamps: Optional[_builtins.bool] = None,
                 insecure_tls: Optional[_builtins.bool] = None,
                 key_rotation_interval_days: Optional[_builtins.int] = None,
                 max_backoff_duration: Optional[_builtins.str] = None,
                 public_key: Optional[_builtins.str] = None,
                 request_timeout: Optional[_builtins.int] = None,
                 start_tls: Optional[_builtins.bool] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 ttl: Optional[_builtins.str] = None,
                 upndomain: Optional[_builtins.str] = None,
                 userdn: Optional[_builtins.str] = None):
        """
        :param _builtins.str binddn: Distinguished name of object to bind when performing user and group search. Example: cn=vault,ou=Users,dc=example,dc=com
        :param _builtins.str bindpass: Password to use along with binddn when performing user search.
        :param _builtins.str name: Unique human-readable name of the Secret Engine.
        :param _builtins.str secret_store_id: Backing secret store identifier
        :param _builtins.str secret_store_root_path: Backing Secret Store root path where managed secrets are going to be stored
        :param _builtins.str url: The LDAP server to connect to.
        :param _builtins.str after_read_ttl: The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        :param _builtins.str certificate: CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.
        :param _builtins.int connection_timeout: Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
        :param _builtins.bool do_not_validate_timestamps: If set to true this will prevent password change timestamp validation in Active Directory when validating credentials
        :param _builtins.bool insecure_tls: If true, skips LDAP server SSL certificate verification - insecure, use with caution!
        :param _builtins.int key_rotation_interval_days: An interval of public/private key rotation for secret engine in days
        :param _builtins.str max_backoff_duration: The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will be retried in an increasing intervals until it reaches max_backoff_duration
        :param _builtins.str public_key: Public key linked with a secret engine
        :param _builtins.int request_timeout: Timeout, in seconds, for the connection when making requests against the server before returning back an error.
        :param _builtins.bool start_tls: If true, issues a StartTLS command after establishing an unencrypted connection.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str ttl: The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        :param _builtins.str upndomain: The domain (userPrincipalDomain) used to construct a UPN string for authentication.
        :param _builtins.str userdn: Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com
               * key_value:
        """
        pulumi.set(__self__, "binddn", binddn)
        pulumi.set(__self__, "bindpass", bindpass)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_store_id", secret_store_id)
        pulumi.set(__self__, "secret_store_root_path", secret_store_root_path)
        pulumi.set(__self__, "url", url)
        if after_read_ttl is not None:
            pulumi.set(__self__, "after_read_ttl", after_read_ttl)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if do_not_validate_timestamps is not None:
            pulumi.set(__self__, "do_not_validate_timestamps", do_not_validate_timestamps)
        if insecure_tls is not None:
            pulumi.set(__self__, "insecure_tls", insecure_tls)
        if key_rotation_interval_days is not None:
            pulumi.set(__self__, "key_rotation_interval_days", key_rotation_interval_days)
        if max_backoff_duration is not None:
            pulumi.set(__self__, "max_backoff_duration", max_backoff_duration)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if start_tls is not None:
            pulumi.set(__self__, "start_tls", start_tls)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if upndomain is not None:
            pulumi.set(__self__, "upndomain", upndomain)
        if userdn is not None:
            pulumi.set(__self__, "userdn", userdn)

    @_builtins.property
    @pulumi.getter
    def binddn(self) -> _builtins.str:
        """
        Distinguished name of object to bind when performing user and group search. Example: cn=vault,ou=Users,dc=example,dc=com
        """
        return pulumi.get(self, "binddn")

    @_builtins.property
    @pulumi.getter
    def bindpass(self) -> _builtins.str:
        """
        Password to use along with binddn when performing user search.
        """
        return pulumi.get(self, "bindpass")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Secret Engine.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> _builtins.str:
        """
        Backing secret store identifier
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreRootPath")
    def secret_store_root_path(self) -> _builtins.str:
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        return pulumi.get(self, "secret_store_root_path")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The LDAP server to connect to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="afterReadTtl")
    def after_read_ttl(self) -> Optional[_builtins.str]:
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        return pulumi.get(self, "after_read_ttl")

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[_builtins.str]:
        """
        CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
        """
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="doNotValidateTimestamps")
    def do_not_validate_timestamps(self) -> Optional[_builtins.bool]:
        """
        If set to true this will prevent password change timestamp validation in Active Directory when validating credentials
        """
        return pulumi.get(self, "do_not_validate_timestamps")

    @_builtins.property
    @pulumi.getter(name="insecureTls")
    def insecure_tls(self) -> Optional[_builtins.bool]:
        """
        If true, skips LDAP server SSL certificate verification - insecure, use with caution!
        """
        return pulumi.get(self, "insecure_tls")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalDays")
    def key_rotation_interval_days(self) -> Optional[_builtins.int]:
        """
        An interval of public/private key rotation for secret engine in days
        """
        return pulumi.get(self, "key_rotation_interval_days")

    @_builtins.property
    @pulumi.getter(name="maxBackoffDuration")
    def max_backoff_duration(self) -> Optional[_builtins.str]:
        """
        The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will be retried in an increasing intervals until it reaches max_backoff_duration
        """
        return pulumi.get(self, "max_backoff_duration")

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[_builtins.str]:
        """
        Public key linked with a secret engine
        """
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout, in seconds, for the connection when making requests against the server before returning back an error.
        """
        return pulumi.get(self, "request_timeout")

    @_builtins.property
    @pulumi.getter(name="startTls")
    def start_tls(self) -> Optional[_builtins.bool]:
        """
        If true, issues a StartTLS command after establishing an unencrypted connection.
        """
        return pulumi.get(self, "start_tls")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter
    def upndomain(self) -> Optional[_builtins.str]:
        """
        The domain (userPrincipalDomain) used to construct a UPN string for authentication.
        """
        return pulumi.get(self, "upndomain")

    @_builtins.property
    @pulumi.getter
    def userdn(self) -> Optional[_builtins.str]:
        """
        Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com
        * key_value:
        """
        return pulumi.get(self, "userdn")


@pulumi.output_type
class SecretEngineKeyValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "secretStoreRootPath":
            suggest = "secret_store_root_path"
        elif key == "keyRotationIntervalDays":
            suggest = "key_rotation_interval_days"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretEngineKeyValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretEngineKeyValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretEngineKeyValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 secret_store_id: _builtins.str,
                 secret_store_root_path: _builtins.str,
                 key_rotation_interval_days: Optional[_builtins.int] = None,
                 public_key: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the Secret Engine.
        :param _builtins.str secret_store_id: Backing secret store identifier
        :param _builtins.str secret_store_root_path: Backing Secret Store root path where managed secrets are going to be stored
        :param _builtins.int key_rotation_interval_days: An interval of public/private key rotation for secret engine in days
        :param _builtins.str public_key: Public key linked with a secret engine
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_store_id", secret_store_id)
        pulumi.set(__self__, "secret_store_root_path", secret_store_root_path)
        if key_rotation_interval_days is not None:
            pulumi.set(__self__, "key_rotation_interval_days", key_rotation_interval_days)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the Secret Engine.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> _builtins.str:
        """
        Backing secret store identifier
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreRootPath")
    def secret_store_root_path(self) -> _builtins.str:
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        return pulumi.get(self, "secret_store_root_path")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalDays")
    def key_rotation_interval_days(self) -> Optional[_builtins.int]:
        """
        An interval of public/private key rotation for secret engine in days
        """
        return pulumi.get(self, "key_rotation_interval_days")

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[_builtins.str]:
        """
        Public key linked with a secret engine
        """
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreActiveDirectoryStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreActiveDirectoryStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreActiveDirectoryStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreActiveDirectoryStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreAws(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 region: _builtins.str,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str region: The AWS region to target e.g. us-east-1
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreAwsCertX509(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caArn":
            suggest = "ca_arn"
        elif key == "certificateTemplateArn":
            suggest = "certificate_template_arn"
        elif key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "signingAlgo":
            suggest = "signing_algo"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreAwsCertX509. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreAwsCertX509.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreAwsCertX509.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_arn: _builtins.str,
                 certificate_template_arn: _builtins.str,
                 issued_cert_ttl_minutes: _builtins.int,
                 name: _builtins.str,
                 region: _builtins.str,
                 signing_algo: _builtins.str,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ca_arn: The ARN of the CA in AWS Private CA
        :param _builtins.str certificate_template_arn: The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str region: The AWS region to target e.g. us-east-1
        :param _builtins.str signing_algo: The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "ca_arn", ca_arn)
        pulumi.set(__self__, "certificate_template_arn", certificate_template_arn)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "signing_algo", signing_algo)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caArn")
    def ca_arn(self) -> _builtins.str:
        """
        The ARN of the CA in AWS Private CA
        """
        return pulumi.get(self, "ca_arn")

    @_builtins.property
    @pulumi.getter(name="certificateTemplateArn")
    def certificate_template_arn(self) -> _builtins.str:
        """
        The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        """
        return pulumi.get(self, "certificate_template_arn")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> _builtins.int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="signingAlgo")
    def signing_algo(self) -> _builtins.str:
        """
        The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        """
        return pulumi.get(self, "signing_algo")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreAzureStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vaultUri":
            suggest = "vault_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreAzureStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreAzureStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreAzureStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 vault_uri: _builtins.str,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str vault_uri: The URI of the key vault to target e.g. https://myvault.vault.azure.net
               * cyberark_conjur:
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vault_uri", vault_uri)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> _builtins.str:
        """
        The URI of the key vault to target e.g. https://myvault.vault.azure.net
        * cyberark_conjur:
        """
        return pulumi.get(self, "vault_uri")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreCyberarkConjur(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appUrl":
            suggest = "app_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreCyberarkConjur. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreCyberarkConjur.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreCyberarkConjur.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_url: _builtins.str,
                 name: _builtins.str,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str app_url: The URL of the Cyberark instance
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "app_url", app_url)
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> _builtins.str:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreCyberarkPam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appUrl":
            suggest = "app_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreCyberarkPam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreCyberarkPam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreCyberarkPam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_url: _builtins.str,
                 name: _builtins.str,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str app_url: The URL of the Cyberark instance
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "app_url", app_url)
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> _builtins.str:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreCyberarkPamExperimental(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appUrl":
            suggest = "app_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreCyberarkPamExperimental. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreCyberarkPamExperimental.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreCyberarkPamExperimental.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_url: _builtins.str,
                 name: _builtins.str,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str app_url: The URL of the Cyberark instance
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "app_url", app_url)
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> _builtins.str:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreDelineaStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverUrl":
            suggest = "server_url"
        elif key == "tenantName":
            suggest = "tenant_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreDelineaStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreDelineaStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreDelineaStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 server_url: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tenant_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_url: The URL of the Delinea instance
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str tenant_name: The tenant name to target
               * gcp_store:
        """
        pulumi.set(__self__, "name", name)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Delinea instance
        """
        return pulumi.get(self, "server_url")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[_builtins.str]:
        """
        The tenant name to target
        * gcp_store:
        """
        return pulumi.get(self, "tenant_name")


@pulumi.output_type
class SecretStoreGcpCertX509Store(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caPoolId":
            suggest = "ca_pool_id"
        elif key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "caId":
            suggest = "ca_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreGcpCertX509Store. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreGcpCertX509Store.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreGcpCertX509Store.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_pool_id: _builtins.str,
                 issued_cert_ttl_minutes: _builtins.int,
                 location: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 ca_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ca_pool_id: The ID of the target CA pool
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str location: The Region for the CA in GCP format e.g. us-west1
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str project_id: The GCP project ID to target.
        :param _builtins.str ca_id: The ID of the target CA
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "ca_pool_id", ca_pool_id)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if ca_id is not None:
            pulumi.set(__self__, "ca_id", ca_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caPoolId")
    def ca_pool_id(self) -> _builtins.str:
        """
        The ID of the target CA pool
        """
        return pulumi.get(self, "ca_pool_id")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> _builtins.int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The Region for the CA in GCP format e.g. us-west1
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="caId")
    def ca_id(self) -> Optional[_builtins.str]:
        """
        The ID of the target CA
        """
        return pulumi.get(self, "ca_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreGcpStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreGcpStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreGcpStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreGcpStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str project_id: The GCP project ID to target.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreKeyfactorSshStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateFilePath":
            suggest = "certificate_file_path"
        elif key == "defaultCertificateAuthorityName":
            suggest = "default_certificate_authority_name"
        elif key == "defaultCertificateProfileName":
            suggest = "default_certificate_profile_name"
        elif key == "defaultEndEntityProfileName":
            suggest = "default_end_entity_profile_name"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "caFilePath":
            suggest = "ca_file_path"
        elif key == "enrollmentCodeEnvVar":
            suggest = "enrollment_code_env_var"
        elif key == "enrollmentUsernameEnvVar":
            suggest = "enrollment_username_env_var"
        elif key == "keyFilePath":
            suggest = "key_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreKeyfactorSshStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreKeyfactorSshStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreKeyfactorSshStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_file_path: _builtins.str,
                 default_certificate_authority_name: _builtins.str,
                 default_certificate_profile_name: _builtins.str,
                 default_end_entity_profile_name: _builtins.str,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 ca_file_path: Optional[_builtins.str] = None,
                 enrollment_code_env_var: Optional[_builtins.str] = None,
                 enrollment_username_env_var: Optional[_builtins.str] = None,
                 key_file_path: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param _builtins.str default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param _builtins.str default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param _builtins.str default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param _builtins.str enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param _builtins.str enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param _builtins.str key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> _builtins.str:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @_builtins.property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> _builtins.str:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @_builtins.property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> _builtins.str:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @_builtins.property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> _builtins.str:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[_builtins.str]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @_builtins.property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[_builtins.str]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @_builtins.property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[_builtins.str]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @_builtins.property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[_builtins.str]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreKeyfactorX509Store(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateFilePath":
            suggest = "certificate_file_path"
        elif key == "defaultCertificateAuthorityName":
            suggest = "default_certificate_authority_name"
        elif key == "defaultCertificateProfileName":
            suggest = "default_certificate_profile_name"
        elif key == "defaultEndEntityProfileName":
            suggest = "default_end_entity_profile_name"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "caFilePath":
            suggest = "ca_file_path"
        elif key == "enrollmentCodeEnvVar":
            suggest = "enrollment_code_env_var"
        elif key == "enrollmentUsernameEnvVar":
            suggest = "enrollment_username_env_var"
        elif key == "keyFilePath":
            suggest = "key_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreKeyfactorX509Store. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreKeyfactorX509Store.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreKeyfactorX509Store.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_file_path: _builtins.str,
                 default_certificate_authority_name: _builtins.str,
                 default_certificate_profile_name: _builtins.str,
                 default_end_entity_profile_name: _builtins.str,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 ca_file_path: Optional[_builtins.str] = None,
                 enrollment_code_env_var: Optional[_builtins.str] = None,
                 enrollment_username_env_var: Optional[_builtins.str] = None,
                 key_file_path: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param _builtins.str default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param _builtins.str default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param _builtins.str default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param _builtins.str enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param _builtins.str enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param _builtins.str key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> _builtins.str:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @_builtins.property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> _builtins.str:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @_builtins.property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> _builtins.str:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @_builtins.property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> _builtins.str:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[_builtins.str]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @_builtins.property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[_builtins.str]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @_builtins.property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[_builtins.str]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @_builtins.property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[_builtins.str]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultApprole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultApprole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultApprole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultApprole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultApproleCertSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"
        elif key == "sshMountPoint":
            suggest = "ssh_mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultApproleCertSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultApproleCertSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultApproleCertSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issued_cert_ttl_minutes: _builtins.int,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 signing_role: _builtins.str,
                 ssh_mount_point: _builtins.str,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param _builtins.str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> _builtins.int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> _builtins.str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> _builtins.str:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultApproleCertX509(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "pkiMountPoint":
            suggest = "pki_mount_point"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultApproleCertX509. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultApproleCertX509.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultApproleCertX509.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issued_cert_ttl_minutes: _builtins.int,
                 name: _builtins.str,
                 pki_mount_point: _builtins.str,
                 server_address: _builtins.str,
                 signing_role: _builtins.str,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> _builtins.int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> _builtins.str:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> _builtins.str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultAwsEc2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultAwsEc2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultAwsEc2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultAwsEc2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultAwsIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultAwsIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultAwsIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultAwsIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertPath":
            suggest = "client_cert_path"
        elif key == "clientKeyPath":
            suggest = "client_key_path"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "caCertPath":
            suggest = "ca_cert_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert_path: _builtins.str,
                 client_key_path: _builtins.str,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 ca_cert_path: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str client_cert_path: A path to a client certificate file accessible by a Node
        :param _builtins.str client_key_path: A path to a client key file accessible by a Node
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str ca_cert_path: A path to a CA file accessible by a Node
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "client_cert_path", client_cert_path)
        pulumi.set(__self__, "client_key_path", client_key_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> _builtins.str:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @_builtins.property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> _builtins.str:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[_builtins.str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTlsCertSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertPath":
            suggest = "client_cert_path"
        elif key == "clientKeyPath":
            suggest = "client_key_path"
        elif key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"
        elif key == "sshMountPoint":
            suggest = "ssh_mount_point"
        elif key == "caCertPath":
            suggest = "ca_cert_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTlsCertSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTlsCertSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTlsCertSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert_path: _builtins.str,
                 client_key_path: _builtins.str,
                 issued_cert_ttl_minutes: _builtins.int,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 signing_role: _builtins.str,
                 ssh_mount_point: _builtins.str,
                 ca_cert_path: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str client_cert_path: A path to a client certificate file accessible by a Node
        :param _builtins.str client_key_path: A path to a client key file accessible by a Node
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param _builtins.str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param _builtins.str ca_cert_path: A path to a CA file accessible by a Node
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "client_cert_path", client_cert_path)
        pulumi.set(__self__, "client_key_path", client_key_path)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> _builtins.str:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @_builtins.property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> _builtins.str:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> _builtins.int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> _builtins.str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> _builtins.str:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @_builtins.property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[_builtins.str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTlsCertX509(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertPath":
            suggest = "client_cert_path"
        elif key == "clientKeyPath":
            suggest = "client_key_path"
        elif key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "pkiMountPoint":
            suggest = "pki_mount_point"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"
        elif key == "caCertPath":
            suggest = "ca_cert_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTlsCertX509. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTlsCertX509.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTlsCertX509.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert_path: _builtins.str,
                 client_key_path: _builtins.str,
                 issued_cert_ttl_minutes: _builtins.int,
                 name: _builtins.str,
                 pki_mount_point: _builtins.str,
                 server_address: _builtins.str,
                 signing_role: _builtins.str,
                 ca_cert_path: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str client_cert_path: A path to a client certificate file accessible by a Node
        :param _builtins.str client_key_path: A path to a client key file accessible by a Node
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param _builtins.str ca_cert_path: A path to a CA file accessible by a Node
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "client_cert_path", client_cert_path)
        pulumi.set(__self__, "client_key_path", client_key_path)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> _builtins.str:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @_builtins.property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> _builtins.str:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> _builtins.int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> _builtins.str:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> _builtins.str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[_builtins.str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTokenCertSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"
        elif key == "sshMountPoint":
            suggest = "ssh_mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTokenCertSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTokenCertSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTokenCertSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issued_cert_ttl_minutes: _builtins.int,
                 name: _builtins.str,
                 server_address: _builtins.str,
                 signing_role: _builtins.str,
                 ssh_mount_point: _builtins.str,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param _builtins.str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> _builtins.int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> _builtins.str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> _builtins.str:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTokenCertX509(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "pkiMountPoint":
            suggest = "pki_mount_point"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTokenCertX509. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTokenCertX509.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTokenCertX509.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issued_cert_ttl_minutes: _builtins.int,
                 name: _builtins.str,
                 pki_mount_point: _builtins.str,
                 server_address: _builtins.str,
                 signing_role: _builtins.str,
                 namespace: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param _builtins.str namespace: The namespace to make requests within
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> _builtins.int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> _builtins.str:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> _builtins.str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAccountAccountResult(dict):
    def __init__(__self__, *,
                 services: Sequence['outputs.GetAccountAccountServiceResult'],
                 tokens: Sequence['outputs.GetAccountAccountTokenResult'],
                 users: Sequence['outputs.GetAccountAccountUserResult']):
        """
        :param Sequence['GetAccountAccountServiceArgs'] services: A Service is a service account that can connect to resources they are granted directly, or granted via roles. Services are typically automated jobs.
        :param Sequence['GetAccountAccountTokenArgs'] tokens: A Token is an account providing tokenized access for automation or integration use. Tokens include admin tokens, API keys, and SCIM tokens.
        :param Sequence['GetAccountAccountUserArgs'] users: A User can connect to resources they are granted directly, or granted via roles.
        """
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "tokens", tokens)
        pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence['outputs.GetAccountAccountServiceResult']:
        """
        A Service is a service account that can connect to resources they are granted directly, or granted via roles. Services are typically automated jobs.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Sequence['outputs.GetAccountAccountTokenResult']:
        """
        A Token is an account providing tokenized access for automation or integration use. Tokens include admin tokens, API keys, and SCIM tokens.
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetAccountAccountUserResult']:
        """
        A User can connect to resources they are granted directly, or granted via roles.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetAccountAccountServiceResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 suspended: Optional[_builtins.bool] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the User.
        :param _builtins.str name: Unique human-readable name of the Token.
        :param _builtins.bool suspended: Reserved for future use.  Always false for tokens.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the User.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Token.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def suspended(self) -> Optional[_builtins.bool]:
        """
        Reserved for future use.  Always false for tokens.
        """
        return pulumi.get(self, "suspended")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAccountAccountTokenResult(dict):
    def __init__(__self__, *,
                 account_type: Optional[_builtins.str] = None,
                 deadline: Optional[_builtins.str] = None,
                 duration: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 permissions: Optional[Sequence[_builtins.str]] = None,
                 rekeyed: Optional[_builtins.str] = None,
                 suspended: Optional[_builtins.bool] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str account_type: Corresponds to the type of token, e.g. api or admin-token.
        :param _builtins.str deadline: The timestamp when the Token will expire.
        :param _builtins.str duration: Duration from token creation to expiration.
        :param _builtins.str id: Unique identifier of the User.
        :param _builtins.str name: Unique human-readable name of the Token.
        :param Sequence[_builtins.str] permissions: Permissions assigned to the token, e.g. role:create.
        :param _builtins.str rekeyed: The timestamp when the Token was last rekeyed.
        :param _builtins.bool suspended: Reserved for future use.  Always false for tokens.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if account_type is not None:
            pulumi.set(__self__, "account_type", account_type)
        if deadline is not None:
            pulumi.set(__self__, "deadline", deadline)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if rekeyed is not None:
            pulumi.set(__self__, "rekeyed", rekeyed)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accountType")
    def account_type(self) -> Optional[_builtins.str]:
        """
        Corresponds to the type of token, e.g. api or admin-token.
        """
        return pulumi.get(self, "account_type")

    @_builtins.property
    @pulumi.getter
    def deadline(self) -> Optional[_builtins.str]:
        """
        The timestamp when the Token will expire.
        """
        return pulumi.get(self, "deadline")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.str]:
        """
        Duration from token creation to expiration.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the User.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Token.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Permissions assigned to the token, e.g. role:create.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def rekeyed(self) -> Optional[_builtins.str]:
        """
        The timestamp when the Token was last rekeyed.
        """
        return pulumi.get(self, "rekeyed")

    @_builtins.property
    @pulumi.getter
    def suspended(self) -> Optional[_builtins.bool]:
        """
        Reserved for future use.  Always false for tokens.
        """
        return pulumi.get(self, "suspended")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAccountAccountUserResult(dict):
    def __init__(__self__, *,
                 managed_by: _builtins.str,
                 resolved_manager_id: _builtins.str,
                 scim: _builtins.str,
                 suspended: _builtins.bool,
                 email: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 first_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 last_name: Optional[_builtins.str] = None,
                 manager_id: Optional[_builtins.str] = None,
                 permission_level: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str managed_by: Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        :param _builtins.str resolved_manager_id: Resolved Manager ID is the ID of the user's manager derived from the manager_id, if present, or from the SCIM metadata. This is a read-only field that's only populated for get and list.
        :param _builtins.str scim: SCIM contains the raw SCIM metadata for the user. This is a read-only field.
        :param _builtins.bool suspended: Reserved for future use.  Always false for tokens.
        :param _builtins.str email: The User's email address. Must be unique.
        :param _builtins.str external_id: External ID is an alternative unique ID this user is represented by within an external service.
        :param _builtins.str first_name: The User's first name.
        :param _builtins.str id: Unique identifier of the User.
        :param _builtins.str last_name: The User's last name.
        :param _builtins.str manager_id: Manager ID is the ID of the user's manager. This field is empty when the user has no manager.
        :param _builtins.str permission_level: PermissionLevel is the user's permission level e.g. admin, DBA, user.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "managed_by", managed_by)
        pulumi.set(__self__, "resolved_manager_id", resolved_manager_id)
        pulumi.set(__self__, "scim", scim)
        pulumi.set(__self__, "suspended", suspended)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if manager_id is not None:
            pulumi.set(__self__, "manager_id", manager_id)
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="managedBy")
    def managed_by(self) -> _builtins.str:
        """
        Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        """
        return pulumi.get(self, "managed_by")

    @_builtins.property
    @pulumi.getter(name="resolvedManagerId")
    def resolved_manager_id(self) -> _builtins.str:
        """
        Resolved Manager ID is the ID of the user's manager derived from the manager_id, if present, or from the SCIM metadata. This is a read-only field that's only populated for get and list.
        """
        return pulumi.get(self, "resolved_manager_id")

    @_builtins.property
    @pulumi.getter
    def scim(self) -> _builtins.str:
        """
        SCIM contains the raw SCIM metadata for the user. This is a read-only field.
        """
        return pulumi.get(self, "scim")

    @_builtins.property
    @pulumi.getter
    def suspended(self) -> _builtins.bool:
        """
        Reserved for future use.  Always false for tokens.
        """
        return pulumi.get(self, "suspended")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The User's email address. Must be unique.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        External ID is an alternative unique ID this user is represented by within an external service.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[_builtins.str]:
        """
        The User's first name.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the User.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[_builtins.str]:
        """
        The User's last name.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> Optional[_builtins.str]:
        """
        Manager ID is the ID of the user's manager. This field is empty when the user has no manager.
        """
        return pulumi.get(self, "manager_id")

    @_builtins.property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[_builtins.str]:
        """
        PermissionLevel is the user's permission level e.g. admin, DBA, user.
        """
        return pulumi.get(self, "permission_level")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAccountAttachmentAccountAttachmentResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 role_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_id: The id of the account of this AccountAttachment.
        :param _builtins.str id: Unique identifier of the AccountAttachment.
        :param _builtins.str role_id: The id of the attached role of this AccountAttachment.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        The id of the account of this AccountAttachment.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the AccountAttachment.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        The id of the attached role of this AccountAttachment.
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class GetApprovalWorkflowApprovalStepResult(dict):
    def __init__(__self__, *,
                 approvers: Sequence['outputs.GetApprovalWorkflowApprovalStepApproverResult'],
                 quantifier: Optional[_builtins.str] = None,
                 skip_after: Optional[_builtins.str] = None):
        """
        :param Sequence['GetApprovalWorkflowApprovalStepApproverArgs'] approvers: The approvers for this approval step
        :param _builtins.str quantifier: Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        :param _builtins.str skip_after: Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        pulumi.set(__self__, "approvers", approvers)
        if quantifier is not None:
            pulumi.set(__self__, "quantifier", quantifier)
        if skip_after is not None:
            pulumi.set(__self__, "skip_after", skip_after)

    @_builtins.property
    @pulumi.getter
    def approvers(self) -> Sequence['outputs.GetApprovalWorkflowApprovalStepApproverResult']:
        """
        The approvers for this approval step
        """
        return pulumi.get(self, "approvers")

    @_builtins.property
    @pulumi.getter
    def quantifier(self) -> Optional[_builtins.str]:
        """
        Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        """
        return pulumi.get(self, "quantifier")

    @_builtins.property
    @pulumi.getter(name="skipAfter")
    def skip_after(self) -> Optional[_builtins.str]:
        """
        Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        return pulumi.get(self, "skip_after")


@pulumi.output_type
class GetApprovalWorkflowApprovalStepApproverResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 reference: Optional[_builtins.str] = None,
                 role_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_id: The account id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        :param _builtins.str reference: A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, or reference may be present for one approver)
        :param _builtins.str role_id: The role id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        The account id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def reference(self) -> Optional[_builtins.str]:
        """
        A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, or reference may be present for one approver)
        """
        return pulumi.get(self, "reference")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        The role id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class GetApprovalWorkflowApprovalWorkflowResult(dict):
    def __init__(__self__, *,
                 approval_mode: Optional[_builtins.str] = None,
                 approval_steps: Optional[Sequence['outputs.GetApprovalWorkflowApprovalWorkflowApprovalStepResult']] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str approval_mode: Approval mode of the ApprovalWorkflow
        :param Sequence['GetApprovalWorkflowApprovalWorkflowApprovalStepArgs'] approval_steps: The approval steps of this approval workflow
        :param _builtins.str description: Optional description of the ApprovalWorkflow.
        :param _builtins.str id: Unique identifier of the ApprovalWorkflow.
        :param _builtins.str name: Unique human-readable name of the ApprovalWorkflow.
        """
        if approval_mode is not None:
            pulumi.set(__self__, "approval_mode", approval_mode)
        if approval_steps is not None:
            pulumi.set(__self__, "approval_steps", approval_steps)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="approvalMode")
    def approval_mode(self) -> Optional[_builtins.str]:
        """
        Approval mode of the ApprovalWorkflow
        """
        return pulumi.get(self, "approval_mode")

    @_builtins.property
    @pulumi.getter(name="approvalSteps")
    def approval_steps(self) -> Optional[Sequence['outputs.GetApprovalWorkflowApprovalWorkflowApprovalStepResult']]:
        """
        The approval steps of this approval workflow
        """
        return pulumi.get(self, "approval_steps")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Optional description of the ApprovalWorkflow.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the ApprovalWorkflow.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the ApprovalWorkflow.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApprovalWorkflowApprovalWorkflowApprovalStepResult(dict):
    def __init__(__self__, *,
                 approvers: Sequence['outputs.GetApprovalWorkflowApprovalWorkflowApprovalStepApproverResult'],
                 quantifier: Optional[_builtins.str] = None,
                 skip_after: Optional[_builtins.str] = None):
        """
        :param Sequence['GetApprovalWorkflowApprovalWorkflowApprovalStepApproverArgs'] approvers: The approvers for this approval step
        :param _builtins.str quantifier: Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        :param _builtins.str skip_after: Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        pulumi.set(__self__, "approvers", approvers)
        if quantifier is not None:
            pulumi.set(__self__, "quantifier", quantifier)
        if skip_after is not None:
            pulumi.set(__self__, "skip_after", skip_after)

    @_builtins.property
    @pulumi.getter
    def approvers(self) -> Sequence['outputs.GetApprovalWorkflowApprovalWorkflowApprovalStepApproverResult']:
        """
        The approvers for this approval step
        """
        return pulumi.get(self, "approvers")

    @_builtins.property
    @pulumi.getter
    def quantifier(self) -> Optional[_builtins.str]:
        """
        Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        """
        return pulumi.get(self, "quantifier")

    @_builtins.property
    @pulumi.getter(name="skipAfter")
    def skip_after(self) -> Optional[_builtins.str]:
        """
        Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        return pulumi.get(self, "skip_after")


@pulumi.output_type
class GetApprovalWorkflowApprovalWorkflowApprovalStepApproverResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 reference: Optional[_builtins.str] = None,
                 role_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_id: The account id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        :param _builtins.str reference: A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, or reference may be present for one approver)
        :param _builtins.str role_id: The role id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        The account id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def reference(self) -> Optional[_builtins.str]:
        """
        A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, or reference may be present for one approver)
        """
        return pulumi.get(self, "reference")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        The role id of the approver (only one of account_id, role_id, or reference may be present for one approver)
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class GetIdentityAliasIdentityAliasResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_id: The account for this identity alias.
        :param _builtins.str id: Unique identifier of the IdentityAlias.
        :param _builtins.str identity_set_id: The identity set.
        :param _builtins.str username: The username to be used as the identity alias for this account.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        The account for this identity alias.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the IdentityAlias.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The identity set.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to be used as the identity alias for this account.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetIdentitySetIdentitySetResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique identifier of the IdentitySet.
        :param _builtins.str name: Unique human-readable name of the IdentitySet.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the IdentitySet.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the IdentitySet.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetManagedSecretManagedSecretResult(dict):
    def __init__(__self__, *,
                 config: _builtins.str,
                 expires_at: _builtins.str,
                 last_rotated_at: _builtins.str,
                 secret_store_path: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_engine_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str config: public part of the secret value
        :param _builtins.str expires_at: Timestamp of when secret is going to be rotated
        :param _builtins.str last_rotated_at: Timestamp of when secret was last rotated
        :param _builtins.str secret_store_path: Path in a secret store.
        :param _builtins.str id: Unique identifier of the Managed Secret.
        :param _builtins.str name: Unique human-readable name of the Managed Secret.
        :param _builtins.str secret_engine_id: An ID of a Secret Engine linked with the Managed Secret.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str value: Sensitive value of the secret.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "last_rotated_at", last_rotated_at)
        pulumi.set(__self__, "secret_store_path", secret_store_path)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_engine_id is not None:
            pulumi.set(__self__, "secret_engine_id", secret_engine_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def config(self) -> _builtins.str:
        """
        public part of the secret value
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        Timestamp of when secret is going to be rotated
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="lastRotatedAt")
    def last_rotated_at(self) -> _builtins.str:
        """
        Timestamp of when secret was last rotated
        """
        return pulumi.get(self, "last_rotated_at")

    @_builtins.property
    @pulumi.getter(name="secretStorePath")
    def secret_store_path(self) -> _builtins.str:
        """
        Path in a secret store.
        """
        return pulumi.get(self, "secret_store_path")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Managed Secret.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Managed Secret.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretEngineId")
    def secret_engine_id(self) -> Optional[_builtins.str]:
        """
        An ID of a Secret Engine linked with the Managed Secret.
        """
        return pulumi.get(self, "secret_engine_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Sensitive value of the secret.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNodeNodeResult(dict):
    def __init__(__self__, *,
                 gateways: Sequence['outputs.GetNodeNodeGatewayResult'],
                 proxy_clusters: Sequence['outputs.GetNodeNodeProxyClusterResult'],
                 relays: Sequence['outputs.GetNodeNodeRelayResult']):
        """
        :param Sequence['GetNodeNodeGatewayArgs'] gateways: Gateway represents a StrongDM CLI installation running in gateway mode.
        :param Sequence['GetNodeNodeProxyClusterArgs'] proxy_clusters: ProxyCluster represents a cluster of StrongDM proxies.
        :param Sequence['GetNodeNodeRelayArgs'] relays: Relay represents a StrongDM CLI installation running in relay mode.
        """
        pulumi.set(__self__, "gateways", gateways)
        pulumi.set(__self__, "proxy_clusters", proxy_clusters)
        pulumi.set(__self__, "relays", relays)

    @_builtins.property
    @pulumi.getter
    def gateways(self) -> Sequence['outputs.GetNodeNodeGatewayResult']:
        """
        Gateway represents a StrongDM CLI installation running in gateway mode.
        """
        return pulumi.get(self, "gateways")

    @_builtins.property
    @pulumi.getter(name="proxyClusters")
    def proxy_clusters(self) -> Sequence['outputs.GetNodeNodeProxyClusterResult']:
        """
        ProxyCluster represents a cluster of StrongDM proxies.
        """
        return pulumi.get(self, "proxy_clusters")

    @_builtins.property
    @pulumi.getter
    def relays(self) -> Sequence['outputs.GetNodeNodeRelayResult']:
        """
        Relay represents a StrongDM CLI installation running in relay mode.
        """
        return pulumi.get(self, "relays")


@pulumi.output_type
class GetNodeNodeGatewayResult(dict):
    def __init__(__self__, *,
                 device: _builtins.str,
                 location: _builtins.str,
                 version: _builtins.str,
                 bind_address: Optional[_builtins.str] = None,
                 gateway_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 listen_address: Optional[_builtins.str] = None,
                 maintenance_windows: Optional[Sequence['outputs.GetNodeNodeGatewayMaintenanceWindowResult']] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param _builtins.str location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param _builtins.str version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        :param _builtins.str bind_address: The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        :param _builtins.str gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param _builtins.str id: Unique identifier of the Relay.
        :param _builtins.str listen_address: The public hostname/port tuple at which the gateway will be accessible to clients.
        :param Sequence['GetNodeNodeGatewayMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param _builtins.str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "version", version)
        if bind_address is not None:
            pulumi.set(__self__, "bind_address", bind_address)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if listen_address is not None:
            pulumi.set(__self__, "listen_address", listen_address)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def device(self) -> _builtins.str:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> Optional[_builtins.str]:
        """
        The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        """
        return pulumi.get(self, "bind_address")

    @_builtins.property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[_builtins.str]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Relay.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> Optional[_builtins.str]:
        """
        The public hostname/port tuple at which the gateway will be accessible to clients.
        """
        return pulumi.get(self, "listen_address")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.GetNodeNodeGatewayMaintenanceWindowResult']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetNodeNodeGatewayMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 cron_schedule: _builtins.str,
                 require_idleness: _builtins.bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @_builtins.property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> _builtins.str:
        return pulumi.get(self, "cron_schedule")

    @_builtins.property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> _builtins.bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class GetNodeNodeProxyClusterResult(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 maintenance_windows: Optional[Sequence['outputs.GetNodeNodeProxyClusterMaintenanceWindowResult']] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str address: The public hostname/port tuple at which the proxy cluster will be accessible to clients.
        :param _builtins.str id: Unique identifier of the Relay.
        :param Sequence['GetNodeNodeProxyClusterMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param _builtins.str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The public hostname/port tuple at which the proxy cluster will be accessible to clients.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Relay.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.GetNodeNodeProxyClusterMaintenanceWindowResult']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetNodeNodeProxyClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 cron_schedule: _builtins.str,
                 require_idleness: _builtins.bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @_builtins.property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> _builtins.str:
        return pulumi.get(self, "cron_schedule")

    @_builtins.property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> _builtins.bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class GetNodeNodeRelayResult(dict):
    def __init__(__self__, *,
                 device: _builtins.str,
                 location: _builtins.str,
                 version: _builtins.str,
                 gateway_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 maintenance_windows: Optional[Sequence['outputs.GetNodeNodeRelayMaintenanceWindowResult']] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param _builtins.str location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param _builtins.str version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        :param _builtins.str gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param _builtins.str id: Unique identifier of the Relay.
        :param Sequence['GetNodeNodeRelayMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param _builtins.str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "version", version)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def device(self) -> _builtins.str:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[_builtins.str]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Relay.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.GetNodeNodeRelayMaintenanceWindowResult']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetNodeNodeRelayMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 cron_schedule: _builtins.str,
                 require_idleness: _builtins.bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @_builtins.property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> _builtins.str:
        return pulumi.get(self, "cron_schedule")

    @_builtins.property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> _builtins.bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class GetPeeringGroupNodePeeringGroupNodeResult(dict):
    def __init__(__self__, *,
                 group_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 node_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str group_id: Peering Group ID to which the node will be attached to.
        :param _builtins.str id: Unique identifier of the Attachment.
        :param _builtins.str node_id: Node ID to be attached.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        """
        Peering Group ID to which the node will be attached to.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Attachment.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[_builtins.str]:
        """
        Node ID to be attached.
        """
        return pulumi.get(self, "node_id")


@pulumi.output_type
class GetPeeringGroupPeerPeeringGroupPeerResult(dict):
    def __init__(__self__, *,
                 group_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 peers_with_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str group_id: Group ID from which the link will originate.
        :param _builtins.str id: Unique identifier of the Attachment.
        :param _builtins.str peers_with_group_id: Peering Group ID to which Group ID will link.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if peers_with_group_id is not None:
            pulumi.set(__self__, "peers_with_group_id", peers_with_group_id)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        """
        Group ID from which the link will originate.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Attachment.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="peersWithGroupId")
    def peers_with_group_id(self) -> Optional[_builtins.str]:
        """
        Peering Group ID to which Group ID will link.
        """
        return pulumi.get(self, "peers_with_group_id")


@pulumi.output_type
class GetPeeringGroupPeeringGroupResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique identifier of the PeeringGroup.
        :param _builtins.str name: Unique human-readable name of the PeeringGroup.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the PeeringGroup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the PeeringGroup.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPeeringGroupResourcePeeringGroupResourceResult(dict):
    def __init__(__self__, *,
                 group_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str group_id: Peering Group ID to which the resource will be attached to.
        :param _builtins.str id: Unique identifier of the Attachment.
        :param _builtins.str resource_id: Resource ID to be attached.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        """
        Peering Group ID to which the resource will be attached to.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Attachment.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        Resource ID to be attached.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class GetPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Optional description of the Policy.
        :param _builtins.str id: Unique identifier of the Policy.
        :param _builtins.str name: Unique human-readable name of the Policy.
        :param _builtins.str policy: The content of the Policy, in Cedar policy language.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Optional description of the Policy.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        The content of the Policy, in Cedar policy language.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class GetProxyClusterKeyProxyClusterKeyResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique identifier of the Relay.
        :param _builtins.str proxy_cluster_id: The ID of the proxy cluster which this key authenticates to.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Relay.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        The ID of the proxy cluster which this key authenticates to.
        """
        return pulumi.get(self, "proxy_cluster_id")


@pulumi.output_type
class GetRemoteIdentityGroupRemoteIdentityGroupResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique identifier of the RemoteIdentityGroup.
        :param _builtins.str name: Unique human-readable name of the RemoteIdentityGroup.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the RemoteIdentityGroup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the RemoteIdentityGroup.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRemoteIdentityRemoteIdentityResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 remote_identity_group_id: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_id: The account for this remote identity.
        :param _builtins.str id: Unique identifier of the RemoteIdentity.
        :param _builtins.str remote_identity_group_id: The remote identity group.
        :param _builtins.str username: The username to be used as the remote identity for this account.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if remote_identity_group_id is not None:
            pulumi.set(__self__, "remote_identity_group_id", remote_identity_group_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        The account for this remote identity.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the RemoteIdentity.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="remoteIdentityGroupId")
    def remote_identity_group_id(self) -> Optional[_builtins.str]:
        """
        The remote identity group.
        """
        return pulumi.get(self, "remote_identity_group_id")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to be used as the remote identity for this account.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceResult(dict):
    def __init__(__self__, *,
                 aerospikes: Sequence['outputs.GetResourceResourceAerospikeResult'],
                 aks: Sequence['outputs.GetResourceResourceAkResult'],
                 aks_basic_auths: Sequence['outputs.GetResourceResourceAksBasicAuthResult'],
                 aks_service_account_user_impersonations: Sequence['outputs.GetResourceResourceAksServiceAccountUserImpersonationResult'],
                 aks_service_accounts: Sequence['outputs.GetResourceResourceAksServiceAccountResult'],
                 aks_user_impersonations: Sequence['outputs.GetResourceResourceAksUserImpersonationResult'],
                 amazon_eks: Sequence['outputs.GetResourceResourceAmazonEkResult'],
                 amazon_eks_instance_profile_user_impersonations: Sequence['outputs.GetResourceResourceAmazonEksInstanceProfileUserImpersonationResult'],
                 amazon_eks_instance_profiles: Sequence['outputs.GetResourceResourceAmazonEksInstanceProfileResult'],
                 amazon_eks_user_impersonations: Sequence['outputs.GetResourceResourceAmazonEksUserImpersonationResult'],
                 amazon_es: Sequence['outputs.GetResourceResourceAmazonEResult'],
                 amazon_esiams: Sequence['outputs.GetResourceResourceAmazonEsiamResult'],
                 amazonmq_amqp091s: Sequence['outputs.GetResourceResourceAmazonmqAmqp091Result'],
                 amazonmq_amqps: Sequence['outputs.GetResourceResourceAmazonmqAmqpResult'],
                 athena_iams: Sequence['outputs.GetResourceResourceAthenaIamResult'],
                 athenas: Sequence['outputs.GetResourceResourceAthenaResult'],
                 aurora_mysql_iams: Sequence['outputs.GetResourceResourceAuroraMysqlIamResult'],
                 aurora_mysqls: Sequence['outputs.GetResourceResourceAuroraMysqlResult'],
                 aurora_postgres: Sequence['outputs.GetResourceResourceAuroraPostgreResult'],
                 aurora_postgres_iams: Sequence['outputs.GetResourceResourceAuroraPostgresIamResult'],
                 aws: Sequence['outputs.GetResourceResourceAwResult'],
                 aws_console_static_key_pairs: Sequence['outputs.GetResourceResourceAwsConsoleStaticKeyPairResult'],
                 aws_consoles: Sequence['outputs.GetResourceResourceAwsConsoleResult'],
                 aws_instance_profiles: Sequence['outputs.GetResourceResourceAwsInstanceProfileResult'],
                 azure_certificates: Sequence['outputs.GetResourceResourceAzureCertificateResult'],
                 azure_consoles: Sequence['outputs.GetResourceResourceAzureConsoleResult'],
                 azure_mysql_managed_identities: Sequence['outputs.GetResourceResourceAzureMysqlManagedIdentityResult'],
                 azure_mysqls: Sequence['outputs.GetResourceResourceAzureMysqlResult'],
                 azure_postgres: Sequence['outputs.GetResourceResourceAzurePostgreResult'],
                 azure_postgres_managed_identities: Sequence['outputs.GetResourceResourceAzurePostgresManagedIdentityResult'],
                 azures: Sequence['outputs.GetResourceResourceAzureResult'],
                 big_queries: Sequence['outputs.GetResourceResourceBigQueryResult'],
                 cassandras: Sequence['outputs.GetResourceResourceCassandraResult'],
                 cituses: Sequence['outputs.GetResourceResourceCitusResult'],
                 click_house_https: Sequence['outputs.GetResourceResourceClickHouseHttpResult'],
                 click_house_my_sqls: Sequence['outputs.GetResourceResourceClickHouseMySqlResult'],
                 click_house_tcps: Sequence['outputs.GetResourceResourceClickHouseTcpResult'],
                 clustrixes: Sequence['outputs.GetResourceResourceClustrixResult'],
                 cockroaches: Sequence['outputs.GetResourceResourceCockroachResult'],
                 couchbase_databases: Sequence['outputs.GetResourceResourceCouchbaseDatabaseResult'],
                 couchbase_web_uis: Sequence['outputs.GetResourceResourceCouchbaseWebUiResult'],
                 db2_is: Sequence['outputs.GetResourceResourceDb2IResult'],
                 db2_luws: Sequence['outputs.GetResourceResourceDb2LuwResult'],
                 document_db_host_iams: Sequence['outputs.GetResourceResourceDocumentDbHostIamResult'],
                 document_db_hosts: Sequence['outputs.GetResourceResourceDocumentDbHostResult'],
                 document_db_replica_set_iams: Sequence['outputs.GetResourceResourceDocumentDbReplicaSetIamResult'],
                 document_db_replica_sets: Sequence['outputs.GetResourceResourceDocumentDbReplicaSetResult'],
                 druids: Sequence['outputs.GetResourceResourceDruidResult'],
                 dynamo_dbiams: Sequence['outputs.GetResourceResourceDynamoDbiamResult'],
                 dynamo_dbs: Sequence['outputs.GetResourceResourceDynamoDbResult'],
                 elasticache_redis: Sequence['outputs.GetResourceResourceElasticacheRediResult'],
                 elastics: Sequence['outputs.GetResourceResourceElasticResult'],
                 gcp_consoles: Sequence['outputs.GetResourceResourceGcpConsoleResult'],
                 gcps: Sequence['outputs.GetResourceResourceGcpResult'],
                 gcpwifs: Sequence['outputs.GetResourceResourceGcpwifResult'],
                 google_gke_user_impersonations: Sequence['outputs.GetResourceResourceGoogleGkeUserImpersonationResult'],
                 google_gkes: Sequence['outputs.GetResourceResourceGoogleGkeResult'],
                 greenplums: Sequence['outputs.GetResourceResourceGreenplumResult'],
                 http_auths: Sequence['outputs.GetResourceResourceHttpAuthResult'],
                 http_basic_auths: Sequence['outputs.GetResourceResourceHttpBasicAuthResult'],
                 http_no_auths: Sequence['outputs.GetResourceResourceHttpNoAuthResult'],
                 kubernetes: Sequence['outputs.GetResourceResourceKuberneteResult'],
                 kubernetes_basic_auths: Sequence['outputs.GetResourceResourceKubernetesBasicAuthResult'],
                 kubernetes_pod_identities: Sequence['outputs.GetResourceResourceKubernetesPodIdentityResult'],
                 kubernetes_service_account_user_impersonations: Sequence['outputs.GetResourceResourceKubernetesServiceAccountUserImpersonationResult'],
                 kubernetes_service_accounts: Sequence['outputs.GetResourceResourceKubernetesServiceAccountResult'],
                 kubernetes_user_impersonations: Sequence['outputs.GetResourceResourceKubernetesUserImpersonationResult'],
                 marias: Sequence['outputs.GetResourceResourceMariaResult'],
                 memcacheds: Sequence['outputs.GetResourceResourceMemcachedResult'],
                 memsqls: Sequence['outputs.GetResourceResourceMemsqlResult'],
                 mongo_hosts: Sequence['outputs.GetResourceResourceMongoHostResult'],
                 mongo_legacy_hosts: Sequence['outputs.GetResourceResourceMongoLegacyHostResult'],
                 mongo_legacy_replicasets: Sequence['outputs.GetResourceResourceMongoLegacyReplicasetResult'],
                 mongo_replica_sets: Sequence['outputs.GetResourceResourceMongoReplicaSetResult'],
                 mongo_sharded_clusters: Sequence['outputs.GetResourceResourceMongoShardedClusterResult'],
                 mtls_mysqls: Sequence['outputs.GetResourceResourceMtlsMysqlResult'],
                 mtls_postgres: Sequence['outputs.GetResourceResourceMtlsPostgreResult'],
                 mysqls: Sequence['outputs.GetResourceResourceMysqlResult'],
                 neptune_iams: Sequence['outputs.GetResourceResourceNeptuneIamResult'],
                 neptunes: Sequence['outputs.GetResourceResourceNeptuneResult'],
                 oracle_nnes: Sequence['outputs.GetResourceResourceOracleNneResult'],
                 oracles: Sequence['outputs.GetResourceResourceOracleResult'],
                 postgres: Sequence['outputs.GetResourceResourcePostgreResult'],
                 prestos: Sequence['outputs.GetResourceResourcePrestoResult'],
                 rabbitmq_amqp091s: Sequence['outputs.GetResourceResourceRabbitmqAmqp091Result'],
                 raw_tcps: Sequence['outputs.GetResourceResourceRawTcpResult'],
                 rdp_certs: Sequence['outputs.GetResourceResourceRdpCertResult'],
                 rdps: Sequence['outputs.GetResourceResourceRdpResult'],
                 rds_postgres_iams: Sequence['outputs.GetResourceResourceRdsPostgresIamResult'],
                 redis: Sequence['outputs.GetResourceResourceRediResult'],
                 redis_clusters: Sequence['outputs.GetResourceResourceRedisClusterResult'],
                 redshift_iams: Sequence['outputs.GetResourceResourceRedshiftIamResult'],
                 redshift_serverless_iams: Sequence['outputs.GetResourceResourceRedshiftServerlessIamResult'],
                 redshifts: Sequence['outputs.GetResourceResourceRedshiftResult'],
                 single_stores: Sequence['outputs.GetResourceResourceSingleStoreResult'],
                 snowflakes: Sequence['outputs.GetResourceResourceSnowflakeResult'],
                 snowsights: Sequence['outputs.GetResourceResourceSnowsightResult'],
                 sql_server_azure_ads: Sequence['outputs.GetResourceResourceSqlServerAzureAdResult'],
                 sql_server_kerberos_ads: Sequence['outputs.GetResourceResourceSqlServerKerberosAdResult'],
                 sql_servers: Sequence['outputs.GetResourceResourceSqlServerResult'],
                 ssh_certs: Sequence['outputs.GetResourceResourceSshCertResult'],
                 ssh_customer_keys: Sequence['outputs.GetResourceResourceSshCustomerKeyResult'],
                 ssh_passwords: Sequence['outputs.GetResourceResourceSshPasswordResult'],
                 sshes: Sequence['outputs.GetResourceResourceSshResult'],
                 sybase_iqs: Sequence['outputs.GetResourceResourceSybaseIqResult'],
                 sybases: Sequence['outputs.GetResourceResourceSybaseResult'],
                 teradatas: Sequence['outputs.GetResourceResourceTeradataResult'],
                 trinos: Sequence['outputs.GetResourceResourceTrinoResult'],
                 verticas: Sequence['outputs.GetResourceResourceVerticaResult']):
        pulumi.set(__self__, "aerospikes", aerospikes)
        pulumi.set(__self__, "aks", aks)
        pulumi.set(__self__, "aks_basic_auths", aks_basic_auths)
        pulumi.set(__self__, "aks_service_account_user_impersonations", aks_service_account_user_impersonations)
        pulumi.set(__self__, "aks_service_accounts", aks_service_accounts)
        pulumi.set(__self__, "aks_user_impersonations", aks_user_impersonations)
        pulumi.set(__self__, "amazon_eks", amazon_eks)
        pulumi.set(__self__, "amazon_eks_instance_profile_user_impersonations", amazon_eks_instance_profile_user_impersonations)
        pulumi.set(__self__, "amazon_eks_instance_profiles", amazon_eks_instance_profiles)
        pulumi.set(__self__, "amazon_eks_user_impersonations", amazon_eks_user_impersonations)
        pulumi.set(__self__, "amazon_es", amazon_es)
        pulumi.set(__self__, "amazon_esiams", amazon_esiams)
        pulumi.set(__self__, "amazonmq_amqp091s", amazonmq_amqp091s)
        pulumi.set(__self__, "amazonmq_amqps", amazonmq_amqps)
        pulumi.set(__self__, "athena_iams", athena_iams)
        pulumi.set(__self__, "athenas", athenas)
        pulumi.set(__self__, "aurora_mysql_iams", aurora_mysql_iams)
        pulumi.set(__self__, "aurora_mysqls", aurora_mysqls)
        pulumi.set(__self__, "aurora_postgres", aurora_postgres)
        pulumi.set(__self__, "aurora_postgres_iams", aurora_postgres_iams)
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "aws_console_static_key_pairs", aws_console_static_key_pairs)
        pulumi.set(__self__, "aws_consoles", aws_consoles)
        pulumi.set(__self__, "aws_instance_profiles", aws_instance_profiles)
        pulumi.set(__self__, "azure_certificates", azure_certificates)
        pulumi.set(__self__, "azure_consoles", azure_consoles)
        pulumi.set(__self__, "azure_mysql_managed_identities", azure_mysql_managed_identities)
        pulumi.set(__self__, "azure_mysqls", azure_mysqls)
        pulumi.set(__self__, "azure_postgres", azure_postgres)
        pulumi.set(__self__, "azure_postgres_managed_identities", azure_postgres_managed_identities)
        pulumi.set(__self__, "azures", azures)
        pulumi.set(__self__, "big_queries", big_queries)
        pulumi.set(__self__, "cassandras", cassandras)
        pulumi.set(__self__, "cituses", cituses)
        pulumi.set(__self__, "click_house_https", click_house_https)
        pulumi.set(__self__, "click_house_my_sqls", click_house_my_sqls)
        pulumi.set(__self__, "click_house_tcps", click_house_tcps)
        pulumi.set(__self__, "clustrixes", clustrixes)
        pulumi.set(__self__, "cockroaches", cockroaches)
        pulumi.set(__self__, "couchbase_databases", couchbase_databases)
        pulumi.set(__self__, "couchbase_web_uis", couchbase_web_uis)
        pulumi.set(__self__, "db2_is", db2_is)
        pulumi.set(__self__, "db2_luws", db2_luws)
        pulumi.set(__self__, "document_db_host_iams", document_db_host_iams)
        pulumi.set(__self__, "document_db_hosts", document_db_hosts)
        pulumi.set(__self__, "document_db_replica_set_iams", document_db_replica_set_iams)
        pulumi.set(__self__, "document_db_replica_sets", document_db_replica_sets)
        pulumi.set(__self__, "druids", druids)
        pulumi.set(__self__, "dynamo_dbiams", dynamo_dbiams)
        pulumi.set(__self__, "dynamo_dbs", dynamo_dbs)
        pulumi.set(__self__, "elasticache_redis", elasticache_redis)
        pulumi.set(__self__, "elastics", elastics)
        pulumi.set(__self__, "gcp_consoles", gcp_consoles)
        pulumi.set(__self__, "gcps", gcps)
        pulumi.set(__self__, "gcpwifs", gcpwifs)
        pulumi.set(__self__, "google_gke_user_impersonations", google_gke_user_impersonations)
        pulumi.set(__self__, "google_gkes", google_gkes)
        pulumi.set(__self__, "greenplums", greenplums)
        pulumi.set(__self__, "http_auths", http_auths)
        pulumi.set(__self__, "http_basic_auths", http_basic_auths)
        pulumi.set(__self__, "http_no_auths", http_no_auths)
        pulumi.set(__self__, "kubernetes", kubernetes)
        pulumi.set(__self__, "kubernetes_basic_auths", kubernetes_basic_auths)
        pulumi.set(__self__, "kubernetes_pod_identities", kubernetes_pod_identities)
        pulumi.set(__self__, "kubernetes_service_account_user_impersonations", kubernetes_service_account_user_impersonations)
        pulumi.set(__self__, "kubernetes_service_accounts", kubernetes_service_accounts)
        pulumi.set(__self__, "kubernetes_user_impersonations", kubernetes_user_impersonations)
        pulumi.set(__self__, "marias", marias)
        pulumi.set(__self__, "memcacheds", memcacheds)
        pulumi.set(__self__, "memsqls", memsqls)
        pulumi.set(__self__, "mongo_hosts", mongo_hosts)
        pulumi.set(__self__, "mongo_legacy_hosts", mongo_legacy_hosts)
        pulumi.set(__self__, "mongo_legacy_replicasets", mongo_legacy_replicasets)
        pulumi.set(__self__, "mongo_replica_sets", mongo_replica_sets)
        pulumi.set(__self__, "mongo_sharded_clusters", mongo_sharded_clusters)
        pulumi.set(__self__, "mtls_mysqls", mtls_mysqls)
        pulumi.set(__self__, "mtls_postgres", mtls_postgres)
        pulumi.set(__self__, "mysqls", mysqls)
        pulumi.set(__self__, "neptune_iams", neptune_iams)
        pulumi.set(__self__, "neptunes", neptunes)
        pulumi.set(__self__, "oracle_nnes", oracle_nnes)
        pulumi.set(__self__, "oracles", oracles)
        pulumi.set(__self__, "postgres", postgres)
        pulumi.set(__self__, "prestos", prestos)
        pulumi.set(__self__, "rabbitmq_amqp091s", rabbitmq_amqp091s)
        pulumi.set(__self__, "raw_tcps", raw_tcps)
        pulumi.set(__self__, "rdp_certs", rdp_certs)
        pulumi.set(__self__, "rdps", rdps)
        pulumi.set(__self__, "rds_postgres_iams", rds_postgres_iams)
        pulumi.set(__self__, "redis", redis)
        pulumi.set(__self__, "redis_clusters", redis_clusters)
        pulumi.set(__self__, "redshift_iams", redshift_iams)
        pulumi.set(__self__, "redshift_serverless_iams", redshift_serverless_iams)
        pulumi.set(__self__, "redshifts", redshifts)
        pulumi.set(__self__, "single_stores", single_stores)
        pulumi.set(__self__, "snowflakes", snowflakes)
        pulumi.set(__self__, "snowsights", snowsights)
        pulumi.set(__self__, "sql_server_azure_ads", sql_server_azure_ads)
        pulumi.set(__self__, "sql_server_kerberos_ads", sql_server_kerberos_ads)
        pulumi.set(__self__, "sql_servers", sql_servers)
        pulumi.set(__self__, "ssh_certs", ssh_certs)
        pulumi.set(__self__, "ssh_customer_keys", ssh_customer_keys)
        pulumi.set(__self__, "ssh_passwords", ssh_passwords)
        pulumi.set(__self__, "sshes", sshes)
        pulumi.set(__self__, "sybase_iqs", sybase_iqs)
        pulumi.set(__self__, "sybases", sybases)
        pulumi.set(__self__, "teradatas", teradatas)
        pulumi.set(__self__, "trinos", trinos)
        pulumi.set(__self__, "verticas", verticas)

    @_builtins.property
    @pulumi.getter
    def aerospikes(self) -> Sequence['outputs.GetResourceResourceAerospikeResult']:
        return pulumi.get(self, "aerospikes")

    @_builtins.property
    @pulumi.getter
    def aks(self) -> Sequence['outputs.GetResourceResourceAkResult']:
        return pulumi.get(self, "aks")

    @_builtins.property
    @pulumi.getter(name="aksBasicAuths")
    def aks_basic_auths(self) -> Sequence['outputs.GetResourceResourceAksBasicAuthResult']:
        return pulumi.get(self, "aks_basic_auths")

    @_builtins.property
    @pulumi.getter(name="aksServiceAccountUserImpersonations")
    @_utilities.deprecated("""aks_service_account_user_impersonation is deprecated, see docs for more info""")
    def aks_service_account_user_impersonations(self) -> Sequence['outputs.GetResourceResourceAksServiceAccountUserImpersonationResult']:
        return pulumi.get(self, "aks_service_account_user_impersonations")

    @_builtins.property
    @pulumi.getter(name="aksServiceAccounts")
    def aks_service_accounts(self) -> Sequence['outputs.GetResourceResourceAksServiceAccountResult']:
        return pulumi.get(self, "aks_service_accounts")

    @_builtins.property
    @pulumi.getter(name="aksUserImpersonations")
    @_utilities.deprecated("""aks_user_impersonation is deprecated, see docs for more info""")
    def aks_user_impersonations(self) -> Sequence['outputs.GetResourceResourceAksUserImpersonationResult']:
        return pulumi.get(self, "aks_user_impersonations")

    @_builtins.property
    @pulumi.getter(name="amazonEks")
    def amazon_eks(self) -> Sequence['outputs.GetResourceResourceAmazonEkResult']:
        return pulumi.get(self, "amazon_eks")

    @_builtins.property
    @pulumi.getter(name="amazonEksInstanceProfileUserImpersonations")
    @_utilities.deprecated("""amazon_eks_instance_profile_user_impersonation is deprecated, see docs for more info""")
    def amazon_eks_instance_profile_user_impersonations(self) -> Sequence['outputs.GetResourceResourceAmazonEksInstanceProfileUserImpersonationResult']:
        return pulumi.get(self, "amazon_eks_instance_profile_user_impersonations")

    @_builtins.property
    @pulumi.getter(name="amazonEksInstanceProfiles")
    def amazon_eks_instance_profiles(self) -> Sequence['outputs.GetResourceResourceAmazonEksInstanceProfileResult']:
        return pulumi.get(self, "amazon_eks_instance_profiles")

    @_builtins.property
    @pulumi.getter(name="amazonEksUserImpersonations")
    @_utilities.deprecated("""amazon_eks_user_impersonation is deprecated, see docs for more info""")
    def amazon_eks_user_impersonations(self) -> Sequence['outputs.GetResourceResourceAmazonEksUserImpersonationResult']:
        return pulumi.get(self, "amazon_eks_user_impersonations")

    @_builtins.property
    @pulumi.getter(name="amazonEs")
    def amazon_es(self) -> Sequence['outputs.GetResourceResourceAmazonEResult']:
        return pulumi.get(self, "amazon_es")

    @_builtins.property
    @pulumi.getter(name="amazonEsiams")
    def amazon_esiams(self) -> Sequence['outputs.GetResourceResourceAmazonEsiamResult']:
        return pulumi.get(self, "amazon_esiams")

    @_builtins.property
    @pulumi.getter(name="amazonmqAmqp091s")
    def amazonmq_amqp091s(self) -> Sequence['outputs.GetResourceResourceAmazonmqAmqp091Result']:
        return pulumi.get(self, "amazonmq_amqp091s")

    @_builtins.property
    @pulumi.getter(name="amazonmqAmqps")
    def amazonmq_amqps(self) -> Sequence['outputs.GetResourceResourceAmazonmqAmqpResult']:
        return pulumi.get(self, "amazonmq_amqps")

    @_builtins.property
    @pulumi.getter(name="athenaIams")
    def athena_iams(self) -> Sequence['outputs.GetResourceResourceAthenaIamResult']:
        return pulumi.get(self, "athena_iams")

    @_builtins.property
    @pulumi.getter
    def athenas(self) -> Sequence['outputs.GetResourceResourceAthenaResult']:
        return pulumi.get(self, "athenas")

    @_builtins.property
    @pulumi.getter(name="auroraMysqlIams")
    def aurora_mysql_iams(self) -> Sequence['outputs.GetResourceResourceAuroraMysqlIamResult']:
        return pulumi.get(self, "aurora_mysql_iams")

    @_builtins.property
    @pulumi.getter(name="auroraMysqls")
    def aurora_mysqls(self) -> Sequence['outputs.GetResourceResourceAuroraMysqlResult']:
        return pulumi.get(self, "aurora_mysqls")

    @_builtins.property
    @pulumi.getter(name="auroraPostgres")
    def aurora_postgres(self) -> Sequence['outputs.GetResourceResourceAuroraPostgreResult']:
        return pulumi.get(self, "aurora_postgres")

    @_builtins.property
    @pulumi.getter(name="auroraPostgresIams")
    def aurora_postgres_iams(self) -> Sequence['outputs.GetResourceResourceAuroraPostgresIamResult']:
        return pulumi.get(self, "aurora_postgres_iams")

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetResourceResourceAwResult']:
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter(name="awsConsoleStaticKeyPairs")
    def aws_console_static_key_pairs(self) -> Sequence['outputs.GetResourceResourceAwsConsoleStaticKeyPairResult']:
        return pulumi.get(self, "aws_console_static_key_pairs")

    @_builtins.property
    @pulumi.getter(name="awsConsoles")
    def aws_consoles(self) -> Sequence['outputs.GetResourceResourceAwsConsoleResult']:
        return pulumi.get(self, "aws_consoles")

    @_builtins.property
    @pulumi.getter(name="awsInstanceProfiles")
    def aws_instance_profiles(self) -> Sequence['outputs.GetResourceResourceAwsInstanceProfileResult']:
        return pulumi.get(self, "aws_instance_profiles")

    @_builtins.property
    @pulumi.getter(name="azureCertificates")
    def azure_certificates(self) -> Sequence['outputs.GetResourceResourceAzureCertificateResult']:
        return pulumi.get(self, "azure_certificates")

    @_builtins.property
    @pulumi.getter(name="azureConsoles")
    def azure_consoles(self) -> Sequence['outputs.GetResourceResourceAzureConsoleResult']:
        return pulumi.get(self, "azure_consoles")

    @_builtins.property
    @pulumi.getter(name="azureMysqlManagedIdentities")
    def azure_mysql_managed_identities(self) -> Sequence['outputs.GetResourceResourceAzureMysqlManagedIdentityResult']:
        return pulumi.get(self, "azure_mysql_managed_identities")

    @_builtins.property
    @pulumi.getter(name="azureMysqls")
    def azure_mysqls(self) -> Sequence['outputs.GetResourceResourceAzureMysqlResult']:
        return pulumi.get(self, "azure_mysqls")

    @_builtins.property
    @pulumi.getter(name="azurePostgres")
    def azure_postgres(self) -> Sequence['outputs.GetResourceResourceAzurePostgreResult']:
        return pulumi.get(self, "azure_postgres")

    @_builtins.property
    @pulumi.getter(name="azurePostgresManagedIdentities")
    def azure_postgres_managed_identities(self) -> Sequence['outputs.GetResourceResourceAzurePostgresManagedIdentityResult']:
        return pulumi.get(self, "azure_postgres_managed_identities")

    @_builtins.property
    @pulumi.getter
    def azures(self) -> Sequence['outputs.GetResourceResourceAzureResult']:
        return pulumi.get(self, "azures")

    @_builtins.property
    @pulumi.getter(name="bigQueries")
    def big_queries(self) -> Sequence['outputs.GetResourceResourceBigQueryResult']:
        return pulumi.get(self, "big_queries")

    @_builtins.property
    @pulumi.getter
    def cassandras(self) -> Sequence['outputs.GetResourceResourceCassandraResult']:
        return pulumi.get(self, "cassandras")

    @_builtins.property
    @pulumi.getter
    def cituses(self) -> Sequence['outputs.GetResourceResourceCitusResult']:
        return pulumi.get(self, "cituses")

    @_builtins.property
    @pulumi.getter(name="clickHouseHttps")
    def click_house_https(self) -> Sequence['outputs.GetResourceResourceClickHouseHttpResult']:
        return pulumi.get(self, "click_house_https")

    @_builtins.property
    @pulumi.getter(name="clickHouseMySqls")
    def click_house_my_sqls(self) -> Sequence['outputs.GetResourceResourceClickHouseMySqlResult']:
        return pulumi.get(self, "click_house_my_sqls")

    @_builtins.property
    @pulumi.getter(name="clickHouseTcps")
    def click_house_tcps(self) -> Sequence['outputs.GetResourceResourceClickHouseTcpResult']:
        return pulumi.get(self, "click_house_tcps")

    @_builtins.property
    @pulumi.getter
    def clustrixes(self) -> Sequence['outputs.GetResourceResourceClustrixResult']:
        return pulumi.get(self, "clustrixes")

    @_builtins.property
    @pulumi.getter
    def cockroaches(self) -> Sequence['outputs.GetResourceResourceCockroachResult']:
        return pulumi.get(self, "cockroaches")

    @_builtins.property
    @pulumi.getter(name="couchbaseDatabases")
    def couchbase_databases(self) -> Sequence['outputs.GetResourceResourceCouchbaseDatabaseResult']:
        return pulumi.get(self, "couchbase_databases")

    @_builtins.property
    @pulumi.getter(name="couchbaseWebUis")
    def couchbase_web_uis(self) -> Sequence['outputs.GetResourceResourceCouchbaseWebUiResult']:
        return pulumi.get(self, "couchbase_web_uis")

    @_builtins.property
    @pulumi.getter(name="db2Is")
    def db2_is(self) -> Sequence['outputs.GetResourceResourceDb2IResult']:
        return pulumi.get(self, "db2_is")

    @_builtins.property
    @pulumi.getter(name="db2Luws")
    def db2_luws(self) -> Sequence['outputs.GetResourceResourceDb2LuwResult']:
        return pulumi.get(self, "db2_luws")

    @_builtins.property
    @pulumi.getter(name="documentDbHostIams")
    def document_db_host_iams(self) -> Sequence['outputs.GetResourceResourceDocumentDbHostIamResult']:
        return pulumi.get(self, "document_db_host_iams")

    @_builtins.property
    @pulumi.getter(name="documentDbHosts")
    def document_db_hosts(self) -> Sequence['outputs.GetResourceResourceDocumentDbHostResult']:
        return pulumi.get(self, "document_db_hosts")

    @_builtins.property
    @pulumi.getter(name="documentDbReplicaSetIams")
    def document_db_replica_set_iams(self) -> Sequence['outputs.GetResourceResourceDocumentDbReplicaSetIamResult']:
        return pulumi.get(self, "document_db_replica_set_iams")

    @_builtins.property
    @pulumi.getter(name="documentDbReplicaSets")
    def document_db_replica_sets(self) -> Sequence['outputs.GetResourceResourceDocumentDbReplicaSetResult']:
        return pulumi.get(self, "document_db_replica_sets")

    @_builtins.property
    @pulumi.getter
    def druids(self) -> Sequence['outputs.GetResourceResourceDruidResult']:
        return pulumi.get(self, "druids")

    @_builtins.property
    @pulumi.getter(name="dynamoDbiams")
    def dynamo_dbiams(self) -> Sequence['outputs.GetResourceResourceDynamoDbiamResult']:
        return pulumi.get(self, "dynamo_dbiams")

    @_builtins.property
    @pulumi.getter(name="dynamoDbs")
    def dynamo_dbs(self) -> Sequence['outputs.GetResourceResourceDynamoDbResult']:
        return pulumi.get(self, "dynamo_dbs")

    @_builtins.property
    @pulumi.getter(name="elasticacheRedis")
    def elasticache_redis(self) -> Sequence['outputs.GetResourceResourceElasticacheRediResult']:
        return pulumi.get(self, "elasticache_redis")

    @_builtins.property
    @pulumi.getter
    def elastics(self) -> Sequence['outputs.GetResourceResourceElasticResult']:
        return pulumi.get(self, "elastics")

    @_builtins.property
    @pulumi.getter(name="gcpConsoles")
    def gcp_consoles(self) -> Sequence['outputs.GetResourceResourceGcpConsoleResult']:
        return pulumi.get(self, "gcp_consoles")

    @_builtins.property
    @pulumi.getter
    def gcps(self) -> Sequence['outputs.GetResourceResourceGcpResult']:
        return pulumi.get(self, "gcps")

    @_builtins.property
    @pulumi.getter
    def gcpwifs(self) -> Sequence['outputs.GetResourceResourceGcpwifResult']:
        return pulumi.get(self, "gcpwifs")

    @_builtins.property
    @pulumi.getter(name="googleGkeUserImpersonations")
    @_utilities.deprecated("""google_gke_user_impersonation is deprecated, see docs for more info""")
    def google_gke_user_impersonations(self) -> Sequence['outputs.GetResourceResourceGoogleGkeUserImpersonationResult']:
        return pulumi.get(self, "google_gke_user_impersonations")

    @_builtins.property
    @pulumi.getter(name="googleGkes")
    def google_gkes(self) -> Sequence['outputs.GetResourceResourceGoogleGkeResult']:
        return pulumi.get(self, "google_gkes")

    @_builtins.property
    @pulumi.getter
    def greenplums(self) -> Sequence['outputs.GetResourceResourceGreenplumResult']:
        return pulumi.get(self, "greenplums")

    @_builtins.property
    @pulumi.getter(name="httpAuths")
    def http_auths(self) -> Sequence['outputs.GetResourceResourceHttpAuthResult']:
        return pulumi.get(self, "http_auths")

    @_builtins.property
    @pulumi.getter(name="httpBasicAuths")
    def http_basic_auths(self) -> Sequence['outputs.GetResourceResourceHttpBasicAuthResult']:
        return pulumi.get(self, "http_basic_auths")

    @_builtins.property
    @pulumi.getter(name="httpNoAuths")
    def http_no_auths(self) -> Sequence['outputs.GetResourceResourceHttpNoAuthResult']:
        return pulumi.get(self, "http_no_auths")

    @_builtins.property
    @pulumi.getter
    def kubernetes(self) -> Sequence['outputs.GetResourceResourceKuberneteResult']:
        return pulumi.get(self, "kubernetes")

    @_builtins.property
    @pulumi.getter(name="kubernetesBasicAuths")
    def kubernetes_basic_auths(self) -> Sequence['outputs.GetResourceResourceKubernetesBasicAuthResult']:
        return pulumi.get(self, "kubernetes_basic_auths")

    @_builtins.property
    @pulumi.getter(name="kubernetesPodIdentities")
    def kubernetes_pod_identities(self) -> Sequence['outputs.GetResourceResourceKubernetesPodIdentityResult']:
        return pulumi.get(self, "kubernetes_pod_identities")

    @_builtins.property
    @pulumi.getter(name="kubernetesServiceAccountUserImpersonations")
    @_utilities.deprecated("""kubernetes_service_account_user_impersonation is deprecated, see docs for more info""")
    def kubernetes_service_account_user_impersonations(self) -> Sequence['outputs.GetResourceResourceKubernetesServiceAccountUserImpersonationResult']:
        return pulumi.get(self, "kubernetes_service_account_user_impersonations")

    @_builtins.property
    @pulumi.getter(name="kubernetesServiceAccounts")
    def kubernetes_service_accounts(self) -> Sequence['outputs.GetResourceResourceKubernetesServiceAccountResult']:
        return pulumi.get(self, "kubernetes_service_accounts")

    @_builtins.property
    @pulumi.getter(name="kubernetesUserImpersonations")
    @_utilities.deprecated("""kubernetes_user_impersonation is deprecated, see docs for more info""")
    def kubernetes_user_impersonations(self) -> Sequence['outputs.GetResourceResourceKubernetesUserImpersonationResult']:
        return pulumi.get(self, "kubernetes_user_impersonations")

    @_builtins.property
    @pulumi.getter
    def marias(self) -> Sequence['outputs.GetResourceResourceMariaResult']:
        return pulumi.get(self, "marias")

    @_builtins.property
    @pulumi.getter
    def memcacheds(self) -> Sequence['outputs.GetResourceResourceMemcachedResult']:
        return pulumi.get(self, "memcacheds")

    @_builtins.property
    @pulumi.getter
    def memsqls(self) -> Sequence['outputs.GetResourceResourceMemsqlResult']:
        return pulumi.get(self, "memsqls")

    @_builtins.property
    @pulumi.getter(name="mongoHosts")
    def mongo_hosts(self) -> Sequence['outputs.GetResourceResourceMongoHostResult']:
        return pulumi.get(self, "mongo_hosts")

    @_builtins.property
    @pulumi.getter(name="mongoLegacyHosts")
    def mongo_legacy_hosts(self) -> Sequence['outputs.GetResourceResourceMongoLegacyHostResult']:
        return pulumi.get(self, "mongo_legacy_hosts")

    @_builtins.property
    @pulumi.getter(name="mongoLegacyReplicasets")
    def mongo_legacy_replicasets(self) -> Sequence['outputs.GetResourceResourceMongoLegacyReplicasetResult']:
        return pulumi.get(self, "mongo_legacy_replicasets")

    @_builtins.property
    @pulumi.getter(name="mongoReplicaSets")
    def mongo_replica_sets(self) -> Sequence['outputs.GetResourceResourceMongoReplicaSetResult']:
        return pulumi.get(self, "mongo_replica_sets")

    @_builtins.property
    @pulumi.getter(name="mongoShardedClusters")
    def mongo_sharded_clusters(self) -> Sequence['outputs.GetResourceResourceMongoShardedClusterResult']:
        return pulumi.get(self, "mongo_sharded_clusters")

    @_builtins.property
    @pulumi.getter(name="mtlsMysqls")
    def mtls_mysqls(self) -> Sequence['outputs.GetResourceResourceMtlsMysqlResult']:
        return pulumi.get(self, "mtls_mysqls")

    @_builtins.property
    @pulumi.getter(name="mtlsPostgres")
    def mtls_postgres(self) -> Sequence['outputs.GetResourceResourceMtlsPostgreResult']:
        return pulumi.get(self, "mtls_postgres")

    @_builtins.property
    @pulumi.getter
    def mysqls(self) -> Sequence['outputs.GetResourceResourceMysqlResult']:
        return pulumi.get(self, "mysqls")

    @_builtins.property
    @pulumi.getter(name="neptuneIams")
    def neptune_iams(self) -> Sequence['outputs.GetResourceResourceNeptuneIamResult']:
        return pulumi.get(self, "neptune_iams")

    @_builtins.property
    @pulumi.getter
    def neptunes(self) -> Sequence['outputs.GetResourceResourceNeptuneResult']:
        return pulumi.get(self, "neptunes")

    @_builtins.property
    @pulumi.getter(name="oracleNnes")
    def oracle_nnes(self) -> Sequence['outputs.GetResourceResourceOracleNneResult']:
        return pulumi.get(self, "oracle_nnes")

    @_builtins.property
    @pulumi.getter
    def oracles(self) -> Sequence['outputs.GetResourceResourceOracleResult']:
        return pulumi.get(self, "oracles")

    @_builtins.property
    @pulumi.getter
    def postgres(self) -> Sequence['outputs.GetResourceResourcePostgreResult']:
        return pulumi.get(self, "postgres")

    @_builtins.property
    @pulumi.getter
    def prestos(self) -> Sequence['outputs.GetResourceResourcePrestoResult']:
        return pulumi.get(self, "prestos")

    @_builtins.property
    @pulumi.getter(name="rabbitmqAmqp091s")
    def rabbitmq_amqp091s(self) -> Sequence['outputs.GetResourceResourceRabbitmqAmqp091Result']:
        return pulumi.get(self, "rabbitmq_amqp091s")

    @_builtins.property
    @pulumi.getter(name="rawTcps")
    def raw_tcps(self) -> Sequence['outputs.GetResourceResourceRawTcpResult']:
        return pulumi.get(self, "raw_tcps")

    @_builtins.property
    @pulumi.getter(name="rdpCerts")
    def rdp_certs(self) -> Sequence['outputs.GetResourceResourceRdpCertResult']:
        return pulumi.get(self, "rdp_certs")

    @_builtins.property
    @pulumi.getter
    def rdps(self) -> Sequence['outputs.GetResourceResourceRdpResult']:
        return pulumi.get(self, "rdps")

    @_builtins.property
    @pulumi.getter(name="rdsPostgresIams")
    def rds_postgres_iams(self) -> Sequence['outputs.GetResourceResourceRdsPostgresIamResult']:
        return pulumi.get(self, "rds_postgres_iams")

    @_builtins.property
    @pulumi.getter
    def redis(self) -> Sequence['outputs.GetResourceResourceRediResult']:
        return pulumi.get(self, "redis")

    @_builtins.property
    @pulumi.getter(name="redisClusters")
    def redis_clusters(self) -> Sequence['outputs.GetResourceResourceRedisClusterResult']:
        return pulumi.get(self, "redis_clusters")

    @_builtins.property
    @pulumi.getter(name="redshiftIams")
    def redshift_iams(self) -> Sequence['outputs.GetResourceResourceRedshiftIamResult']:
        return pulumi.get(self, "redshift_iams")

    @_builtins.property
    @pulumi.getter(name="redshiftServerlessIams")
    def redshift_serverless_iams(self) -> Sequence['outputs.GetResourceResourceRedshiftServerlessIamResult']:
        return pulumi.get(self, "redshift_serverless_iams")

    @_builtins.property
    @pulumi.getter
    def redshifts(self) -> Sequence['outputs.GetResourceResourceRedshiftResult']:
        return pulumi.get(self, "redshifts")

    @_builtins.property
    @pulumi.getter(name="singleStores")
    def single_stores(self) -> Sequence['outputs.GetResourceResourceSingleStoreResult']:
        return pulumi.get(self, "single_stores")

    @_builtins.property
    @pulumi.getter
    def snowflakes(self) -> Sequence['outputs.GetResourceResourceSnowflakeResult']:
        return pulumi.get(self, "snowflakes")

    @_builtins.property
    @pulumi.getter
    def snowsights(self) -> Sequence['outputs.GetResourceResourceSnowsightResult']:
        return pulumi.get(self, "snowsights")

    @_builtins.property
    @pulumi.getter(name="sqlServerAzureAds")
    def sql_server_azure_ads(self) -> Sequence['outputs.GetResourceResourceSqlServerAzureAdResult']:
        return pulumi.get(self, "sql_server_azure_ads")

    @_builtins.property
    @pulumi.getter(name="sqlServerKerberosAds")
    def sql_server_kerberos_ads(self) -> Sequence['outputs.GetResourceResourceSqlServerKerberosAdResult']:
        return pulumi.get(self, "sql_server_kerberos_ads")

    @_builtins.property
    @pulumi.getter(name="sqlServers")
    def sql_servers(self) -> Sequence['outputs.GetResourceResourceSqlServerResult']:
        return pulumi.get(self, "sql_servers")

    @_builtins.property
    @pulumi.getter(name="sshCerts")
    def ssh_certs(self) -> Sequence['outputs.GetResourceResourceSshCertResult']:
        return pulumi.get(self, "ssh_certs")

    @_builtins.property
    @pulumi.getter(name="sshCustomerKeys")
    def ssh_customer_keys(self) -> Sequence['outputs.GetResourceResourceSshCustomerKeyResult']:
        return pulumi.get(self, "ssh_customer_keys")

    @_builtins.property
    @pulumi.getter(name="sshPasswords")
    def ssh_passwords(self) -> Sequence['outputs.GetResourceResourceSshPasswordResult']:
        return pulumi.get(self, "ssh_passwords")

    @_builtins.property
    @pulumi.getter
    def sshes(self) -> Sequence['outputs.GetResourceResourceSshResult']:
        return pulumi.get(self, "sshes")

    @_builtins.property
    @pulumi.getter(name="sybaseIqs")
    def sybase_iqs(self) -> Sequence['outputs.GetResourceResourceSybaseIqResult']:
        return pulumi.get(self, "sybase_iqs")

    @_builtins.property
    @pulumi.getter
    def sybases(self) -> Sequence['outputs.GetResourceResourceSybaseResult']:
        return pulumi.get(self, "sybases")

    @_builtins.property
    @pulumi.getter
    def teradatas(self) -> Sequence['outputs.GetResourceResourceTeradataResult']:
        return pulumi.get(self, "teradatas")

    @_builtins.property
    @pulumi.getter
    def trinos(self) -> Sequence['outputs.GetResourceResourceTrinoResult']:
        return pulumi.get(self, "trinos")

    @_builtins.property
    @pulumi.getter
    def verticas(self) -> Sequence['outputs.GetResourceResourceVerticaResult']:
        return pulumi.get(self, "verticas")


@pulumi.output_type
class GetResourceResourceAerospikeResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_services_alternate: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_services_alternate: If true, uses UseServicesAlternates directive for Aerospike connection
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_services_alternate is not None:
            pulumi.set(__self__, "use_services_alternate", use_services_alternate)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useServicesAlternate")
    def use_services_alternate(self) -> Optional[_builtins.bool]:
        """
        If true, uses UseServicesAlternates directive for Aerospike connection
        """
        return pulumi.get(self, "use_services_alternate")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAkResult(dict):
    def __init__(__self__, *,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAksBasicAuthResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAksServiceAccountResult(dict):
    def __init__(__self__, *,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetResourceResourceAksServiceAccountUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetResourceResourceAksUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEkResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str cluster_name: The name of the cluster to connect to.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEksInstanceProfileResult(dict):
    def __init__(__self__, *,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str cluster_name: The name of the cluster to connect to.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEksInstanceProfileUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str cluster_name: The name of the cluster to connect to.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEksUserImpersonationResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str cluster_name: The name of the cluster to connect to.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEsiamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")


@pulumi.output_type
class GetResourceResourceAmazonmqAmqp091Result(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAmazonmqAmqpResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAthenaResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 output: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str output: The AWS S3 output location.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional[_builtins.str]:
        """
        The AWS S3 output location.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAthenaIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 output: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str output: The AWS S3 output location.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional[_builtins.str]:
        """
        The AWS S3 output location.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAuroraMysqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAuroraMysqlIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAuroraPostgreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAuroraPostgresIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAwResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_region: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_region: The AWS region healthcheck requests should attempt to connect to.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_region is not None:
            pulumi.set(__self__, "healthcheck_region", healthcheck_region)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckRegion")
    def healthcheck_region(self) -> Optional[_builtins.str]:
        """
        The AWS region healthcheck requests should attempt to connect to.
        """
        return pulumi.get(self, "healthcheck_region")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAwsConsoleResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 enable_env_variables: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 session_expiry: Optional[_builtins.int] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool enable_env_variables: If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.int session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if enable_env_variables is not None:
            pulumi.set(__self__, "enable_env_variables", enable_env_variables)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="enableEnvVariables")
    def enable_env_variables(self) -> Optional[_builtins.bool]:
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        return pulumi.get(self, "enable_env_variables")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[_builtins.int]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAwsConsoleStaticKeyPairResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 session_expiry: Optional[_builtins.int] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.int session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[_builtins.int]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAwsInstanceProfileResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 enable_env_variables: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.bool enable_env_variables: If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if enable_env_variables is not None:
            pulumi.set(__self__, "enable_env_variables", enable_env_variables)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="enableEnvVariables")
    def enable_env_variables(self) -> Optional[_builtins.bool]:
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        return pulumi.get(self, "enable_env_variables")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAzureResult(dict):
    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str app_id: The application ID to authenticate with.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetResourceResourceAzureCertificateResult(dict):
    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str app_id: The application ID to authenticate with.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetResourceResourceAzureConsoleResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 connector_id: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 management_group_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 privilege_levels: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 subscription_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str connector_id: The connector ID to authenticate through.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str management_group_id: The management group ID to authenticate scope Privileges to.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str privilege_levels: The privilege levels specify which Groups are managed externally
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param _builtins.str subscription_id: The subscription ID to authenticate scope Privileges to.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if management_group_id is not None:
            pulumi.set(__self__, "management_group_id", management_group_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if privilege_levels is not None:
            pulumi.set(__self__, "privilege_levels", privilege_levels)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[_builtins.str]:
        """
        The connector ID to authenticate through.
        """
        return pulumi.get(self, "connector_id")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="managementGroupId")
    def management_group_id(self) -> Optional[_builtins.str]:
        """
        The management group ID to authenticate scope Privileges to.
        """
        return pulumi.get(self, "management_group_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privilegeLevels")
    def privilege_levels(self) -> Optional[_builtins.str]:
        """
        The privilege levels specify which Groups are managed externally
        """
        return pulumi.get(self, "privilege_levels")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        """
        The subscription ID to authenticate scope Privileges to.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAzureMysqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAzureMysqlManagedIdentityResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAzurePostgreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAzurePostgresManagedIdentityResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceBigQueryResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 private_key: Optional[_builtins.str] = None,
                 project: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str private_key: The private key used to authenticate with the server.
        :param _builtins.str project: The project to connect to.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[_builtins.str]:
        """
        The project to connect to.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceCassandraResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceCitusResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceClickHouseHttpResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 url: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceClickHouseMySqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceClickHouseTcpResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceClustrixResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceCockroachResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceCouchbaseDatabaseResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 n1_ql_port: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.int n1_ql_port: The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if n1_ql_port is not None:
            pulumi.set(__self__, "n1_ql_port", n1_ql_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="n1QlPort")
    def n1_ql_port(self) -> Optional[_builtins.int]:
        """
        The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.
        """
        return pulumi.get(self, "n1_ql_port")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceCouchbaseWebUiResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 url: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDb2IResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDb2LuwResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDocumentDbHostResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDocumentDbHostIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceDocumentDbReplicaSetResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 connect_to_replica: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 replica_set: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str replica_set: The name of the mongo replicaset.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[_builtins.bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[_builtins.str]:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDocumentDbReplicaSetIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 connect_to_replica: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[_builtins.bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceDruidResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDynamoDbResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceDynamoDbiamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceElasticResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceElasticacheRediResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceGcpResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 keyfile: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 scopes: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str keyfile: The service account keyfile to authenticate with.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str scopes: Space separated scopes that this login should assume into when authenticating.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def keyfile(self) -> Optional[_builtins.str]:
        """
        The service account keyfile to authenticate with.
        """
        return pulumi.get(self, "keyfile")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[_builtins.str]:
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceGcpConsoleResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 session_expiry: Optional[_builtins.int] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 workforce_pool_id: Optional[_builtins.str] = None,
                 workforce_provider_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.int session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str workforce_pool_id: The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        :param _builtins.str workforce_provider_id: The ID of the Workforce Identity Provider in GCP to use for federated authentication.
               * google_gke:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if workforce_pool_id is not None:
            pulumi.set(__self__, "workforce_pool_id", workforce_pool_id)
        if workforce_provider_id is not None:
            pulumi.set(__self__, "workforce_provider_id", workforce_provider_id)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[_builtins.int]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="workforcePoolId")
    def workforce_pool_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        """
        return pulumi.get(self, "workforce_pool_id")

    @_builtins.property
    @pulumi.getter(name="workforceProviderId")
    def workforce_provider_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Workforce Identity Provider in GCP to use for federated authentication.
        * google_gke:
        """
        return pulumi.get(self, "workforce_provider_id")


@pulumi.output_type
class GetResourceResourceGcpwifResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 project_id: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 scopes: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 session_expiry: Optional[_builtins.int] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 workforce_pool_id: Optional[_builtins.str] = None,
                 workforce_provider_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str project_id: When specified, all project scoped requests will use this Project ID, overriding the project ID specified by clients
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str scopes: Space separated scopes that this login should assume into when authenticating.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.int session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str workforce_pool_id: The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        :param _builtins.str workforce_provider_id: The ID of the Workforce Identity Provider in GCP to use for federated authentication.
               * google_gke:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if workforce_pool_id is not None:
            pulumi.set(__self__, "workforce_pool_id", workforce_pool_id)
        if workforce_provider_id is not None:
            pulumi.set(__self__, "workforce_provider_id", workforce_provider_id)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        When specified, all project scoped requests will use this Project ID, overriding the project ID specified by clients
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[_builtins.str]:
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[_builtins.int]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="workforcePoolId")
    def workforce_pool_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        """
        return pulumi.get(self, "workforce_pool_id")

    @_builtins.property
    @pulumi.getter(name="workforceProviderId")
    def workforce_provider_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Workforce Identity Provider in GCP to use for federated authentication.
        * google_gke:
        """
        return pulumi.get(self, "workforce_provider_id")


@pulumi.output_type
class GetResourceResourceGoogleGkeResult(dict):
    def __init__(__self__, *,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 service_account_key: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str service_account_key: The service account key to authenticate with.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[_builtins.str]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceGoogleGkeUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 service_account_key: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str service_account_key: The service account key to authenticate with.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[_builtins.str]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceGreenplumResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceHttpAuthResult(dict):
    def __init__(__self__, *,
                 auth_header: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 default_path: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 headers_blacklist: Optional[_builtins.str] = None,
                 healthcheck_path: Optional[_builtins.str] = None,
                 host_override: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_header: The content to set as the authorization header.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str default_path: Automatically redirect to this path upon connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param _builtins.str healthcheck_path: This path will be used to check the health of your site.
        :param _builtins.str host_override: The host header will be overwritten with this field if provided.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        """
        if auth_header is not None:
            pulumi.set(__self__, "auth_header", auth_header)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if healthcheck_path is not None:
            pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="authHeader")
    def auth_header(self) -> Optional[_builtins.str]:
        """
        The content to set as the authorization header.
        """
        return pulumi.get(self, "auth_header")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[_builtins.str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[_builtins.str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @_builtins.property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> Optional[_builtins.str]:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @_builtins.property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[_builtins.str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetResourceResourceHttpBasicAuthResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 default_path: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 headers_blacklist: Optional[_builtins.str] = None,
                 healthcheck_path: Optional[_builtins.str] = None,
                 host_override: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 url: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str default_path: Automatically redirect to this path upon connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param _builtins.str healthcheck_path: This path will be used to check the health of your site.
        :param _builtins.str host_override: The host header will be overwritten with this field if provided.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if healthcheck_path is not None:
            pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[_builtins.str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[_builtins.str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @_builtins.property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> Optional[_builtins.str]:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @_builtins.property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[_builtins.str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceHttpNoAuthResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 default_path: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 headers_blacklist: Optional[_builtins.str] = None,
                 healthcheck_path: Optional[_builtins.str] = None,
                 host_override: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str default_path: Automatically redirect to this path upon connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param _builtins.str healthcheck_path: This path will be used to check the health of your site.
        :param _builtins.str host_override: The host header will be overwritten with this field if provided.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str url: The base address of your website without the path.
               * kubernetes:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if healthcheck_path is not None:
            pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[_builtins.str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[_builtins.str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @_builtins.property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> Optional[_builtins.str]:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @_builtins.property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[_builtins.str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetResourceResourceKuberneteResult(dict):
    def __init__(__self__, *,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceKubernetesBasicAuthResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceKubernetesPodIdentityResult(dict):
    def __init__(__self__, *,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceKubernetesServiceAccountResult(dict):
    def __init__(__self__, *,
                 allow_resource_role_bypass: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 discovery_enabled: Optional[_builtins.bool] = None,
                 discovery_username: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param _builtins.str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[_builtins.bool]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[_builtins.bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[_builtins.str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetResourceResourceKubernetesServiceAccountUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetResourceResourceKubernetesUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_namespace: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[_builtins.str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceMariaResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMemcachedResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceMemsqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoHostResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoLegacyHostResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoLegacyReplicasetResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 connect_to_replica: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 replica_set: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str replica_set: The name of the mongo replicaset.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[_builtins.bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[_builtins.str]:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoReplicaSetResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 connect_to_replica: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 replica_set: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str replica_set: The name of the mongo replicaset.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[_builtins.bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[_builtins.str]:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoShardedClusterResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_database: The authentication database to use.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMtlsMysqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMtlsPostgreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 certificate_authority: Optional[_builtins.str] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str certificate_authority: The CA to authenticate TLS connections with.
        :param _builtins.str client_certificate: The certificate to authenticate TLS connections with.
        :param _builtins.str client_key: The key to authenticate TLS connections with.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[_builtins.str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMysqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceNeptuneResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceNeptuneIamResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 role_external_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str access_key: The Access Key ID to use to authenticate.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_arn: The role to assume after logging in.
        :param _builtins.str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param _builtins.str secret_access_key: The Secret Access Key to use to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[_builtins.str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceOracleResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceOracleNneResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourcePostgreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourcePrestoResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRabbitmqAmqp091Result(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRawTcpResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceRdpResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 downgrade_nla_connections: Optional[_builtins.bool] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 lock_required: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.bool downgrade_nla_connections: When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.bool lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if downgrade_nla_connections is not None:
            pulumi.set(__self__, "downgrade_nla_connections", downgrade_nla_connections)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="downgradeNlaConnections")
    def downgrade_nla_connections(self) -> Optional[_builtins.bool]:
        """
        When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        """
        return pulumi.get(self, "downgrade_nla_connections")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[_builtins.bool]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRdpCertResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 lock_required: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.bool lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[_builtins.bool]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRdsPostgresIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRediResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRedisClusterResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRedshiftResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRedshiftIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str cluster_id: Cluster Identified of Redshift cluster
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        Cluster Identified of Redshift cluster
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceRedshiftServerlessIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role_assumption_arn: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 workgroup: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str region: The AWS region to connect to.
        :param _builtins.str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str workgroup: Workgroup name in the serverless Redshift
               * single_store:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if workgroup is not None:
            pulumi.set(__self__, "workgroup", workgroup)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[_builtins.str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def workgroup(self) -> Optional[_builtins.str]:
        """
        Workgroup name in the serverless Redshift
        * single_store:
        """
        return pulumi.get(self, "workgroup")


@pulumi.output_type
class GetResourceResourceSingleStoreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 require_native_auth: Optional[_builtins.bool] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 use_azure_single_server_usernames: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[_builtins.bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[_builtins.bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSnowflakeResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 private_key: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str private_key: The private key used to authenticate with the server.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str schema: The Schema to use to direct initial requests.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "password", password)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSnowsightResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 healthcheck_username: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 saml_metadata: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str healthcheck_username: The StrongDM user email to use for healthchecks.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str saml_metadata: The Metadata for your snowflake IDP integration
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_username is not None:
            pulumi.set(__self__, "healthcheck_username", healthcheck_username)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if saml_metadata is not None:
            pulumi.set(__self__, "saml_metadata", saml_metadata)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter(name="healthcheckUsername")
    def healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The StrongDM user email to use for healthchecks.
        """
        return pulumi.get(self, "healthcheck_username")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="samlMetadata")
    def saml_metadata(self) -> Optional[_builtins.str]:
        """
        The Metadata for your snowflake IDP integration
        """
        return pulumi.get(self, "saml_metadata")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceSqlServerResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_encryption: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str schema: The Schema to use to direct initial requests.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[_builtins.bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSqlServerAzureAdResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_encryption: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str client_id: The Azure AD application (client) ID with which to authenticate.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str schema: The Schema to use to direct initial requests.
        :param _builtins.str secret: The Azure AD client secret (application password) with which to authenticate.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[_builtins.bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Azure AD application (client) ID with which to authenticate.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        The Azure AD client secret (application password) with which to authenticate.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetResourceResourceSqlServerKerberosAdResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_encryption: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 keytab: Optional[_builtins.str] = None,
                 krb_config: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_database: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 realm: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 server_spn: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str keytab: The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        :param _builtins.str krb_config: The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str realm: The Active Directory domain (realm) to which the configured username belongs.
        :param _builtins.str schema: The Schema to use to direct initial requests.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str server_spn: The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keytab is not None:
            pulumi.set(__self__, "keytab", keytab)
        if krb_config is not None:
            pulumi.set(__self__, "krb_config", krb_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_spn is not None:
            pulumi.set(__self__, "server_spn", server_spn)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[_builtins.bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def keytab(self) -> Optional[_builtins.str]:
        """
        The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        """
        return pulumi.get(self, "keytab")

    @_builtins.property
    @pulumi.getter(name="krbConfig")
    def krb_config(self) -> Optional[_builtins.str]:
        """
        The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        """
        return pulumi.get(self, "krb_config")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[_builtins.bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter
    def realm(self) -> Optional[_builtins.str]:
        """
        The Active Directory domain (realm) to which the configured username belongs.
        """
        return pulumi.get(self, "realm")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="serverSpn")
    def server_spn(self) -> Optional[_builtins.str]:
        """
        The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        """
        return pulumi.get(self, "server_spn")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSshResult(dict):
    def __init__(__self__, *,
                 public_key: _builtins.str,
                 allow_deprecated_key_exchanges: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 key_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_forwarding: Optional[_builtins.bool] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str public_key: The public key to append to a server's authorized keys. This will be generated after resource creation.
        :param _builtins.bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str key_type: The key type to use e.g. rsa-2048 or ed25519
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool port_forwarding: Whether port forwarding is allowed through this server.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        pulumi.set(__self__, "public_key", public_key)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> _builtins.str:
        """
        The public key to append to a server's authorized keys. This will be generated after resource creation.
        """
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[_builtins.bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[_builtins.str]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[_builtins.bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSshCertResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_key_exchanges: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 key_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_forwarding: Optional[_builtins.bool] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str key_type: The key type to use e.g. rsa-2048 or ed25519
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool port_forwarding: Whether port forwarding is allowed through this server.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[_builtins.bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[_builtins.str]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[_builtins.bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSshCustomerKeyResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_key_exchanges: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 identity_alias_healthcheck_username: Optional[_builtins.str] = None,
                 identity_set_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_forwarding: Optional[_builtins.bool] = None,
                 port_override: Optional[_builtins.int] = None,
                 private_key: Optional[_builtins.str] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param _builtins.str identity_set_id: The ID of the identity set to use for identity connections.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool port_forwarding: Whether port forwarding is allowed through this server.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str private_key: The private key used to authenticate with the server.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[_builtins.bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[_builtins.str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[_builtins.bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSshPasswordResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_key_exchanges: Optional[_builtins.bool] = None,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_forwarding: Optional[_builtins.bool] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.bool port_forwarding: Whether port forwarding is allowed through this server.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[_builtins.bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[_builtins.bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSybaseResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSybaseIqResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceTeradataResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceTrinoResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tls_required: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.bool tls_required: If set, TLS must be used to connect to this resource.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[_builtins.bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceVerticaResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 egress_filter: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_override: Optional[_builtins.int] = None,
                 proxy_cluster_id: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 subdomain: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param _builtins.str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param _builtins.str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param _builtins.str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param _builtins.str id: Unique identifier of the Resource.
        :param _builtins.str name: Unique human-readable name of the Resource.
        :param _builtins.str password: The password to authenticate with.
        :param _builtins.int port: The port to dial to initiate a connection from the egress node to this resource.
        :param _builtins.int port_override: The local port used by clients to connect to this resource.
        :param _builtins.str proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param _builtins.str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param _builtins.str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[_builtins.str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[_builtins.int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[_builtins.str]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[_builtins.str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetRoleRoleResult(dict):
    def __init__(__self__, *,
                 managed_by: _builtins.str,
                 access_rules: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str managed_by: Managed By is a read only field for what service manages this role, e.g. StrongDM, Okta, Azure.
        :param _builtins.str access_rules: AccessRules is a list of access rules defining the resources this Role has access to.
        :param _builtins.str id: Unique identifier of the Role.
        :param _builtins.str name: Unique human-readable name of the Role.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "managed_by", managed_by)
        if access_rules is not None:
            pulumi.set(__self__, "access_rules", access_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="managedBy")
    def managed_by(self) -> _builtins.str:
        """
        Managed By is a read only field for what service manages this role, e.g. StrongDM, Okta, Azure.
        """
        return pulumi.get(self, "managed_by")

    @_builtins.property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> Optional[_builtins.str]:
        """
        AccessRules is a list of access rules defining the resources this Role has access to.
        """
        return pulumi.get(self, "access_rules")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Role.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Role.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretEngineSecretEngineResult(dict):
    def __init__(__self__, *,
                 active_directories: Sequence['outputs.GetSecretEngineSecretEngineActiveDirectoryResult'],
                 key_values: Sequence['outputs.GetSecretEngineSecretEngineKeyValueResult']):
        pulumi.set(__self__, "active_directories", active_directories)
        pulumi.set(__self__, "key_values", key_values)

    @_builtins.property
    @pulumi.getter(name="activeDirectories")
    def active_directories(self) -> Sequence['outputs.GetSecretEngineSecretEngineActiveDirectoryResult']:
        return pulumi.get(self, "active_directories")

    @_builtins.property
    @pulumi.getter(name="keyValues")
    def key_values(self) -> Sequence['outputs.GetSecretEngineSecretEngineKeyValueResult']:
        return pulumi.get(self, "key_values")


@pulumi.output_type
class GetSecretEngineSecretEngineActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 public_key: _builtins.str,
                 after_read_ttl: Optional[_builtins.str] = None,
                 binddn: Optional[_builtins.str] = None,
                 bindpass: Optional[_builtins.str] = None,
                 certificate: Optional[_builtins.str] = None,
                 connection_timeout: Optional[_builtins.int] = None,
                 do_not_validate_timestamps: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 insecure_tls: Optional[_builtins.bool] = None,
                 key_rotation_interval_days: Optional[_builtins.int] = None,
                 max_backoff_duration: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 request_timeout: Optional[_builtins.int] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 secret_store_root_path: Optional[_builtins.str] = None,
                 start_tls: Optional[_builtins.bool] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 ttl: Optional[_builtins.str] = None,
                 upndomain: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 userdn: Optional[_builtins.str] = None):
        """
        :param _builtins.str public_key: Public key linked with a secret engine
        :param _builtins.str after_read_ttl: The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        :param _builtins.str binddn: Distinguished name of object to bind when performing user and group search. Example: cn=vault,ou=Users,dc=example,dc=com
        :param _builtins.str bindpass: Password to use along with binddn when performing user search.
        :param _builtins.str certificate: CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.
        :param _builtins.int connection_timeout: Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
        :param _builtins.bool do_not_validate_timestamps: If set to true this will prevent password change timestamp validation in Active Directory when validating credentials
        :param _builtins.str id: Unique identifier of the Secret Engine.
        :param _builtins.bool insecure_tls: If true, skips LDAP server SSL certificate verification - insecure, use with caution!
        :param _builtins.int key_rotation_interval_days: An interval of public/private key rotation for secret engine in days
        :param _builtins.str max_backoff_duration: The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will be retried in an increasing intervals until it reaches max_backoff_duration
        :param _builtins.str name: Unique human-readable name of the Secret Engine.
        :param _builtins.int request_timeout: Timeout, in seconds, for the connection when making requests against the server before returning back an error.
        :param _builtins.str secret_store_id: Backing secret store identifier
        :param _builtins.str secret_store_root_path: Backing Secret Store root path where managed secrets are going to be stored
        :param _builtins.bool start_tls: If true, issues a StartTLS command after establishing an unencrypted connection.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str ttl: The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        :param _builtins.str upndomain: The domain (userPrincipalDomain) used to construct a UPN string for authentication.
        :param _builtins.str url: The LDAP server to connect to.
        :param _builtins.str userdn: Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com
        """
        pulumi.set(__self__, "public_key", public_key)
        if after_read_ttl is not None:
            pulumi.set(__self__, "after_read_ttl", after_read_ttl)
        if binddn is not None:
            pulumi.set(__self__, "binddn", binddn)
        if bindpass is not None:
            pulumi.set(__self__, "bindpass", bindpass)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if do_not_validate_timestamps is not None:
            pulumi.set(__self__, "do_not_validate_timestamps", do_not_validate_timestamps)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure_tls is not None:
            pulumi.set(__self__, "insecure_tls", insecure_tls)
        if key_rotation_interval_days is not None:
            pulumi.set(__self__, "key_rotation_interval_days", key_rotation_interval_days)
        if max_backoff_duration is not None:
            pulumi.set(__self__, "max_backoff_duration", max_backoff_duration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if secret_store_root_path is not None:
            pulumi.set(__self__, "secret_store_root_path", secret_store_root_path)
        if start_tls is not None:
            pulumi.set(__self__, "start_tls", start_tls)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if upndomain is not None:
            pulumi.set(__self__, "upndomain", upndomain)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if userdn is not None:
            pulumi.set(__self__, "userdn", userdn)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> _builtins.str:
        """
        Public key linked with a secret engine
        """
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter(name="afterReadTtl")
    def after_read_ttl(self) -> Optional[_builtins.str]:
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        return pulumi.get(self, "after_read_ttl")

    @_builtins.property
    @pulumi.getter
    def binddn(self) -> Optional[_builtins.str]:
        """
        Distinguished name of object to bind when performing user and group search. Example: cn=vault,ou=Users,dc=example,dc=com
        """
        return pulumi.get(self, "binddn")

    @_builtins.property
    @pulumi.getter
    def bindpass(self) -> Optional[_builtins.str]:
        """
        Password to use along with binddn when performing user search.
        """
        return pulumi.get(self, "bindpass")

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[_builtins.str]:
        """
        CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
        """
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="doNotValidateTimestamps")
    def do_not_validate_timestamps(self) -> Optional[_builtins.bool]:
        """
        If set to true this will prevent password change timestamp validation in Active Directory when validating credentials
        """
        return pulumi.get(self, "do_not_validate_timestamps")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Secret Engine.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="insecureTls")
    def insecure_tls(self) -> Optional[_builtins.bool]:
        """
        If true, skips LDAP server SSL certificate verification - insecure, use with caution!
        """
        return pulumi.get(self, "insecure_tls")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalDays")
    def key_rotation_interval_days(self) -> Optional[_builtins.int]:
        """
        An interval of public/private key rotation for secret engine in days
        """
        return pulumi.get(self, "key_rotation_interval_days")

    @_builtins.property
    @pulumi.getter(name="maxBackoffDuration")
    def max_backoff_duration(self) -> Optional[_builtins.str]:
        """
        The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will be retried in an increasing intervals until it reaches max_backoff_duration
        """
        return pulumi.get(self, "max_backoff_duration")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Secret Engine.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout, in seconds, for the connection when making requests against the server before returning back an error.
        """
        return pulumi.get(self, "request_timeout")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        Backing secret store identifier
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreRootPath")
    def secret_store_root_path(self) -> Optional[_builtins.str]:
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        return pulumi.get(self, "secret_store_root_path")

    @_builtins.property
    @pulumi.getter(name="startTls")
    def start_tls(self) -> Optional[_builtins.bool]:
        """
        If true, issues a StartTLS command after establishing an unencrypted connection.
        """
        return pulumi.get(self, "start_tls")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter
    def upndomain(self) -> Optional[_builtins.str]:
        """
        The domain (userPrincipalDomain) used to construct a UPN string for authentication.
        """
        return pulumi.get(self, "upndomain")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The LDAP server to connect to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def userdn(self) -> Optional[_builtins.str]:
        """
        Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com
        """
        return pulumi.get(self, "userdn")


@pulumi.output_type
class GetSecretEngineSecretEngineKeyValueResult(dict):
    def __init__(__self__, *,
                 public_key: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 key_rotation_interval_days: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 secret_store_id: Optional[_builtins.str] = None,
                 secret_store_root_path: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str public_key: Public key linked with a secret engine
        :param _builtins.str id: Unique identifier of the Secret Engine.
        :param _builtins.int key_rotation_interval_days: An interval of public/private key rotation for secret engine in days
        :param _builtins.str name: Unique human-readable name of the Secret Engine.
        :param _builtins.str secret_store_id: Backing secret store identifier
        :param _builtins.str secret_store_root_path: Backing Secret Store root path where managed secrets are going to be stored
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "public_key", public_key)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_rotation_interval_days is not None:
            pulumi.set(__self__, "key_rotation_interval_days", key_rotation_interval_days)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if secret_store_root_path is not None:
            pulumi.set(__self__, "secret_store_root_path", secret_store_root_path)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> _builtins.str:
        """
        Public key linked with a secret engine
        """
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Secret Engine.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalDays")
    def key_rotation_interval_days(self) -> Optional[_builtins.int]:
        """
        An interval of public/private key rotation for secret engine in days
        """
        return pulumi.get(self, "key_rotation_interval_days")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Secret Engine.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[_builtins.str]:
        """
        Backing secret store identifier
        """
        return pulumi.get(self, "secret_store_id")

    @_builtins.property
    @pulumi.getter(name="secretStoreRootPath")
    def secret_store_root_path(self) -> Optional[_builtins.str]:
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        return pulumi.get(self, "secret_store_root_path")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreResult(dict):
    def __init__(__self__, *,
                 active_directory_stores: Sequence['outputs.GetSecretStoreSecretStoreActiveDirectoryStoreResult'],
                 aws: Sequence['outputs.GetSecretStoreSecretStoreAwResult'],
                 aws_cert_x509s: Sequence['outputs.GetSecretStoreSecretStoreAwsCertX509Result'],
                 azure_stores: Sequence['outputs.GetSecretStoreSecretStoreAzureStoreResult'],
                 cyberark_conjurs: Sequence['outputs.GetSecretStoreSecretStoreCyberarkConjurResult'],
                 cyberark_pam_experimentals: Sequence['outputs.GetSecretStoreSecretStoreCyberarkPamExperimentalResult'],
                 cyberark_pams: Sequence['outputs.GetSecretStoreSecretStoreCyberarkPamResult'],
                 delinea_stores: Sequence['outputs.GetSecretStoreSecretStoreDelineaStoreResult'],
                 gcp_cert_x509_stores: Sequence['outputs.GetSecretStoreSecretStoreGcpCertX509StoreResult'],
                 gcp_stores: Sequence['outputs.GetSecretStoreSecretStoreGcpStoreResult'],
                 keyfactor_ssh_stores: Sequence['outputs.GetSecretStoreSecretStoreKeyfactorSshStoreResult'],
                 keyfactor_x509_stores: Sequence['outputs.GetSecretStoreSecretStoreKeyfactorX509StoreResult'],
                 vault_approle_cert_sshes: Sequence['outputs.GetSecretStoreSecretStoreVaultApproleCertSshResult'],
                 vault_approle_cert_x509s: Sequence['outputs.GetSecretStoreSecretStoreVaultApproleCertX509Result'],
                 vault_approles: Sequence['outputs.GetSecretStoreSecretStoreVaultApproleResult'],
                 vault_aws_ec2s: Sequence['outputs.GetSecretStoreSecretStoreVaultAwsEc2Result'],
                 vault_aws_iams: Sequence['outputs.GetSecretStoreSecretStoreVaultAwsIamResult'],
                 vault_tls: Sequence['outputs.GetSecretStoreSecretStoreVaultTlResult'],
                 vault_tls_cert_sshes: Sequence['outputs.GetSecretStoreSecretStoreVaultTlsCertSshResult'],
                 vault_tls_cert_x509s: Sequence['outputs.GetSecretStoreSecretStoreVaultTlsCertX509Result'],
                 vault_token_cert_sshes: Sequence['outputs.GetSecretStoreSecretStoreVaultTokenCertSshResult'],
                 vault_token_cert_x509s: Sequence['outputs.GetSecretStoreSecretStoreVaultTokenCertX509Result'],
                 vault_tokens: Sequence['outputs.GetSecretStoreSecretStoreVaultTokenResult']):
        pulumi.set(__self__, "active_directory_stores", active_directory_stores)
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "aws_cert_x509s", aws_cert_x509s)
        pulumi.set(__self__, "azure_stores", azure_stores)
        pulumi.set(__self__, "cyberark_conjurs", cyberark_conjurs)
        pulumi.set(__self__, "cyberark_pam_experimentals", cyberark_pam_experimentals)
        pulumi.set(__self__, "cyberark_pams", cyberark_pams)
        pulumi.set(__self__, "delinea_stores", delinea_stores)
        pulumi.set(__self__, "gcp_cert_x509_stores", gcp_cert_x509_stores)
        pulumi.set(__self__, "gcp_stores", gcp_stores)
        pulumi.set(__self__, "keyfactor_ssh_stores", keyfactor_ssh_stores)
        pulumi.set(__self__, "keyfactor_x509_stores", keyfactor_x509_stores)
        pulumi.set(__self__, "vault_approle_cert_sshes", vault_approle_cert_sshes)
        pulumi.set(__self__, "vault_approle_cert_x509s", vault_approle_cert_x509s)
        pulumi.set(__self__, "vault_approles", vault_approles)
        pulumi.set(__self__, "vault_aws_ec2s", vault_aws_ec2s)
        pulumi.set(__self__, "vault_aws_iams", vault_aws_iams)
        pulumi.set(__self__, "vault_tls", vault_tls)
        pulumi.set(__self__, "vault_tls_cert_sshes", vault_tls_cert_sshes)
        pulumi.set(__self__, "vault_tls_cert_x509s", vault_tls_cert_x509s)
        pulumi.set(__self__, "vault_token_cert_sshes", vault_token_cert_sshes)
        pulumi.set(__self__, "vault_token_cert_x509s", vault_token_cert_x509s)
        pulumi.set(__self__, "vault_tokens", vault_tokens)

    @_builtins.property
    @pulumi.getter(name="activeDirectoryStores")
    def active_directory_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreActiveDirectoryStoreResult']:
        return pulumi.get(self, "active_directory_stores")

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetSecretStoreSecretStoreAwResult']:
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter(name="awsCertX509s")
    def aws_cert_x509s(self) -> Sequence['outputs.GetSecretStoreSecretStoreAwsCertX509Result']:
        return pulumi.get(self, "aws_cert_x509s")

    @_builtins.property
    @pulumi.getter(name="azureStores")
    def azure_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreAzureStoreResult']:
        return pulumi.get(self, "azure_stores")

    @_builtins.property
    @pulumi.getter(name="cyberarkConjurs")
    def cyberark_conjurs(self) -> Sequence['outputs.GetSecretStoreSecretStoreCyberarkConjurResult']:
        return pulumi.get(self, "cyberark_conjurs")

    @_builtins.property
    @pulumi.getter(name="cyberarkPamExperimentals")
    def cyberark_pam_experimentals(self) -> Sequence['outputs.GetSecretStoreSecretStoreCyberarkPamExperimentalResult']:
        return pulumi.get(self, "cyberark_pam_experimentals")

    @_builtins.property
    @pulumi.getter(name="cyberarkPams")
    def cyberark_pams(self) -> Sequence['outputs.GetSecretStoreSecretStoreCyberarkPamResult']:
        return pulumi.get(self, "cyberark_pams")

    @_builtins.property
    @pulumi.getter(name="delineaStores")
    def delinea_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreDelineaStoreResult']:
        return pulumi.get(self, "delinea_stores")

    @_builtins.property
    @pulumi.getter(name="gcpCertX509Stores")
    def gcp_cert_x509_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreGcpCertX509StoreResult']:
        return pulumi.get(self, "gcp_cert_x509_stores")

    @_builtins.property
    @pulumi.getter(name="gcpStores")
    def gcp_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreGcpStoreResult']:
        return pulumi.get(self, "gcp_stores")

    @_builtins.property
    @pulumi.getter(name="keyfactorSshStores")
    def keyfactor_ssh_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreKeyfactorSshStoreResult']:
        return pulumi.get(self, "keyfactor_ssh_stores")

    @_builtins.property
    @pulumi.getter(name="keyfactorX509Stores")
    def keyfactor_x509_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreKeyfactorX509StoreResult']:
        return pulumi.get(self, "keyfactor_x509_stores")

    @_builtins.property
    @pulumi.getter(name="vaultApproleCertSshes")
    def vault_approle_cert_sshes(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultApproleCertSshResult']:
        return pulumi.get(self, "vault_approle_cert_sshes")

    @_builtins.property
    @pulumi.getter(name="vaultApproleCertX509s")
    def vault_approle_cert_x509s(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultApproleCertX509Result']:
        return pulumi.get(self, "vault_approle_cert_x509s")

    @_builtins.property
    @pulumi.getter(name="vaultApproles")
    def vault_approles(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultApproleResult']:
        return pulumi.get(self, "vault_approles")

    @_builtins.property
    @pulumi.getter(name="vaultAwsEc2s")
    def vault_aws_ec2s(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultAwsEc2Result']:
        return pulumi.get(self, "vault_aws_ec2s")

    @_builtins.property
    @pulumi.getter(name="vaultAwsIams")
    def vault_aws_iams(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultAwsIamResult']:
        return pulumi.get(self, "vault_aws_iams")

    @_builtins.property
    @pulumi.getter(name="vaultTls")
    def vault_tls(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTlResult']:
        return pulumi.get(self, "vault_tls")

    @_builtins.property
    @pulumi.getter(name="vaultTlsCertSshes")
    def vault_tls_cert_sshes(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTlsCertSshResult']:
        return pulumi.get(self, "vault_tls_cert_sshes")

    @_builtins.property
    @pulumi.getter(name="vaultTlsCertX509s")
    def vault_tls_cert_x509s(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTlsCertX509Result']:
        return pulumi.get(self, "vault_tls_cert_x509s")

    @_builtins.property
    @pulumi.getter(name="vaultTokenCertSshes")
    def vault_token_cert_sshes(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTokenCertSshResult']:
        return pulumi.get(self, "vault_token_cert_sshes")

    @_builtins.property
    @pulumi.getter(name="vaultTokenCertX509s")
    def vault_token_cert_x509s(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTokenCertX509Result']:
        return pulumi.get(self, "vault_token_cert_x509s")

    @_builtins.property
    @pulumi.getter(name="vaultTokens")
    def vault_tokens(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTokenResult']:
        return pulumi.get(self, "vault_tokens")


@pulumi.output_type
class GetSecretStoreSecretStoreActiveDirectoryStoreResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreAwResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str region: The AWS region to target e.g. us-east-1
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreAwsCertX509Result(dict):
    def __init__(__self__, *,
                 ca_arn: Optional[_builtins.str] = None,
                 certificate_template_arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 issued_cert_ttl_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 signing_algo: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ca_arn: The ARN of the CA in AWS Private CA
        :param _builtins.str certificate_template_arn: The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str region: The AWS region to target e.g. us-east-1
        :param _builtins.str signing_algo: The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if ca_arn is not None:
            pulumi.set(__self__, "ca_arn", ca_arn)
        if certificate_template_arn is not None:
            pulumi.set(__self__, "certificate_template_arn", certificate_template_arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if signing_algo is not None:
            pulumi.set(__self__, "signing_algo", signing_algo)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caArn")
    def ca_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the CA in AWS Private CA
        """
        return pulumi.get(self, "ca_arn")

    @_builtins.property
    @pulumi.getter(name="certificateTemplateArn")
    def certificate_template_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        """
        return pulumi.get(self, "certificate_template_arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="signingAlgo")
    def signing_algo(self) -> Optional[_builtins.str]:
        """
        The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        """
        return pulumi.get(self, "signing_algo")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreAzureStoreResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 vault_uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str vault_uri: The URI of the key vault to target e.g. https://myvault.vault.azure.net
               * cyberark_conjur:
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vault_uri is not None:
            pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> Optional[_builtins.str]:
        """
        The URI of the key vault to target e.g. https://myvault.vault.azure.net
        * cyberark_conjur:
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class GetSecretStoreSecretStoreCyberarkConjurResult(dict):
    def __init__(__self__, *,
                 app_url: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str app_url: The URL of the Cyberark instance
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if app_url is not None:
            pulumi.set(__self__, "app_url", app_url)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreCyberarkPamResult(dict):
    def __init__(__self__, *,
                 app_url: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str app_url: The URL of the Cyberark instance
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if app_url is not None:
            pulumi.set(__self__, "app_url", app_url)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreCyberarkPamExperimentalResult(dict):
    def __init__(__self__, *,
                 app_url: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str app_url: The URL of the Cyberark instance
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if app_url is not None:
            pulumi.set(__self__, "app_url", app_url)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreDelineaStoreResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 server_url: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tenant_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_url: The URL of the Delinea instance
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        :param _builtins.str tenant_name: The tenant name to target
               * gcp_store:
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Delinea instance
        """
        return pulumi.get(self, "server_url")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[_builtins.str]:
        """
        The tenant name to target
        * gcp_store:
        """
        return pulumi.get(self, "tenant_name")


@pulumi.output_type
class GetSecretStoreSecretStoreGcpCertX509StoreResult(dict):
    def __init__(__self__, *,
                 ca_id: Optional[_builtins.str] = None,
                 ca_pool_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 issued_cert_ttl_minutes: Optional[_builtins.int] = None,
                 location: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ca_id: The ID of the target CA
        :param _builtins.str ca_pool_id: The ID of the target CA pool
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str location: The Region for the CA in GCP format e.g. us-west1
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str project_id: The GCP project ID to target.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if ca_id is not None:
            pulumi.set(__self__, "ca_id", ca_id)
        if ca_pool_id is not None:
            pulumi.set(__self__, "ca_pool_id", ca_pool_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caId")
    def ca_id(self) -> Optional[_builtins.str]:
        """
        The ID of the target CA
        """
        return pulumi.get(self, "ca_id")

    @_builtins.property
    @pulumi.getter(name="caPoolId")
    def ca_pool_id(self) -> Optional[_builtins.str]:
        """
        The ID of the target CA pool
        """
        return pulumi.get(self, "ca_pool_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        The Region for the CA in GCP format e.g. us-west1
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreGcpStoreResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str project_id: The GCP project ID to target.
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreKeyfactorSshStoreResult(dict):
    def __init__(__self__, *,
                 ca_file_path: Optional[_builtins.str] = None,
                 certificate_file_path: Optional[_builtins.str] = None,
                 default_certificate_authority_name: Optional[_builtins.str] = None,
                 default_certificate_profile_name: Optional[_builtins.str] = None,
                 default_end_entity_profile_name: Optional[_builtins.str] = None,
                 enrollment_code_env_var: Optional[_builtins.str] = None,
                 enrollment_username_env_var: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 key_file_path: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param _builtins.str certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param _builtins.str default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param _builtins.str default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param _builtins.str default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param _builtins.str enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param _builtins.str enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if certificate_file_path is not None:
            pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        if default_certificate_authority_name is not None:
            pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        if default_certificate_profile_name is not None:
            pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        if default_end_entity_profile_name is not None:
            pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[_builtins.str]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @_builtins.property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> Optional[_builtins.str]:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @_builtins.property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> Optional[_builtins.str]:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @_builtins.property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> Optional[_builtins.str]:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @_builtins.property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> Optional[_builtins.str]:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @_builtins.property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[_builtins.str]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @_builtins.property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[_builtins.str]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[_builtins.str]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreKeyfactorX509StoreResult(dict):
    def __init__(__self__, *,
                 ca_file_path: Optional[_builtins.str] = None,
                 certificate_file_path: Optional[_builtins.str] = None,
                 default_certificate_authority_name: Optional[_builtins.str] = None,
                 default_certificate_profile_name: Optional[_builtins.str] = None,
                 default_end_entity_profile_name: Optional[_builtins.str] = None,
                 enrollment_code_env_var: Optional[_builtins.str] = None,
                 enrollment_username_env_var: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 key_file_path: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param _builtins.str certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param _builtins.str default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param _builtins.str default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param _builtins.str default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param _builtins.str enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param _builtins.str enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str server_address: The URL of the Vault to target
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if certificate_file_path is not None:
            pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        if default_certificate_authority_name is not None:
            pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        if default_certificate_profile_name is not None:
            pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        if default_end_entity_profile_name is not None:
            pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[_builtins.str]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @_builtins.property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> Optional[_builtins.str]:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @_builtins.property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> Optional[_builtins.str]:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @_builtins.property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> Optional[_builtins.str]:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @_builtins.property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> Optional[_builtins.str]:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @_builtins.property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[_builtins.str]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @_builtins.property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[_builtins.str]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[_builtins.str]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultApproleResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str server_address: The URL of the Vault to target
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultApproleCertSshResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 issued_cert_ttl_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 signing_role: Optional[_builtins.str] = None,
                 ssh_mount_point: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param _builtins.str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if ssh_mount_point is not None:
            pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultApproleCertX509Result(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 issued_cert_ttl_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 pki_mount_point: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 signing_role: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if pki_mount_point is not None:
            pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultAwsEc2Result(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str server_address: The URL of the Vault to target
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultAwsIamResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str server_address: The URL of the Vault to target
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTlResult(dict):
    def __init__(__self__, *,
                 ca_cert_path: Optional[_builtins.str] = None,
                 client_cert_path: Optional[_builtins.str] = None,
                 client_key_path: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ca_cert_path: A path to a CA file accessible by a Node
        :param _builtins.str client_cert_path: A path to a client certificate file accessible by a Node
        :param _builtins.str client_key_path: A path to a client key file accessible by a Node
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str server_address: The URL of the Vault to target
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if client_cert_path is not None:
            pulumi.set(__self__, "client_cert_path", client_cert_path)
        if client_key_path is not None:
            pulumi.set(__self__, "client_key_path", client_key_path)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[_builtins.str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @_builtins.property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> Optional[_builtins.str]:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @_builtins.property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> Optional[_builtins.str]:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTlsCertSshResult(dict):
    def __init__(__self__, *,
                 ca_cert_path: Optional[_builtins.str] = None,
                 client_cert_path: Optional[_builtins.str] = None,
                 client_key_path: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 issued_cert_ttl_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 signing_role: Optional[_builtins.str] = None,
                 ssh_mount_point: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ca_cert_path: A path to a CA file accessible by a Node
        :param _builtins.str client_cert_path: A path to a client certificate file accessible by a Node
        :param _builtins.str client_key_path: A path to a client key file accessible by a Node
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param _builtins.str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if client_cert_path is not None:
            pulumi.set(__self__, "client_cert_path", client_cert_path)
        if client_key_path is not None:
            pulumi.set(__self__, "client_key_path", client_key_path)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if ssh_mount_point is not None:
            pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[_builtins.str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @_builtins.property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> Optional[_builtins.str]:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @_builtins.property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> Optional[_builtins.str]:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTlsCertX509Result(dict):
    def __init__(__self__, *,
                 ca_cert_path: Optional[_builtins.str] = None,
                 client_cert_path: Optional[_builtins.str] = None,
                 client_key_path: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 issued_cert_ttl_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 pki_mount_point: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 signing_role: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ca_cert_path: A path to a CA file accessible by a Node
        :param _builtins.str client_cert_path: A path to a client certificate file accessible by a Node
        :param _builtins.str client_key_path: A path to a client key file accessible by a Node
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if client_cert_path is not None:
            pulumi.set(__self__, "client_cert_path", client_cert_path)
        if client_key_path is not None:
            pulumi.set(__self__, "client_key_path", client_key_path)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if pki_mount_point is not None:
            pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[_builtins.str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @_builtins.property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> Optional[_builtins.str]:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @_builtins.property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> Optional[_builtins.str]:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTokenResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str server_address: The URL of the Vault to target
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTokenCertSshResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 issued_cert_ttl_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 signing_role: Optional[_builtins.str] = None,
                 ssh_mount_point: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param _builtins.str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if ssh_mount_point is not None:
            pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTokenCertX509Result(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 issued_cert_ttl_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 pki_mount_point: Optional[_builtins.str] = None,
                 server_address: Optional[_builtins.str] = None,
                 signing_role: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str id: Unique identifier of the SecretStore.
        :param _builtins.int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param _builtins.str name: Unique human-readable name of the SecretStore.
        :param _builtins.str namespace: The namespace to make requests within
        :param _builtins.str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param _builtins.str server_address: The URL of the Vault to target
        :param _builtins.str signing_role: The signing role to be used for signing certificates
        :param Mapping[str, _builtins.str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if pki_mount_point is not None:
            pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> Optional[_builtins.str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetWorkflowApproverWorkflowApproverResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 role_id: Optional[_builtins.str] = None,
                 workflow_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_id: The approver account id.
        :param _builtins.str id: Unique identifier of the WorkflowApprover.
        :param _builtins.str role_id: The approver role id
        :param _builtins.str workflow_id: The workflow id.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if workflow_id is not None:
            pulumi.set(__self__, "workflow_id", workflow_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        The approver account id.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the WorkflowApprover.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        The approver role id
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> Optional[_builtins.str]:
        """
        The workflow id.
        """
        return pulumi.get(self, "workflow_id")


@pulumi.output_type
class GetWorkflowRoleWorkflowRoleResult(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 role_id: Optional[_builtins.str] = None,
                 workflow_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique identifier of the WorkflowRole.
        :param _builtins.str role_id: The role id.
        :param _builtins.str workflow_id: The workflow id.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if workflow_id is not None:
            pulumi.set(__self__, "workflow_id", workflow_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the WorkflowRole.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        The role id.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> Optional[_builtins.str]:
        """
        The workflow id.
        """
        return pulumi.get(self, "workflow_id")


@pulumi.output_type
class GetWorkflowWorkflowResult(dict):
    def __init__(__self__, *,
                 access_request_fixed_duration: Optional[_builtins.str] = None,
                 access_request_max_duration: Optional[_builtins.str] = None,
                 access_rules: Optional[_builtins.str] = None,
                 approval_flow_id: Optional[_builtins.str] = None,
                 auto_grant: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_request_fixed_duration: Fixed Duration of access requests bound to this workflow. If fixed duration is provided, max duration must be empty. If neither max nor fixed duration are provided, requests that bind to this workflow will use the organization-level settings.
        :param _builtins.str access_request_max_duration: Maximum Duration of access requests bound to this workflow. If max duration is provided, fixed duration must be empty. If neither max nor fixed duration are provided, requests that bind to this workflow will use the organization-level settings.
        :param _builtins.str access_rules: AccessRules is a list of access rules defining the resources this Workflow provides access to.
        :param _builtins.str approval_flow_id: Optional approval flow ID identifies an approval flow that linked to the workflow
        :param _builtins.bool auto_grant: Optional auto grant setting to automatically approve requests or not, defaults to false.
        :param _builtins.str description: Optional description of the Workflow.
        :param _builtins.bool enabled: Optional enabled state for workflow. This setting may be overridden by the system if the workflow doesn't meet the requirements to be enabled or if other conditions prevent enabling the workflow. The requirements to enable a workflow are that the workflow must be either set up for with auto grant enabled or have one or more WorkflowApprovers created for the workflow.
        :param _builtins.str id: Unique identifier of the Workflow.
        :param _builtins.str name: Unique human-readable name of the Workflow.
        :param _builtins.int weight: Optional weight for workflow to specify it's priority in matching a request.
        """
        if access_request_fixed_duration is not None:
            pulumi.set(__self__, "access_request_fixed_duration", access_request_fixed_duration)
        if access_request_max_duration is not None:
            pulumi.set(__self__, "access_request_max_duration", access_request_max_duration)
        if access_rules is not None:
            pulumi.set(__self__, "access_rules", access_rules)
        if approval_flow_id is not None:
            pulumi.set(__self__, "approval_flow_id", approval_flow_id)
        if auto_grant is not None:
            pulumi.set(__self__, "auto_grant", auto_grant)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="accessRequestFixedDuration")
    def access_request_fixed_duration(self) -> Optional[_builtins.str]:
        """
        Fixed Duration of access requests bound to this workflow. If fixed duration is provided, max duration must be empty. If neither max nor fixed duration are provided, requests that bind to this workflow will use the organization-level settings.
        """
        return pulumi.get(self, "access_request_fixed_duration")

    @_builtins.property
    @pulumi.getter(name="accessRequestMaxDuration")
    def access_request_max_duration(self) -> Optional[_builtins.str]:
        """
        Maximum Duration of access requests bound to this workflow. If max duration is provided, fixed duration must be empty. If neither max nor fixed duration are provided, requests that bind to this workflow will use the organization-level settings.
        """
        return pulumi.get(self, "access_request_max_duration")

    @_builtins.property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> Optional[_builtins.str]:
        """
        AccessRules is a list of access rules defining the resources this Workflow provides access to.
        """
        return pulumi.get(self, "access_rules")

    @_builtins.property
    @pulumi.getter(name="approvalFlowId")
    def approval_flow_id(self) -> Optional[_builtins.str]:
        """
        Optional approval flow ID identifies an approval flow that linked to the workflow
        """
        return pulumi.get(self, "approval_flow_id")

    @_builtins.property
    @pulumi.getter(name="autoGrant")
    @_utilities.deprecated("""auto_grant is deprecated, see docs for more info""")
    def auto_grant(self) -> Optional[_builtins.bool]:
        """
        Optional auto grant setting to automatically approve requests or not, defaults to false.
        """
        return pulumi.get(self, "auto_grant")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Optional description of the Workflow.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Optional enabled state for workflow. This setting may be overridden by the system if the workflow doesn't meet the requirements to be enabled or if other conditions prevent enabling the workflow. The requirements to enable a workflow are that the workflow must be either set up for with auto grant enabled or have one or more WorkflowApprovers created for the workflow.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Workflow.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Unique human-readable name of the Workflow.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Optional weight for workflow to specify it's priority in matching a request.
        """
        return pulumi.get(self, "weight")


