# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AccountService',
    'AccountUser',
    'NodeGateway',
    'NodeGatewayMaintenanceWindow',
    'NodeRelay',
    'NodeRelayMaintenanceWindow',
    'ResourceAks',
    'ResourceAksBasicAuth',
    'ResourceAksServiceAccount',
    'ResourceAksServiceAccountUserImpersonation',
    'ResourceAksUserImpersonation',
    'ResourceAmazonEks',
    'ResourceAmazonEksInstanceProfile',
    'ResourceAmazonEksInstanceProfileUserImpersonation',
    'ResourceAmazonEksUserImpersonation',
    'ResourceAmazonEs',
    'ResourceAmazonmqAmqp091',
    'ResourceAthena',
    'ResourceAuroraMysql',
    'ResourceAuroraPostgres',
    'ResourceAuroraPostgresIam',
    'ResourceAws',
    'ResourceAwsConsole',
    'ResourceAwsConsoleStaticKeyPair',
    'ResourceAzure',
    'ResourceAzureCertificate',
    'ResourceAzureMysql',
    'ResourceAzurePostgres',
    'ResourceAzurePostgresManagedIdentity',
    'ResourceBigQuery',
    'ResourceCassandra',
    'ResourceCitus',
    'ResourceClustrix',
    'ResourceCockroach',
    'ResourceDb2I',
    'ResourceDb2Luw',
    'ResourceDocumentDbHost',
    'ResourceDocumentDbReplicaSet',
    'ResourceDruid',
    'ResourceDynamoDb',
    'ResourceElastic',
    'ResourceElasticacheRedis',
    'ResourceGcp',
    'ResourceGoogleGke',
    'ResourceGoogleGkeUserImpersonation',
    'ResourceGreenplum',
    'ResourceHttpAuth',
    'ResourceHttpBasicAuth',
    'ResourceHttpNoAuth',
    'ResourceKubernetes',
    'ResourceKubernetesBasicAuth',
    'ResourceKubernetesServiceAccount',
    'ResourceKubernetesServiceAccountUserImpersonation',
    'ResourceKubernetesUserImpersonation',
    'ResourceMaria',
    'ResourceMemcached',
    'ResourceMemsql',
    'ResourceMongoHost',
    'ResourceMongoLegacyHost',
    'ResourceMongoLegacyReplicaset',
    'ResourceMongoReplicaSet',
    'ResourceMongoShardedCluster',
    'ResourceMtlsMysql',
    'ResourceMtlsPostgres',
    'ResourceMysql',
    'ResourceNeptune',
    'ResourceNeptuneIam',
    'ResourceOracle',
    'ResourcePostgres',
    'ResourcePresto',
    'ResourceRabbitmqAmqp091',
    'ResourceRawTcp',
    'ResourceRdp',
    'ResourceRdpCert',
    'ResourceRdsPostgresIam',
    'ResourceRedis',
    'ResourceRedshift',
    'ResourceSingleStore',
    'ResourceSnowflake',
    'ResourceSnowsight',
    'ResourceSqlServer',
    'ResourceSqlServerAzureAd',
    'ResourceSqlServerKerberosAd',
    'ResourceSsh',
    'ResourceSshCert',
    'ResourceSshCustomerKey',
    'ResourceSshPassword',
    'ResourceSybase',
    'ResourceSybaseIq',
    'ResourceTeradata',
    'ResourceTrino',
    'SecretStoreActiveDirectoryStore',
    'SecretStoreAws',
    'SecretStoreAwsCertX509',
    'SecretStoreAzureStore',
    'SecretStoreCyberarkConjur',
    'SecretStoreCyberarkPam',
    'SecretStoreCyberarkPamExperimental',
    'SecretStoreDelineaStore',
    'SecretStoreGcpCertX509Store',
    'SecretStoreGcpStore',
    'SecretStoreKeyfactorSshStore',
    'SecretStoreKeyfactorX509Store',
    'SecretStoreVaultApprole',
    'SecretStoreVaultApproleCertSsh',
    'SecretStoreVaultApproleCertX509',
    'SecretStoreVaultAwsEc2',
    'SecretStoreVaultAwsIam',
    'SecretStoreVaultTls',
    'SecretStoreVaultTlsCertSsh',
    'SecretStoreVaultTlsCertX509',
    'SecretStoreVaultToken',
    'SecretStoreVaultTokenCertSsh',
    'SecretStoreVaultTokenCertX509',
    'GetAccountAccountResult',
    'GetAccountAccountServiceResult',
    'GetAccountAccountTokenResult',
    'GetAccountAccountUserResult',
    'GetAccountAttachmentAccountAttachmentResult',
    'GetApprovalWorkflowApprovalWorkflowResult',
    'GetApprovalWorkflowApproverApprovalWorkflowApproverResult',
    'GetApprovalWorkflowStepApprovalWorkflowStepResult',
    'GetIdentityAliasIdentityAliasResult',
    'GetIdentitySetIdentitySetResult',
    'GetNodeNodeResult',
    'GetNodeNodeGatewayResult',
    'GetNodeNodeGatewayMaintenanceWindowResult',
    'GetNodeNodeRelayResult',
    'GetNodeNodeRelayMaintenanceWindowResult',
    'GetPeeringGroupNodePeeringGroupNodeResult',
    'GetPeeringGroupPeerPeeringGroupPeerResult',
    'GetPeeringGroupPeeringGroupResult',
    'GetPeeringGroupResourcePeeringGroupResourceResult',
    'GetRemoteIdentityGroupRemoteIdentityGroupResult',
    'GetRemoteIdentityRemoteIdentityResult',
    'GetResourceResourceResult',
    'GetResourceResourceAkResult',
    'GetResourceResourceAksBasicAuthResult',
    'GetResourceResourceAksServiceAccountResult',
    'GetResourceResourceAksServiceAccountUserImpersonationResult',
    'GetResourceResourceAksUserImpersonationResult',
    'GetResourceResourceAmazonEResult',
    'GetResourceResourceAmazonEkResult',
    'GetResourceResourceAmazonEksInstanceProfileResult',
    'GetResourceResourceAmazonEksInstanceProfileUserImpersonationResult',
    'GetResourceResourceAmazonEksUserImpersonationResult',
    'GetResourceResourceAmazonmqAmqp091Result',
    'GetResourceResourceAthenaResult',
    'GetResourceResourceAuroraMysqlResult',
    'GetResourceResourceAuroraPostgreResult',
    'GetResourceResourceAuroraPostgresIamResult',
    'GetResourceResourceAwResult',
    'GetResourceResourceAwsConsoleResult',
    'GetResourceResourceAwsConsoleStaticKeyPairResult',
    'GetResourceResourceAzureResult',
    'GetResourceResourceAzureCertificateResult',
    'GetResourceResourceAzureMysqlResult',
    'GetResourceResourceAzurePostgreResult',
    'GetResourceResourceAzurePostgresManagedIdentityResult',
    'GetResourceResourceBigQueryResult',
    'GetResourceResourceCassandraResult',
    'GetResourceResourceCitusResult',
    'GetResourceResourceClustrixResult',
    'GetResourceResourceCockroachResult',
    'GetResourceResourceDb2IResult',
    'GetResourceResourceDb2LuwResult',
    'GetResourceResourceDocumentDbHostResult',
    'GetResourceResourceDocumentDbReplicaSetResult',
    'GetResourceResourceDruidResult',
    'GetResourceResourceDynamoDbResult',
    'GetResourceResourceElasticResult',
    'GetResourceResourceElasticacheRediResult',
    'GetResourceResourceGcpResult',
    'GetResourceResourceGoogleGkeResult',
    'GetResourceResourceGoogleGkeUserImpersonationResult',
    'GetResourceResourceGreenplumResult',
    'GetResourceResourceHttpAuthResult',
    'GetResourceResourceHttpBasicAuthResult',
    'GetResourceResourceHttpNoAuthResult',
    'GetResourceResourceKuberneteResult',
    'GetResourceResourceKubernetesBasicAuthResult',
    'GetResourceResourceKubernetesServiceAccountResult',
    'GetResourceResourceKubernetesServiceAccountUserImpersonationResult',
    'GetResourceResourceKubernetesUserImpersonationResult',
    'GetResourceResourceMariaResult',
    'GetResourceResourceMemcachedResult',
    'GetResourceResourceMemsqlResult',
    'GetResourceResourceMongoHostResult',
    'GetResourceResourceMongoLegacyHostResult',
    'GetResourceResourceMongoLegacyReplicasetResult',
    'GetResourceResourceMongoReplicaSetResult',
    'GetResourceResourceMongoShardedClusterResult',
    'GetResourceResourceMtlsMysqlResult',
    'GetResourceResourceMtlsPostgreResult',
    'GetResourceResourceMysqlResult',
    'GetResourceResourceNeptuneResult',
    'GetResourceResourceNeptuneIamResult',
    'GetResourceResourceOracleResult',
    'GetResourceResourcePostgreResult',
    'GetResourceResourcePrestoResult',
    'GetResourceResourceRabbitmqAmqp091Result',
    'GetResourceResourceRawTcpResult',
    'GetResourceResourceRdpResult',
    'GetResourceResourceRdpCertResult',
    'GetResourceResourceRdsPostgresIamResult',
    'GetResourceResourceRediResult',
    'GetResourceResourceRedshiftResult',
    'GetResourceResourceSingleStoreResult',
    'GetResourceResourceSnowflakeResult',
    'GetResourceResourceSnowsightResult',
    'GetResourceResourceSqlServerResult',
    'GetResourceResourceSqlServerAzureAdResult',
    'GetResourceResourceSqlServerKerberosAdResult',
    'GetResourceResourceSshResult',
    'GetResourceResourceSshCertResult',
    'GetResourceResourceSshCustomerKeyResult',
    'GetResourceResourceSshPasswordResult',
    'GetResourceResourceSybaseResult',
    'GetResourceResourceSybaseIqResult',
    'GetResourceResourceTeradataResult',
    'GetResourceResourceTrinoResult',
    'GetRoleRoleResult',
    'GetSecretStoreSecretStoreResult',
    'GetSecretStoreSecretStoreActiveDirectoryStoreResult',
    'GetSecretStoreSecretStoreAwResult',
    'GetSecretStoreSecretStoreAwsCertX509Result',
    'GetSecretStoreSecretStoreAzureStoreResult',
    'GetSecretStoreSecretStoreCyberarkConjurResult',
    'GetSecretStoreSecretStoreCyberarkPamResult',
    'GetSecretStoreSecretStoreCyberarkPamExperimentalResult',
    'GetSecretStoreSecretStoreDelineaStoreResult',
    'GetSecretStoreSecretStoreGcpCertX509StoreResult',
    'GetSecretStoreSecretStoreGcpStoreResult',
    'GetSecretStoreSecretStoreKeyfactorSshStoreResult',
    'GetSecretStoreSecretStoreKeyfactorX509StoreResult',
    'GetSecretStoreSecretStoreVaultApproleResult',
    'GetSecretStoreSecretStoreVaultApproleCertSshResult',
    'GetSecretStoreSecretStoreVaultApproleCertX509Result',
    'GetSecretStoreSecretStoreVaultAwsEc2Result',
    'GetSecretStoreSecretStoreVaultAwsIamResult',
    'GetSecretStoreSecretStoreVaultTlResult',
    'GetSecretStoreSecretStoreVaultTlsCertSshResult',
    'GetSecretStoreSecretStoreVaultTlsCertX509Result',
    'GetSecretStoreSecretStoreVaultTokenResult',
    'GetSecretStoreSecretStoreVaultTokenCertSshResult',
    'GetSecretStoreSecretStoreVaultTokenCertX509Result',
    'GetWorkflowApproverWorkflowApproverResult',
    'GetWorkflowRoleWorkflowRoleResult',
    'GetWorkflowWorkflowResult',
]

@pulumi.output_type
class AccountService(dict):
    def __init__(__self__, *,
                 name: str,
                 suspended: Optional[bool] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None):
        """
        :param str name: Unique human-readable name of the Service.
        :param bool suspended: The Service's suspended state.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def suspended(self) -> Optional[bool]:
        """
        The Service's suspended state.
        """
        return pulumi.get(self, "suspended")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        return pulumi.get(self, "token")


@pulumi.output_type
class AccountUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "managedBy":
            suggest = "managed_by"
        elif key == "permissionLevel":
            suggest = "permission_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 first_name: str,
                 last_name: str,
                 external_id: Optional[str] = None,
                 managed_by: Optional[str] = None,
                 permission_level: Optional[str] = None,
                 suspended: Optional[bool] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str email: The User's email address. Must be unique.
        :param str first_name: The User's first name.
        :param str last_name: The User's last name.
        :param str external_id: External ID is an alternative unique ID this user is represented by within an external service.
        :param str managed_by: Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        :param str permission_level: PermissionLevel is the user's permission level e.g. admin, DBA, user.
        :param bool suspended: The Service's suspended state.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if managed_by is not None:
            pulumi.set(__self__, "managed_by", managed_by)
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The User's email address. Must be unique.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        The User's first name.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        The User's last name.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        External ID is an alternative unique ID this user is represented by within an external service.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="managedBy")
    def managed_by(self) -> Optional[str]:
        """
        Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        """
        return pulumi.get(self, "managed_by")

    @property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[str]:
        """
        PermissionLevel is the user's permission level e.g. admin, DBA, user.
        """
        return pulumi.get(self, "permission_level")

    @property
    @pulumi.getter
    def suspended(self) -> Optional[bool]:
        """
        The Service's suspended state.
        """
        return pulumi.get(self, "suspended")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class NodeGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listenAddress":
            suggest = "listen_address"
        elif key == "bindAddress":
            suggest = "bind_address"
        elif key == "gatewayFilter":
            suggest = "gateway_filter"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 listen_address: str,
                 bind_address: Optional[str] = None,
                 device: Optional[str] = None,
                 gateway_filter: Optional[str] = None,
                 location: Optional[str] = None,
                 maintenance_windows: Optional[Sequence['outputs.NodeGatewayMaintenanceWindow']] = None,
                 name: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str listen_address: The public hostname/port tuple at which the gateway will be accessible to clients.
        :param str bind_address: The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        :param str device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param str gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param str location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param Sequence['NodeGatewayMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        pulumi.set(__self__, "listen_address", listen_address)
        if bind_address is not None:
            pulumi.set(__self__, "bind_address", bind_address)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> str:
        """
        The public hostname/port tuple at which the gateway will be accessible to clients.
        """
        return pulumi.get(self, "listen_address")

    @property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> Optional[str]:
        """
        The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        """
        return pulumi.get(self, "bind_address")

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[str]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.NodeGatewayMaintenanceWindow']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class NodeGatewayMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronSchedule":
            suggest = "cron_schedule"
        elif key == "requireIdleness":
            suggest = "require_idleness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeGatewayMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeGatewayMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeGatewayMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_schedule: str,
                 require_idleness: bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> str:
        return pulumi.get(self, "cron_schedule")

    @property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class NodeRelay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayFilter":
            suggest = "gateway_filter"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeRelay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeRelay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeRelay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: Optional[str] = None,
                 gateway_filter: Optional[str] = None,
                 location: Optional[str] = None,
                 maintenance_windows: Optional[Sequence['outputs.NodeRelayMaintenanceWindow']] = None,
                 name: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param str gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param str location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param Sequence['NodeRelayMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        if device is not None:
            pulumi.set(__self__, "device", device)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[str]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.NodeRelayMaintenanceWindow']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class NodeRelayMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronSchedule":
            suggest = "cron_schedule"
        elif key == "requireIdleness":
            suggest = "require_idleness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeRelayMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeRelayMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeRelayMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_schedule: str,
                 require_idleness: bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> str:
        return pulumi.get(self, "cron_schedule")

    @property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class ResourceAks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAksBasicAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAksBasicAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAksBasicAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAksBasicAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAksServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAksServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAksServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAksServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ResourceAksServiceAccountUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAksServiceAccountUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAksServiceAccountUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAksServiceAccountUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ResourceAksUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAksUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAksUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAksUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 endpoint: str,
                 name: str,
                 region: str,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str cluster_name: The name of the cluster to connect to.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEksInstanceProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEksInstanceProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEksInstanceProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEksInstanceProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 endpoint: str,
                 name: str,
                 region: str,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str cluster_name: The name of the cluster to connect to.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEksInstanceProfileUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEksInstanceProfileUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEksInstanceProfileUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEksInstanceProfileUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 endpoint: str,
                 name: str,
                 region: str,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str cluster_name: The name of the cluster to connect to.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEksUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEksUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEksUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEksUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 endpoint: str,
                 name: str,
                 region: str,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str cluster_name: The name of the cluster to connect to.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonEs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonEs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonEs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonEs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 region: str,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAmazonmqAmqp091(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAmazonmqAmqp091. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAmazonmqAmqp091.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAmazonmqAmqp091.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAthena(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "athenaOutput":
            suggest = "athena_output"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAthena. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAthena.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAthena.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 athena_output: str,
                 name: str,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str athena_output: The AWS S3 output location.
        :param str name: Unique human-readable name of the Resource.
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "athena_output", athena_output)
        pulumi.set(__self__, "name", name)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="athenaOutput")
    def athena_output(self) -> str:
        """
        The AWS S3 output location.
        """
        return pulumi.get(self, "athena_output")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAuroraMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAuroraMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAuroraMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAuroraMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAuroraPostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAuroraPostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAuroraPostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAuroraPostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAuroraPostgresIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleAssumptionArn":
            suggest = "role_assumption_arn"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAuroraPostgresIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAuroraPostgresIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAuroraPostgresIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 region: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 role_assumption_arn: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckRegion":
            suggest = "healthcheck_region"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_region: str,
                 name: str,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str healthcheck_region: The AWS region healthcheck requests should attempt to connect to.
        :param str name: Unique human-readable name of the Resource.
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_region", healthcheck_region)
        pulumi.set(__self__, "name", name)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="healthcheckRegion")
    def healthcheck_region(self) -> str:
        """
        The AWS region healthcheck requests should attempt to connect to.
        """
        return pulumi.get(self, "healthcheck_region")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAwsConsole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "enableEnvVariables":
            suggest = "enable_env_variables"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "sessionExpiry":
            suggest = "session_expiry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAwsConsole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAwsConsole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAwsConsole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 region: str,
                 subdomain: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 enable_env_variables: Optional[bool] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 session_expiry: Optional[int] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool enable_env_variables: If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param int session_expiry: The length of time in seconds AWS console sessions will live before needing to reauthenticate.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "subdomain", subdomain)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if enable_env_variables is not None:
            pulumi.set(__self__, "enable_env_variables", enable_env_variables)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="enableEnvVariables")
    def enable_env_variables(self) -> Optional[bool]:
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        return pulumi.get(self, "enable_env_variables")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[int]:
        """
        The length of time in seconds AWS console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAwsConsoleStaticKeyPair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "sessionExpiry":
            suggest = "session_expiry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAwsConsoleStaticKeyPair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAwsConsoleStaticKeyPair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAwsConsoleStaticKeyPair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 region: str,
                 subdomain: str,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 session_expiry: Optional[int] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param int session_expiry: The length of time in seconds AWS console sessions will live before needing to reauthenticate.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "subdomain", subdomain)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[int]:
        """
        The length of time in seconds AWS console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 app_id: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str name: Unique human-readable name of the Resource.
        :param str app_id: The application ID to authenticate with.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        pulumi.set(__self__, "name", name)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[str]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ResourceAzureCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzureCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzureCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzureCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 app_id: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str name: Unique human-readable name of the Resource.
        :param str app_id: The application ID to authenticate with.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        pulumi.set(__self__, "name", name)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[str]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ResourceAzureMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzureMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzureMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzureMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAzurePostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzurePostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzurePostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzurePostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceAzurePostgresManagedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceAzurePostgresManagedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceAzurePostgresManagedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceAzurePostgresManagedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceBigQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceBigQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceBigQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceBigQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 name: str,
                 project: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port_override: Optional[int] = None,
                 private_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str project: The project to connect to.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str private_key: The private key used to authenticate with the server.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        The project to connect to.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceCassandra(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceCassandra. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceCassandra.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceCassandra.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceCitus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceCitus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceCitus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceCitus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceClustrix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceClustrix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceClustrix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceClustrix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceCockroach(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceCockroach. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceCockroach.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceCockroach.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDb2I(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDb2I. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDb2I.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDb2I.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDb2Luw(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDb2Luw. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDb2Luw.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDb2Luw.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDocumentDbHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDocumentDbHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDocumentDbHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDocumentDbHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDocumentDbReplicaSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "replicaSet":
            suggest = "replica_set"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "connectToReplica":
            suggest = "connect_to_replica"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDocumentDbReplicaSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDocumentDbReplicaSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDocumentDbReplicaSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: str,
                 hostname: str,
                 name: str,
                 replica_set: str,
                 bind_interface: Optional[str] = None,
                 connect_to_replica: Optional[bool] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str replica_set: The name of the mongo replicaset.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replica_set", replica_set)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> str:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDruid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDruid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDruid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDruid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceDynamoDb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDynamoDb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDynamoDb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDynamoDb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 name: str,
                 region: str,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceElastic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceElastic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceElastic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceElastic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceElasticacheRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceElasticacheRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceElasticacheRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceElasticacheRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 scopes: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 keyfile: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the Resource.
        :param str scopes: Space separated scopes that this login should assume into when authenticating.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str keyfile: The service account keyfile to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scopes(self) -> str:
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def keyfile(self) -> Optional[str]:
        """
        The service account keyfile to authenticate with.
        """
        return pulumi.get(self, "keyfile")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceGoogleGke(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "serviceAccountKey":
            suggest = "service_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGoogleGke. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGoogleGke.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGoogleGke.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 service_account_key: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str service_account_key: The service account key to authenticate with.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[str]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceGoogleGkeUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "serviceAccountKey":
            suggest = "service_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGoogleGkeUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGoogleGkeUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGoogleGkeUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 service_account_key: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str service_account_key: The service account key to authenticate with.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[str]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceGreenplum(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGreenplum. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGreenplum.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGreenplum.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceHttpAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckPath":
            suggest = "healthcheck_path"
        elif key == "authHeader":
            suggest = "auth_header"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "defaultPath":
            suggest = "default_path"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "headersBlacklist":
            suggest = "headers_blacklist"
        elif key == "hostOverride":
            suggest = "host_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceHttpAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceHttpAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceHttpAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_path: str,
                 name: str,
                 subdomain: str,
                 url: str,
                 auth_header: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 default_path: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 headers_blacklist: Optional[str] = None,
                 host_override: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str healthcheck_path: This path will be used to check the health of your site.
        :param str name: Unique human-readable name of the Resource.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param str url: The base address of your website without the path.
               * kubernetes:
        :param str auth_header: The content to set as the authorization header.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str default_path: Automatically redirect to this path upon connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param str host_override: The host header will be overwritten with this field if provided.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if auth_header is not None:
            pulumi.set(__self__, "auth_header", auth_header)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> str:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="authHeader")
    def auth_header(self) -> Optional[str]:
        """
        The content to set as the authorization header.
        """
        return pulumi.get(self, "auth_header")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceHttpBasicAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckPath":
            suggest = "healthcheck_path"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "defaultPath":
            suggest = "default_path"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "headersBlacklist":
            suggest = "headers_blacklist"
        elif key == "hostOverride":
            suggest = "host_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceHttpBasicAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceHttpBasicAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceHttpBasicAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_path: str,
                 name: str,
                 subdomain: str,
                 url: str,
                 bind_interface: Optional[str] = None,
                 default_path: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 headers_blacklist: Optional[str] = None,
                 host_override: Optional[str] = None,
                 password: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str healthcheck_path: This path will be used to check the health of your site.
        :param str name: Unique human-readable name of the Resource.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param str url: The base address of your website without the path.
               * kubernetes:
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str default_path: Automatically redirect to this path upon connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param str host_override: The host header will be overwritten with this field if provided.
        :param str password: The password to authenticate with.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> str:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceHttpNoAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckPath":
            suggest = "healthcheck_path"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "defaultPath":
            suggest = "default_path"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "headersBlacklist":
            suggest = "headers_blacklist"
        elif key == "hostOverride":
            suggest = "host_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceHttpNoAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceHttpNoAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceHttpNoAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_path: str,
                 name: str,
                 subdomain: str,
                 url: str,
                 bind_interface: Optional[str] = None,
                 default_path: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 headers_blacklist: Optional[str] = None,
                 host_override: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str healthcheck_path: This path will be used to check the health of your site.
        :param str name: Unique human-readable name of the Resource.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param str url: The base address of your website without the path.
               * kubernetes:
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str default_path: Automatically redirect to this path upon connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param str host_override: The host header will be overwritten with this field if provided.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> str:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceKubernetes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceKubernetesBasicAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetesBasicAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetesBasicAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetesBasicAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceKubernetesServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "discoveryEnabled":
            suggest = "discovery_enabled"
        elif key == "discoveryUsername":
            suggest = "discovery_username"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetesServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetesServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetesServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ResourceKubernetesServiceAccountUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetesServiceAccountUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetesServiceAccountUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetesServiceAccountUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ResourceKubernetesUserImpersonation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "healthcheckNamespace":
            suggest = "healthcheck_namespace"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceKubernetesUserImpersonation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceKubernetesUserImpersonation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceKubernetesUserImpersonation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceMaria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMaria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMaria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMaria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMemcached(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMemcached. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMemcached.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMemcached.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceMemsql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMemsql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMemsql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMemsql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoLegacyHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoLegacyHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoLegacyHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoLegacyHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoLegacyReplicaset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "replicaSet":
            suggest = "replica_set"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "connectToReplica":
            suggest = "connect_to_replica"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoLegacyReplicaset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoLegacyReplicaset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoLegacyReplicaset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: str,
                 hostname: str,
                 name: str,
                 replica_set: str,
                 bind_interface: Optional[str] = None,
                 connect_to_replica: Optional[bool] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str replica_set: The name of the mongo replicaset.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replica_set", replica_set)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> str:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoReplicaSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "replicaSet":
            suggest = "replica_set"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "connectToReplica":
            suggest = "connect_to_replica"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoReplicaSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoReplicaSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoReplicaSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: str,
                 hostname: str,
                 name: str,
                 replica_set: str,
                 bind_interface: Optional[str] = None,
                 connect_to_replica: Optional[bool] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str replica_set: The name of the mongo replicaset.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replica_set", replica_set)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> str:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMongoShardedCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDatabase":
            suggest = "auth_database"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMongoShardedCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMongoShardedCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMongoShardedCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> str:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMtlsMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMtlsMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMtlsMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMtlsMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 server_name: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMtlsPostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMtlsPostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMtlsPostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMtlsPostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 server_name: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceNeptune(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceNeptune. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceNeptune.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceNeptune.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceNeptuneIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "roleExternalId":
            suggest = "role_external_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceNeptuneIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceNeptuneIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceNeptuneIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 name: str,
                 region: str,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceOracle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceOracle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceOracle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceOracle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 port: int,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourcePostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourcePresto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePresto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePresto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePresto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRabbitmqAmqp091(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRabbitmqAmqp091. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRabbitmqAmqp091.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRabbitmqAmqp091.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRawTcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRawTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRawTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRawTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceRdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "downgradeNlaConnections":
            suggest = "downgrade_nla_connections"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "lockRequired":
            suggest = "lock_required"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 downgrade_nla_connections: Optional[bool] = None,
                 egress_filter: Optional[str] = None,
                 lock_required: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool downgrade_nla_connections: When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if downgrade_nla_connections is not None:
            pulumi.set(__self__, "downgrade_nla_connections", downgrade_nla_connections)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="downgradeNlaConnections")
    def downgrade_nla_connections(self) -> Optional[bool]:
        """
        When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        """
        return pulumi.get(self, "downgrade_nla_connections")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[bool]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRdpCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRdpCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRdpCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRdpCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRdsPostgresIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "roleAssumptionArn":
            suggest = "role_assumption_arn"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRdsPostgresIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRdsPostgresIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRdsPostgresIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 region: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 role_assumption_arn: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str region: The AWS region to connect to.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tlsRequired":
            suggest = "tls_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSingleStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "requireNativeAuth":
            suggest = "require_native_auth"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "useAzureSingleServerUsernames":
            suggest = "use_azure_single_server_usernames"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSingleStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSingleStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSingleStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSnowflake(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSnowflake. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSnowflake.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSnowflake.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 schema: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str schema: The Schema to use to direct initial requests.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSnowsight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthcheckUsername":
            suggest = "healthcheck_username"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "samlMetadata":
            suggest = "saml_metadata"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSnowsight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSnowsight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSnowsight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthcheck_username: str,
                 name: str,
                 subdomain: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port_override: Optional[int] = None,
                 saml_metadata: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str healthcheck_username: The StrongDM user email to use for healthchecks.
        :param str name: Unique human-readable name of the Resource.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str saml_metadata: The Metadata for your snowflake IDP integration
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_username", healthcheck_username)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if saml_metadata is not None:
            pulumi.set(__self__, "saml_metadata", saml_metadata)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="healthcheckUsername")
    def healthcheck_username(self) -> str:
        """
        The StrongDM user email to use for healthchecks.
        """
        return pulumi.get(self, "healthcheck_username")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="samlMetadata")
    def saml_metadata(self) -> Optional[str]:
        """
        The Metadata for your snowflake IDP integration
        """
        return pulumi.get(self, "saml_metadata")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ResourceSqlServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedEncryption":
            suggest = "allow_deprecated_encryption"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSqlServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSqlServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSqlServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 allow_deprecated_encryption: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 schema: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str schema: The Schema to use to direct initial requests.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSqlServerAzureAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedEncryption":
            suggest = "allow_deprecated_encryption"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSqlServerAzureAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSqlServerAzureAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSqlServerAzureAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 allow_deprecated_encryption: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 client_id: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 schema: Optional[str] = None,
                 secret: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str client_id: The Azure AD application (client) ID with which to authenticate.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str schema: The Schema to use to direct initial requests.
        :param str secret: The Azure AD client secret (application password) with which to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Azure AD application (client) ID with which to authenticate.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        The Azure AD client secret (application password) with which to authenticate.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ResourceSqlServerKerberosAd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedEncryption":
            suggest = "allow_deprecated_encryption"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "krbConfig":
            suggest = "krb_config"
        elif key == "overrideDatabase":
            suggest = "override_database"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"
        elif key == "serverSpn":
            suggest = "server_spn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSqlServerKerberosAd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSqlServerKerberosAd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSqlServerKerberosAd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 allow_deprecated_encryption: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 keytab: Optional[str] = None,
                 krb_config: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 realm: Optional[str] = None,
                 schema: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 server_spn: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str keytab: The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        :param str krb_config: The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str realm: The Active Directory domain (realm) to which the configured username belongs.
        :param str schema: The Schema to use to direct initial requests.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str server_spn: The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if keytab is not None:
            pulumi.set(__self__, "keytab", keytab)
        if krb_config is not None:
            pulumi.set(__self__, "krb_config", krb_config)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_spn is not None:
            pulumi.set(__self__, "server_spn", server_spn)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def keytab(self) -> Optional[str]:
        """
        The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        """
        return pulumi.get(self, "keytab")

    @property
    @pulumi.getter(name="krbConfig")
    def krb_config(self) -> Optional[str]:
        """
        The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        """
        return pulumi.get(self, "krb_config")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def realm(self) -> Optional[str]:
        """
        The Active Directory domain (realm) to which the configured username belongs.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serverSpn")
    def server_spn(self) -> Optional[str]:
        """
        The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        """
        return pulumi.get(self, "server_spn")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedKeyExchanges":
            suggest = "allow_deprecated_key_exchanges"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "keyType":
            suggest = "key_type"
        elif key == "portForwarding":
            suggest = "port_forwarding"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 allow_deprecated_key_exchanges: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 key_type: Optional[str] = None,
                 port_forwarding: Optional[bool] = None,
                 port_override: Optional[int] = None,
                 public_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str key_type: The key type to use e.g. rsa-2048 or ed25519
        :param bool port_forwarding: Whether port forwarding is allowed through this server.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str public_key: The public key to append to a server's authorized keys. This will be generated after resource creation.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[str]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        The public key to append to a server's authorized keys. This will be generated after resource creation.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSshCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedKeyExchanges":
            suggest = "allow_deprecated_key_exchanges"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "identityAliasHealthcheckUsername":
            suggest = "identity_alias_healthcheck_username"
        elif key == "identitySetId":
            suggest = "identity_set_id"
        elif key == "keyType":
            suggest = "key_type"
        elif key == "portForwarding":
            suggest = "port_forwarding"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSshCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSshCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSshCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 allow_deprecated_key_exchanges: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 key_type: Optional[str] = None,
                 port_forwarding: Optional[bool] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str key_type: The key type to use e.g. rsa-2048 or ed25519
        :param bool port_forwarding: Whether port forwarding is allowed through this server.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[str]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSshCustomerKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedKeyExchanges":
            suggest = "allow_deprecated_key_exchanges"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portForwarding":
            suggest = "port_forwarding"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSshCustomerKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSshCustomerKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSshCustomerKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 allow_deprecated_key_exchanges: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 port_forwarding: Optional[bool] = None,
                 port_override: Optional[int] = None,
                 private_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool port_forwarding: Whether port forwarding is allowed through this server.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str private_key: The private key used to authenticate with the server.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSshPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDeprecatedKeyExchanges":
            suggest = "allow_deprecated_key_exchanges"
        elif key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portForwarding":
            suggest = "port_forwarding"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSshPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSshPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSshPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 port: int,
                 allow_deprecated_key_exchanges: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port_forwarding: Optional[bool] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param bool port_forwarding: Whether port forwarding is allowed through this server.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSybase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSybase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSybase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSybase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceSybaseIq(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSybaseIq. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSybaseIq.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSybaseIq.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceTeradata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTeradata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTeradata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTeradata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceTrino(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindInterface":
            suggest = "bind_interface"
        elif key == "egressFilter":
            suggest = "egress_filter"
        elif key == "portOverride":
            suggest = "port_override"
        elif key == "secretStoreId":
            suggest = "secret_store_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTrino. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTrino.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTrino.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 hostname: str,
                 name: str,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str name: Unique human-readable name of the Resource.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SecretStoreActiveDirectoryStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreActiveDirectoryStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreActiveDirectoryStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreActiveDirectoryStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_address: str,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreAws(dict):
    def __init__(__self__, *,
                 name: str,
                 region: str,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the SecretStore.
        :param str region: The AWS region to target e.g. us-east-1
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreAwsCertX509(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caArn":
            suggest = "ca_arn"
        elif key == "certificateTemplateArn":
            suggest = "certificate_template_arn"
        elif key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "signingAlgo":
            suggest = "signing_algo"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreAwsCertX509. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreAwsCertX509.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreAwsCertX509.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_arn: str,
                 certificate_template_arn: str,
                 issued_cert_ttl_minutes: int,
                 name: str,
                 region: str,
                 signing_algo: str,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str ca_arn: The ARN of the CA in AWS Private CA
        :param str certificate_template_arn: The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str region: The AWS region to target e.g. us-east-1
        :param str signing_algo: The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "ca_arn", ca_arn)
        pulumi.set(__self__, "certificate_template_arn", certificate_template_arn)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "signing_algo", signing_algo)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="caArn")
    def ca_arn(self) -> str:
        """
        The ARN of the CA in AWS Private CA
        """
        return pulumi.get(self, "ca_arn")

    @property
    @pulumi.getter(name="certificateTemplateArn")
    def certificate_template_arn(self) -> str:
        """
        The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        """
        return pulumi.get(self, "certificate_template_arn")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="signingAlgo")
    def signing_algo(self) -> str:
        """
        The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        """
        return pulumi.get(self, "signing_algo")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreAzureStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vaultUri":
            suggest = "vault_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreAzureStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreAzureStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreAzureStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vault_uri: str,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the SecretStore.
        :param str vault_uri: The URI of the key vault to target e.g. https://myvault.vault.azure.net
               * cyberark_conjur:
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vault_uri", vault_uri)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> str:
        """
        The URI of the key vault to target e.g. https://myvault.vault.azure.net
        * cyberark_conjur:
        """
        return pulumi.get(self, "vault_uri")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreCyberarkConjur(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appUrl":
            suggest = "app_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreCyberarkConjur. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreCyberarkConjur.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreCyberarkConjur.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_url: str,
                 name: str,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str app_url: The URL of the Cyberark instance
        :param str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "app_url", app_url)
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> str:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreCyberarkPam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appUrl":
            suggest = "app_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreCyberarkPam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreCyberarkPam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreCyberarkPam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_url: str,
                 name: str,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str app_url: The URL of the Cyberark instance
        :param str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "app_url", app_url)
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> str:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreCyberarkPamExperimental(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appUrl":
            suggest = "app_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreCyberarkPamExperimental. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreCyberarkPamExperimental.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreCyberarkPamExperimental.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_url: str,
                 name: str,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str app_url: The URL of the Cyberark instance
        :param str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "app_url", app_url)
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> str:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreDelineaStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverUrl":
            suggest = "server_url"
        elif key == "tenantName":
            suggest = "tenant_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreDelineaStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreDelineaStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreDelineaStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_url: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tenant_name: Optional[str] = None):
        """
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_url: The URL of the Delinea instance
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str tenant_name: The tenant name to target
               * gcp_store:
        """
        pulumi.set(__self__, "name", name)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[str]:
        """
        The URL of the Delinea instance
        """
        return pulumi.get(self, "server_url")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[str]:
        """
        The tenant name to target
        * gcp_store:
        """
        return pulumi.get(self, "tenant_name")


@pulumi.output_type
class SecretStoreGcpCertX509Store(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caPoolId":
            suggest = "ca_pool_id"
        elif key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "caId":
            suggest = "ca_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreGcpCertX509Store. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreGcpCertX509Store.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreGcpCertX509Store.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_pool_id: str,
                 issued_cert_ttl_minutes: int,
                 location: str,
                 name: str,
                 project_id: str,
                 ca_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str ca_pool_id: The ID of the target CA pool
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str location: The Region for the CA in GCP format e.g. us-west1
        :param str name: Unique human-readable name of the SecretStore.
        :param str project_id: The GCP project ID to target.
        :param str ca_id: The ID of the target CA
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "ca_pool_id", ca_pool_id)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if ca_id is not None:
            pulumi.set(__self__, "ca_id", ca_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="caPoolId")
    def ca_pool_id(self) -> str:
        """
        The ID of the target CA pool
        """
        return pulumi.get(self, "ca_pool_id")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The Region for the CA in GCP format e.g. us-west1
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="caId")
    def ca_id(self) -> Optional[str]:
        """
        The ID of the target CA
        """
        return pulumi.get(self, "ca_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreGcpStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreGcpStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreGcpStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreGcpStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 project_id: str,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the SecretStore.
        :param str project_id: The GCP project ID to target.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreKeyfactorSshStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateFilePath":
            suggest = "certificate_file_path"
        elif key == "defaultCertificateAuthorityName":
            suggest = "default_certificate_authority_name"
        elif key == "defaultCertificateProfileName":
            suggest = "default_certificate_profile_name"
        elif key == "defaultEndEntityProfileName":
            suggest = "default_end_entity_profile_name"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "caFilePath":
            suggest = "ca_file_path"
        elif key == "enrollmentCodeEnvVar":
            suggest = "enrollment_code_env_var"
        elif key == "enrollmentUsernameEnvVar":
            suggest = "enrollment_username_env_var"
        elif key == "keyFilePath":
            suggest = "key_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreKeyfactorSshStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreKeyfactorSshStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreKeyfactorSshStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_file_path: str,
                 default_certificate_authority_name: str,
                 default_certificate_profile_name: str,
                 default_end_entity_profile_name: str,
                 name: str,
                 server_address: str,
                 ca_file_path: Optional[str] = None,
                 enrollment_code_env_var: Optional[str] = None,
                 enrollment_username_env_var: Optional[str] = None,
                 key_file_path: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param str default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param str default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param str default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param str enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param str enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param str key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> str:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> str:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> str:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> str:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[str]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[str]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[str]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[str]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreKeyfactorX509Store(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateFilePath":
            suggest = "certificate_file_path"
        elif key == "defaultCertificateAuthorityName":
            suggest = "default_certificate_authority_name"
        elif key == "defaultCertificateProfileName":
            suggest = "default_certificate_profile_name"
        elif key == "defaultEndEntityProfileName":
            suggest = "default_end_entity_profile_name"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "caFilePath":
            suggest = "ca_file_path"
        elif key == "enrollmentCodeEnvVar":
            suggest = "enrollment_code_env_var"
        elif key == "enrollmentUsernameEnvVar":
            suggest = "enrollment_username_env_var"
        elif key == "keyFilePath":
            suggest = "key_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreKeyfactorX509Store. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreKeyfactorX509Store.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreKeyfactorX509Store.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_file_path: str,
                 default_certificate_authority_name: str,
                 default_certificate_profile_name: str,
                 default_end_entity_profile_name: str,
                 name: str,
                 server_address: str,
                 ca_file_path: Optional[str] = None,
                 enrollment_code_env_var: Optional[str] = None,
                 enrollment_username_env_var: Optional[str] = None,
                 key_file_path: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param str default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param str default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param str default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param str enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param str enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param str key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> str:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> str:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> str:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> str:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[str]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[str]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[str]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[str]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultApprole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultApprole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultApprole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultApprole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_address: str,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultApproleCertSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"
        elif key == "sshMountPoint":
            suggest = "ssh_mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultApproleCertSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultApproleCertSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultApproleCertSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issued_cert_ttl_minutes: int,
                 name: str,
                 server_address: str,
                 signing_role: str,
                 ssh_mount_point: str,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> str:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultApproleCertX509(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "pkiMountPoint":
            suggest = "pki_mount_point"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultApproleCertX509. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultApproleCertX509.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultApproleCertX509.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issued_cert_ttl_minutes: int,
                 name: str,
                 pki_mount_point: str,
                 server_address: str,
                 signing_role: str,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> str:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultAwsEc2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultAwsEc2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultAwsEc2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultAwsEc2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_address: str,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultAwsIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultAwsIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultAwsIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultAwsIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_address: str,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertPath":
            suggest = "client_cert_path"
        elif key == "clientKeyPath":
            suggest = "client_key_path"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "caCertPath":
            suggest = "ca_cert_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert_path: str,
                 client_key_path: str,
                 name: str,
                 server_address: str,
                 ca_cert_path: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str client_cert_path: A path to a client certificate file accessible by a Node
        :param str client_key_path: A path to a client key file accessible by a Node
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str ca_cert_path: A path to a CA file accessible by a Node
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "client_cert_path", client_cert_path)
        pulumi.set(__self__, "client_key_path", client_key_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> str:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> str:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTlsCertSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertPath":
            suggest = "client_cert_path"
        elif key == "clientKeyPath":
            suggest = "client_key_path"
        elif key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"
        elif key == "sshMountPoint":
            suggest = "ssh_mount_point"
        elif key == "caCertPath":
            suggest = "ca_cert_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTlsCertSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTlsCertSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTlsCertSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert_path: str,
                 client_key_path: str,
                 issued_cert_ttl_minutes: int,
                 name: str,
                 server_address: str,
                 signing_role: str,
                 ssh_mount_point: str,
                 ca_cert_path: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str client_cert_path: A path to a client certificate file accessible by a Node
        :param str client_key_path: A path to a client key file accessible by a Node
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param str ca_cert_path: A path to a CA file accessible by a Node
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "client_cert_path", client_cert_path)
        pulumi.set(__self__, "client_key_path", client_key_path)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> str:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> str:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> str:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTlsCertX509(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertPath":
            suggest = "client_cert_path"
        elif key == "clientKeyPath":
            suggest = "client_key_path"
        elif key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "pkiMountPoint":
            suggest = "pki_mount_point"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"
        elif key == "caCertPath":
            suggest = "ca_cert_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTlsCertX509. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTlsCertX509.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTlsCertX509.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert_path: str,
                 client_key_path: str,
                 issued_cert_ttl_minutes: int,
                 name: str,
                 pki_mount_point: str,
                 server_address: str,
                 signing_role: str,
                 ca_cert_path: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str client_cert_path: A path to a client certificate file accessible by a Node
        :param str client_key_path: A path to a client key file accessible by a Node
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param str ca_cert_path: A path to a CA file accessible by a Node
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "client_cert_path", client_cert_path)
        pulumi.set(__self__, "client_key_path", client_key_path)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> str:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> str:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> str:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_address: str,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTokenCertSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"
        elif key == "sshMountPoint":
            suggest = "ssh_mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTokenCertSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTokenCertSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTokenCertSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issued_cert_ttl_minutes: int,
                 name: str,
                 server_address: str,
                 signing_role: str,
                 ssh_mount_point: str,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> str:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecretStoreVaultTokenCertX509(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuedCertTtlMinutes":
            suggest = "issued_cert_ttl_minutes"
        elif key == "pkiMountPoint":
            suggest = "pki_mount_point"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "signingRole":
            suggest = "signing_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreVaultTokenCertX509. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreVaultTokenCertX509.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreVaultTokenCertX509.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issued_cert_ttl_minutes: int,
                 name: str,
                 pki_mount_point: str,
                 server_address: str,
                 signing_role: str,
                 namespace: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param str namespace: The namespace to make requests within
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> int:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> str:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> str:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAccountAccountResult(dict):
    def __init__(__self__, *,
                 services: Sequence['outputs.GetAccountAccountServiceResult'],
                 tokens: Sequence['outputs.GetAccountAccountTokenResult'],
                 users: Sequence['outputs.GetAccountAccountUserResult']):
        """
        :param Sequence['GetAccountAccountServiceArgs'] services: A Service is a service account that can connect to resources they are granted directly, or granted via roles. Services are typically automated jobs.
        :param Sequence['GetAccountAccountTokenArgs'] tokens: A Token is an account providing tokenized access for automation or integration use. Tokens include admin tokens, API keys, and SCIM tokens.
        :param Sequence['GetAccountAccountUserArgs'] users: A User can connect to resources they are granted directly, or granted via roles.
        """
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "tokens", tokens)
        pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def services(self) -> Sequence['outputs.GetAccountAccountServiceResult']:
        """
        A Service is a service account that can connect to resources they are granted directly, or granted via roles. Services are typically automated jobs.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tokens(self) -> Sequence['outputs.GetAccountAccountTokenResult']:
        """
        A Token is an account providing tokenized access for automation or integration use. Tokens include admin tokens, API keys, and SCIM tokens.
        """
        return pulumi.get(self, "tokens")

    @property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetAccountAccountUserResult']:
        """
        A User can connect to resources they are granted directly, or granted via roles.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetAccountAccountServiceResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 suspended: Optional[bool] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the User.
        :param str name: Unique human-readable name of the Token.
        :param bool suspended: Reserved for future use.  Always false for tokens.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the User.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Token.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def suspended(self) -> Optional[bool]:
        """
        Reserved for future use.  Always false for tokens.
        """
        return pulumi.get(self, "suspended")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAccountAccountTokenResult(dict):
    def __init__(__self__, *,
                 account_type: Optional[str] = None,
                 deadline: Optional[str] = None,
                 duration: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 permissions: Optional[Sequence[str]] = None,
                 rekeyed: Optional[str] = None,
                 suspended: Optional[bool] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str account_type: Corresponds to the type of token, e.g. api or admin-token.
        :param str deadline: The timestamp when the Token will expire.
        :param str duration: Duration from token creation to expiration.
        :param str id: Unique identifier of the User.
        :param str name: Unique human-readable name of the Token.
        :param Sequence[str] permissions: Permissions assigned to the token, e.g. role:create.
        :param str rekeyed: The timestamp when the Token was last rekeyed.
        :param bool suspended: Reserved for future use.  Always false for tokens.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if account_type is not None:
            pulumi.set(__self__, "account_type", account_type)
        if deadline is not None:
            pulumi.set(__self__, "deadline", deadline)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if rekeyed is not None:
            pulumi.set(__self__, "rekeyed", rekeyed)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accountType")
    def account_type(self) -> Optional[str]:
        """
        Corresponds to the type of token, e.g. api or admin-token.
        """
        return pulumi.get(self, "account_type")

    @property
    @pulumi.getter
    def deadline(self) -> Optional[str]:
        """
        The timestamp when the Token will expire.
        """
        return pulumi.get(self, "deadline")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Duration from token creation to expiration.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the User.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Token.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[str]]:
        """
        Permissions assigned to the token, e.g. role:create.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def rekeyed(self) -> Optional[str]:
        """
        The timestamp when the Token was last rekeyed.
        """
        return pulumi.get(self, "rekeyed")

    @property
    @pulumi.getter
    def suspended(self) -> Optional[bool]:
        """
        Reserved for future use.  Always false for tokens.
        """
        return pulumi.get(self, "suspended")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAccountAccountUserResult(dict):
    def __init__(__self__, *,
                 managed_by: str,
                 suspended: bool,
                 email: Optional[str] = None,
                 external_id: Optional[str] = None,
                 first_name: Optional[str] = None,
                 id: Optional[str] = None,
                 last_name: Optional[str] = None,
                 permission_level: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str managed_by: Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        :param bool suspended: Reserved for future use.  Always false for tokens.
        :param str email: The User's email address. Must be unique.
        :param str external_id: External ID is an alternative unique ID this user is represented by within an external service.
        :param str first_name: The User's first name.
        :param str id: Unique identifier of the User.
        :param str last_name: The User's last name.
        :param str permission_level: PermissionLevel is the user's permission level e.g. admin, DBA, user.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "managed_by", managed_by)
        pulumi.set(__self__, "suspended", suspended)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="managedBy")
    def managed_by(self) -> str:
        """
        Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        """
        return pulumi.get(self, "managed_by")

    @property
    @pulumi.getter
    def suspended(self) -> bool:
        """
        Reserved for future use.  Always false for tokens.
        """
        return pulumi.get(self, "suspended")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The User's email address. Must be unique.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        External ID is an alternative unique ID this user is represented by within an external service.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        """
        The User's first name.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the User.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        """
        The User's last name.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[str]:
        """
        PermissionLevel is the user's permission level e.g. admin, DBA, user.
        """
        return pulumi.get(self, "permission_level")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAccountAttachmentAccountAttachmentResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 id: Optional[str] = None,
                 role_id: Optional[str] = None):
        """
        :param str account_id: The id of the account of this AccountAttachment.
        :param str id: Unique identifier of the AccountAttachment.
        :param str role_id: The id of the attached role of this AccountAttachment.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The id of the account of this AccountAttachment.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the AccountAttachment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[str]:
        """
        The id of the attached role of this AccountAttachment.
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class GetApprovalWorkflowApprovalWorkflowResult(dict):
    def __init__(__self__, *,
                 approval_mode: Optional[str] = None,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str approval_mode: Approval mode of the ApprovalWorkflow
        :param str description: Optional description of the ApprovalWorkflow.
        :param str id: Unique identifier of the ApprovalWorkflow.
        :param str name: Unique human-readable name of the ApprovalWorkflow.
        """
        if approval_mode is not None:
            pulumi.set(__self__, "approval_mode", approval_mode)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="approvalMode")
    def approval_mode(self) -> Optional[str]:
        """
        Approval mode of the ApprovalWorkflow
        """
        return pulumi.get(self, "approval_mode")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Optional description of the ApprovalWorkflow.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the ApprovalWorkflow.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the ApprovalWorkflow.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApprovalWorkflowApproverApprovalWorkflowApproverResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 approval_flow_id: Optional[str] = None,
                 approval_step_id: Optional[str] = None,
                 id: Optional[str] = None,
                 role_id: Optional[str] = None):
        """
        :param str account_id: The approver account id.
        :param str approval_flow_id: The approval flow id specified the approval workflow that this approver belongs to
        :param str approval_step_id: The approval step id specified the approval flow step that this approver belongs to
        :param str id: Unique identifier of the ApprovalWorkflowApprover.
        :param str role_id: The approver role id
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if approval_flow_id is not None:
            pulumi.set(__self__, "approval_flow_id", approval_flow_id)
        if approval_step_id is not None:
            pulumi.set(__self__, "approval_step_id", approval_step_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The approver account id.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="approvalFlowId")
    def approval_flow_id(self) -> Optional[str]:
        """
        The approval flow id specified the approval workflow that this approver belongs to
        """
        return pulumi.get(self, "approval_flow_id")

    @property
    @pulumi.getter(name="approvalStepId")
    def approval_step_id(self) -> Optional[str]:
        """
        The approval step id specified the approval flow step that this approver belongs to
        """
        return pulumi.get(self, "approval_step_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the ApprovalWorkflowApprover.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[str]:
        """
        The approver role id
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class GetApprovalWorkflowStepApprovalWorkflowStepResult(dict):
    def __init__(__self__, *,
                 approval_flow_id: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str approval_flow_id: The approval flow id specified the approval workfflow that this step belongs to
        :param str id: Unique identifier of the ApprovalWorkflowStep.
        """
        if approval_flow_id is not None:
            pulumi.set(__self__, "approval_flow_id", approval_flow_id)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="approvalFlowId")
    def approval_flow_id(self) -> Optional[str]:
        """
        The approval flow id specified the approval workfflow that this step belongs to
        """
        return pulumi.get(self, "approval_flow_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the ApprovalWorkflowStep.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetIdentityAliasIdentityAliasResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str account_id: The account for this identity alias.
        :param str id: Unique identifier of the IdentityAlias.
        :param str identity_set_id: The identity set.
        :param str username: The username to be used as the identity alias for this account.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The account for this identity alias.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the IdentityAlias.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The identity set.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to be used as the identity alias for this account.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetIdentitySetIdentitySetResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: Unique identifier of the IdentitySet.
        :param str name: Unique human-readable name of the IdentitySet.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the IdentitySet.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the IdentitySet.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNodeNodeResult(dict):
    def __init__(__self__, *,
                 gateways: Sequence['outputs.GetNodeNodeGatewayResult'],
                 relays: Sequence['outputs.GetNodeNodeRelayResult']):
        """
        :param Sequence['GetNodeNodeGatewayArgs'] gateways: Gateway represents a StrongDM CLI installation running in gateway mode.
        :param Sequence['GetNodeNodeRelayArgs'] relays: Relay represents a StrongDM CLI installation running in relay mode.
        """
        pulumi.set(__self__, "gateways", gateways)
        pulumi.set(__self__, "relays", relays)

    @property
    @pulumi.getter
    def gateways(self) -> Sequence['outputs.GetNodeNodeGatewayResult']:
        """
        Gateway represents a StrongDM CLI installation running in gateway mode.
        """
        return pulumi.get(self, "gateways")

    @property
    @pulumi.getter
    def relays(self) -> Sequence['outputs.GetNodeNodeRelayResult']:
        """
        Relay represents a StrongDM CLI installation running in relay mode.
        """
        return pulumi.get(self, "relays")


@pulumi.output_type
class GetNodeNodeGatewayResult(dict):
    def __init__(__self__, *,
                 device: str,
                 location: str,
                 version: str,
                 bind_address: Optional[str] = None,
                 gateway_filter: Optional[str] = None,
                 id: Optional[str] = None,
                 listen_address: Optional[str] = None,
                 maintenance_windows: Optional[Sequence['outputs.GetNodeNodeGatewayMaintenanceWindowResult']] = None,
                 name: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param str location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param str version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        :param str bind_address: The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        :param str gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param str id: Unique identifier of the Relay.
        :param str listen_address: The public hostname/port tuple at which the gateway will be accessible to clients.
        :param Sequence['GetNodeNodeGatewayMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "version", version)
        if bind_address is not None:
            pulumi.set(__self__, "bind_address", bind_address)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if listen_address is not None:
            pulumi.set(__self__, "listen_address", listen_address)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def device(self) -> str:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> Optional[str]:
        """
        The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        """
        return pulumi.get(self, "bind_address")

    @property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[str]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Relay.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> Optional[str]:
        """
        The public hostname/port tuple at which the gateway will be accessible to clients.
        """
        return pulumi.get(self, "listen_address")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.GetNodeNodeGatewayMaintenanceWindowResult']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetNodeNodeGatewayMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 cron_schedule: str,
                 require_idleness: bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> str:
        return pulumi.get(self, "cron_schedule")

    @property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class GetNodeNodeRelayResult(dict):
    def __init__(__self__, *,
                 device: str,
                 location: str,
                 version: str,
                 gateway_filter: Optional[str] = None,
                 id: Optional[str] = None,
                 maintenance_windows: Optional[Sequence['outputs.GetNodeNodeRelayMaintenanceWindowResult']] = None,
                 name: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param str location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param str version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        :param str gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param str id: Unique identifier of the Relay.
        :param Sequence['GetNodeNodeRelayMaintenanceWindowArgs'] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "version", version)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def device(self) -> str:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[str]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Relay.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.GetNodeNodeRelayMaintenanceWindowResult']]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetNodeNodeRelayMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 cron_schedule: str,
                 require_idleness: bool):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> str:
        return pulumi.get(self, "cron_schedule")

    @property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> bool:
        return pulumi.get(self, "require_idleness")


@pulumi.output_type
class GetPeeringGroupNodePeeringGroupNodeResult(dict):
    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 id: Optional[str] = None,
                 node_id: Optional[str] = None):
        """
        :param str group_id: Peering Group ID to which the node will be attached to.
        :param str id: Unique identifier of the Attachment.
        :param str node_id: Node ID to be attached.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        Peering Group ID to which the node will be attached to.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Attachment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        """
        Node ID to be attached.
        """
        return pulumi.get(self, "node_id")


@pulumi.output_type
class GetPeeringGroupPeerPeeringGroupPeerResult(dict):
    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 id: Optional[str] = None,
                 peers_with_group_id: Optional[str] = None):
        """
        :param str group_id: Group ID from which the link will originate.
        :param str id: Unique identifier of the Attachment.
        :param str peers_with_group_id: Peering Group ID to which Group ID will link.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if peers_with_group_id is not None:
            pulumi.set(__self__, "peers_with_group_id", peers_with_group_id)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        Group ID from which the link will originate.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Attachment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="peersWithGroupId")
    def peers_with_group_id(self) -> Optional[str]:
        """
        Peering Group ID to which Group ID will link.
        """
        return pulumi.get(self, "peers_with_group_id")


@pulumi.output_type
class GetPeeringGroupPeeringGroupResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: Unique identifier of the PeeringGroup.
        :param str name: Unique human-readable name of the PeeringGroup.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the PeeringGroup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the PeeringGroup.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPeeringGroupResourcePeeringGroupResourceResult(dict):
    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 id: Optional[str] = None,
                 resource_id: Optional[str] = None):
        """
        :param str group_id: Peering Group ID to which the resource will be attached to.
        :param str id: Unique identifier of the Attachment.
        :param str resource_id: Resource ID to be attached.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        Peering Group ID to which the resource will be attached to.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Attachment.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Resource ID to be attached.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class GetRemoteIdentityGroupRemoteIdentityGroupResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: Unique identifier of the RemoteIdentityGroup.
        :param str name: Unique human-readable name of the RemoteIdentityGroup.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the RemoteIdentityGroup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the RemoteIdentityGroup.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRemoteIdentityRemoteIdentityResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 id: Optional[str] = None,
                 remote_identity_group_id: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str account_id: The account for this remote identity.
        :param str id: Unique identifier of the RemoteIdentity.
        :param str remote_identity_group_id: The remote identity group.
        :param str username: The username to be used as the remote identity for this account.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if remote_identity_group_id is not None:
            pulumi.set(__self__, "remote_identity_group_id", remote_identity_group_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The account for this remote identity.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the RemoteIdentity.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="remoteIdentityGroupId")
    def remote_identity_group_id(self) -> Optional[str]:
        """
        The remote identity group.
        """
        return pulumi.get(self, "remote_identity_group_id")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to be used as the remote identity for this account.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceResult(dict):
    def __init__(__self__, *,
                 aks: Sequence['outputs.GetResourceResourceAkResult'],
                 aks_basic_auths: Sequence['outputs.GetResourceResourceAksBasicAuthResult'],
                 aks_service_account_user_impersonations: Sequence['outputs.GetResourceResourceAksServiceAccountUserImpersonationResult'],
                 aks_service_accounts: Sequence['outputs.GetResourceResourceAksServiceAccountResult'],
                 aks_user_impersonations: Sequence['outputs.GetResourceResourceAksUserImpersonationResult'],
                 amazon_eks: Sequence['outputs.GetResourceResourceAmazonEkResult'],
                 amazon_eks_instance_profile_user_impersonations: Sequence['outputs.GetResourceResourceAmazonEksInstanceProfileUserImpersonationResult'],
                 amazon_eks_instance_profiles: Sequence['outputs.GetResourceResourceAmazonEksInstanceProfileResult'],
                 amazon_eks_user_impersonations: Sequence['outputs.GetResourceResourceAmazonEksUserImpersonationResult'],
                 amazon_es: Sequence['outputs.GetResourceResourceAmazonEResult'],
                 amazonmq_amqp091s: Sequence['outputs.GetResourceResourceAmazonmqAmqp091Result'],
                 athenas: Sequence['outputs.GetResourceResourceAthenaResult'],
                 aurora_mysqls: Sequence['outputs.GetResourceResourceAuroraMysqlResult'],
                 aurora_postgres: Sequence['outputs.GetResourceResourceAuroraPostgreResult'],
                 aurora_postgres_iams: Sequence['outputs.GetResourceResourceAuroraPostgresIamResult'],
                 aws: Sequence['outputs.GetResourceResourceAwResult'],
                 aws_console_static_key_pairs: Sequence['outputs.GetResourceResourceAwsConsoleStaticKeyPairResult'],
                 aws_consoles: Sequence['outputs.GetResourceResourceAwsConsoleResult'],
                 azure_certificates: Sequence['outputs.GetResourceResourceAzureCertificateResult'],
                 azure_mysqls: Sequence['outputs.GetResourceResourceAzureMysqlResult'],
                 azure_postgres: Sequence['outputs.GetResourceResourceAzurePostgreResult'],
                 azure_postgres_managed_identities: Sequence['outputs.GetResourceResourceAzurePostgresManagedIdentityResult'],
                 azures: Sequence['outputs.GetResourceResourceAzureResult'],
                 big_queries: Sequence['outputs.GetResourceResourceBigQueryResult'],
                 cassandras: Sequence['outputs.GetResourceResourceCassandraResult'],
                 cituses: Sequence['outputs.GetResourceResourceCitusResult'],
                 clustrixes: Sequence['outputs.GetResourceResourceClustrixResult'],
                 cockroaches: Sequence['outputs.GetResourceResourceCockroachResult'],
                 db2_is: Sequence['outputs.GetResourceResourceDb2IResult'],
                 db2_luws: Sequence['outputs.GetResourceResourceDb2LuwResult'],
                 document_db_hosts: Sequence['outputs.GetResourceResourceDocumentDbHostResult'],
                 document_db_replica_sets: Sequence['outputs.GetResourceResourceDocumentDbReplicaSetResult'],
                 druids: Sequence['outputs.GetResourceResourceDruidResult'],
                 dynamo_dbs: Sequence['outputs.GetResourceResourceDynamoDbResult'],
                 elasticache_redis: Sequence['outputs.GetResourceResourceElasticacheRediResult'],
                 elastics: Sequence['outputs.GetResourceResourceElasticResult'],
                 gcps: Sequence['outputs.GetResourceResourceGcpResult'],
                 google_gke_user_impersonations: Sequence['outputs.GetResourceResourceGoogleGkeUserImpersonationResult'],
                 google_gkes: Sequence['outputs.GetResourceResourceGoogleGkeResult'],
                 greenplums: Sequence['outputs.GetResourceResourceGreenplumResult'],
                 http_auths: Sequence['outputs.GetResourceResourceHttpAuthResult'],
                 http_basic_auths: Sequence['outputs.GetResourceResourceHttpBasicAuthResult'],
                 http_no_auths: Sequence['outputs.GetResourceResourceHttpNoAuthResult'],
                 kubernetes: Sequence['outputs.GetResourceResourceKuberneteResult'],
                 kubernetes_basic_auths: Sequence['outputs.GetResourceResourceKubernetesBasicAuthResult'],
                 kubernetes_service_account_user_impersonations: Sequence['outputs.GetResourceResourceKubernetesServiceAccountUserImpersonationResult'],
                 kubernetes_service_accounts: Sequence['outputs.GetResourceResourceKubernetesServiceAccountResult'],
                 kubernetes_user_impersonations: Sequence['outputs.GetResourceResourceKubernetesUserImpersonationResult'],
                 marias: Sequence['outputs.GetResourceResourceMariaResult'],
                 memcacheds: Sequence['outputs.GetResourceResourceMemcachedResult'],
                 memsqls: Sequence['outputs.GetResourceResourceMemsqlResult'],
                 mongo_hosts: Sequence['outputs.GetResourceResourceMongoHostResult'],
                 mongo_legacy_hosts: Sequence['outputs.GetResourceResourceMongoLegacyHostResult'],
                 mongo_legacy_replicasets: Sequence['outputs.GetResourceResourceMongoLegacyReplicasetResult'],
                 mongo_replica_sets: Sequence['outputs.GetResourceResourceMongoReplicaSetResult'],
                 mongo_sharded_clusters: Sequence['outputs.GetResourceResourceMongoShardedClusterResult'],
                 mtls_mysqls: Sequence['outputs.GetResourceResourceMtlsMysqlResult'],
                 mtls_postgres: Sequence['outputs.GetResourceResourceMtlsPostgreResult'],
                 mysqls: Sequence['outputs.GetResourceResourceMysqlResult'],
                 neptune_iams: Sequence['outputs.GetResourceResourceNeptuneIamResult'],
                 neptunes: Sequence['outputs.GetResourceResourceNeptuneResult'],
                 oracles: Sequence['outputs.GetResourceResourceOracleResult'],
                 postgres: Sequence['outputs.GetResourceResourcePostgreResult'],
                 prestos: Sequence['outputs.GetResourceResourcePrestoResult'],
                 rabbitmq_amqp091s: Sequence['outputs.GetResourceResourceRabbitmqAmqp091Result'],
                 raw_tcps: Sequence['outputs.GetResourceResourceRawTcpResult'],
                 rdp_certs: Sequence['outputs.GetResourceResourceRdpCertResult'],
                 rdps: Sequence['outputs.GetResourceResourceRdpResult'],
                 rds_postgres_iams: Sequence['outputs.GetResourceResourceRdsPostgresIamResult'],
                 redis: Sequence['outputs.GetResourceResourceRediResult'],
                 redshifts: Sequence['outputs.GetResourceResourceRedshiftResult'],
                 single_stores: Sequence['outputs.GetResourceResourceSingleStoreResult'],
                 snowflakes: Sequence['outputs.GetResourceResourceSnowflakeResult'],
                 snowsights: Sequence['outputs.GetResourceResourceSnowsightResult'],
                 sql_server_azure_ads: Sequence['outputs.GetResourceResourceSqlServerAzureAdResult'],
                 sql_server_kerberos_ads: Sequence['outputs.GetResourceResourceSqlServerKerberosAdResult'],
                 sql_servers: Sequence['outputs.GetResourceResourceSqlServerResult'],
                 ssh_certs: Sequence['outputs.GetResourceResourceSshCertResult'],
                 ssh_customer_keys: Sequence['outputs.GetResourceResourceSshCustomerKeyResult'],
                 ssh_passwords: Sequence['outputs.GetResourceResourceSshPasswordResult'],
                 sshes: Sequence['outputs.GetResourceResourceSshResult'],
                 sybase_iqs: Sequence['outputs.GetResourceResourceSybaseIqResult'],
                 sybases: Sequence['outputs.GetResourceResourceSybaseResult'],
                 teradatas: Sequence['outputs.GetResourceResourceTeradataResult'],
                 trinos: Sequence['outputs.GetResourceResourceTrinoResult']):
        pulumi.set(__self__, "aks", aks)
        pulumi.set(__self__, "aks_basic_auths", aks_basic_auths)
        pulumi.set(__self__, "aks_service_account_user_impersonations", aks_service_account_user_impersonations)
        pulumi.set(__self__, "aks_service_accounts", aks_service_accounts)
        pulumi.set(__self__, "aks_user_impersonations", aks_user_impersonations)
        pulumi.set(__self__, "amazon_eks", amazon_eks)
        pulumi.set(__self__, "amazon_eks_instance_profile_user_impersonations", amazon_eks_instance_profile_user_impersonations)
        pulumi.set(__self__, "amazon_eks_instance_profiles", amazon_eks_instance_profiles)
        pulumi.set(__self__, "amazon_eks_user_impersonations", amazon_eks_user_impersonations)
        pulumi.set(__self__, "amazon_es", amazon_es)
        pulumi.set(__self__, "amazonmq_amqp091s", amazonmq_amqp091s)
        pulumi.set(__self__, "athenas", athenas)
        pulumi.set(__self__, "aurora_mysqls", aurora_mysqls)
        pulumi.set(__self__, "aurora_postgres", aurora_postgres)
        pulumi.set(__self__, "aurora_postgres_iams", aurora_postgres_iams)
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "aws_console_static_key_pairs", aws_console_static_key_pairs)
        pulumi.set(__self__, "aws_consoles", aws_consoles)
        pulumi.set(__self__, "azure_certificates", azure_certificates)
        pulumi.set(__self__, "azure_mysqls", azure_mysqls)
        pulumi.set(__self__, "azure_postgres", azure_postgres)
        pulumi.set(__self__, "azure_postgres_managed_identities", azure_postgres_managed_identities)
        pulumi.set(__self__, "azures", azures)
        pulumi.set(__self__, "big_queries", big_queries)
        pulumi.set(__self__, "cassandras", cassandras)
        pulumi.set(__self__, "cituses", cituses)
        pulumi.set(__self__, "clustrixes", clustrixes)
        pulumi.set(__self__, "cockroaches", cockroaches)
        pulumi.set(__self__, "db2_is", db2_is)
        pulumi.set(__self__, "db2_luws", db2_luws)
        pulumi.set(__self__, "document_db_hosts", document_db_hosts)
        pulumi.set(__self__, "document_db_replica_sets", document_db_replica_sets)
        pulumi.set(__self__, "druids", druids)
        pulumi.set(__self__, "dynamo_dbs", dynamo_dbs)
        pulumi.set(__self__, "elasticache_redis", elasticache_redis)
        pulumi.set(__self__, "elastics", elastics)
        pulumi.set(__self__, "gcps", gcps)
        pulumi.set(__self__, "google_gke_user_impersonations", google_gke_user_impersonations)
        pulumi.set(__self__, "google_gkes", google_gkes)
        pulumi.set(__self__, "greenplums", greenplums)
        pulumi.set(__self__, "http_auths", http_auths)
        pulumi.set(__self__, "http_basic_auths", http_basic_auths)
        pulumi.set(__self__, "http_no_auths", http_no_auths)
        pulumi.set(__self__, "kubernetes", kubernetes)
        pulumi.set(__self__, "kubernetes_basic_auths", kubernetes_basic_auths)
        pulumi.set(__self__, "kubernetes_service_account_user_impersonations", kubernetes_service_account_user_impersonations)
        pulumi.set(__self__, "kubernetes_service_accounts", kubernetes_service_accounts)
        pulumi.set(__self__, "kubernetes_user_impersonations", kubernetes_user_impersonations)
        pulumi.set(__self__, "marias", marias)
        pulumi.set(__self__, "memcacheds", memcacheds)
        pulumi.set(__self__, "memsqls", memsqls)
        pulumi.set(__self__, "mongo_hosts", mongo_hosts)
        pulumi.set(__self__, "mongo_legacy_hosts", mongo_legacy_hosts)
        pulumi.set(__self__, "mongo_legacy_replicasets", mongo_legacy_replicasets)
        pulumi.set(__self__, "mongo_replica_sets", mongo_replica_sets)
        pulumi.set(__self__, "mongo_sharded_clusters", mongo_sharded_clusters)
        pulumi.set(__self__, "mtls_mysqls", mtls_mysqls)
        pulumi.set(__self__, "mtls_postgres", mtls_postgres)
        pulumi.set(__self__, "mysqls", mysqls)
        pulumi.set(__self__, "neptune_iams", neptune_iams)
        pulumi.set(__self__, "neptunes", neptunes)
        pulumi.set(__self__, "oracles", oracles)
        pulumi.set(__self__, "postgres", postgres)
        pulumi.set(__self__, "prestos", prestos)
        pulumi.set(__self__, "rabbitmq_amqp091s", rabbitmq_amqp091s)
        pulumi.set(__self__, "raw_tcps", raw_tcps)
        pulumi.set(__self__, "rdp_certs", rdp_certs)
        pulumi.set(__self__, "rdps", rdps)
        pulumi.set(__self__, "rds_postgres_iams", rds_postgres_iams)
        pulumi.set(__self__, "redis", redis)
        pulumi.set(__self__, "redshifts", redshifts)
        pulumi.set(__self__, "single_stores", single_stores)
        pulumi.set(__self__, "snowflakes", snowflakes)
        pulumi.set(__self__, "snowsights", snowsights)
        pulumi.set(__self__, "sql_server_azure_ads", sql_server_azure_ads)
        pulumi.set(__self__, "sql_server_kerberos_ads", sql_server_kerberos_ads)
        pulumi.set(__self__, "sql_servers", sql_servers)
        pulumi.set(__self__, "ssh_certs", ssh_certs)
        pulumi.set(__self__, "ssh_customer_keys", ssh_customer_keys)
        pulumi.set(__self__, "ssh_passwords", ssh_passwords)
        pulumi.set(__self__, "sshes", sshes)
        pulumi.set(__self__, "sybase_iqs", sybase_iqs)
        pulumi.set(__self__, "sybases", sybases)
        pulumi.set(__self__, "teradatas", teradatas)
        pulumi.set(__self__, "trinos", trinos)

    @property
    @pulumi.getter
    def aks(self) -> Sequence['outputs.GetResourceResourceAkResult']:
        return pulumi.get(self, "aks")

    @property
    @pulumi.getter(name="aksBasicAuths")
    def aks_basic_auths(self) -> Sequence['outputs.GetResourceResourceAksBasicAuthResult']:
        return pulumi.get(self, "aks_basic_auths")

    @property
    @pulumi.getter(name="aksServiceAccountUserImpersonations")
    def aks_service_account_user_impersonations(self) -> Sequence['outputs.GetResourceResourceAksServiceAccountUserImpersonationResult']:
        return pulumi.get(self, "aks_service_account_user_impersonations")

    @property
    @pulumi.getter(name="aksServiceAccounts")
    def aks_service_accounts(self) -> Sequence['outputs.GetResourceResourceAksServiceAccountResult']:
        return pulumi.get(self, "aks_service_accounts")

    @property
    @pulumi.getter(name="aksUserImpersonations")
    def aks_user_impersonations(self) -> Sequence['outputs.GetResourceResourceAksUserImpersonationResult']:
        return pulumi.get(self, "aks_user_impersonations")

    @property
    @pulumi.getter(name="amazonEks")
    def amazon_eks(self) -> Sequence['outputs.GetResourceResourceAmazonEkResult']:
        return pulumi.get(self, "amazon_eks")

    @property
    @pulumi.getter(name="amazonEksInstanceProfileUserImpersonations")
    def amazon_eks_instance_profile_user_impersonations(self) -> Sequence['outputs.GetResourceResourceAmazonEksInstanceProfileUserImpersonationResult']:
        return pulumi.get(self, "amazon_eks_instance_profile_user_impersonations")

    @property
    @pulumi.getter(name="amazonEksInstanceProfiles")
    def amazon_eks_instance_profiles(self) -> Sequence['outputs.GetResourceResourceAmazonEksInstanceProfileResult']:
        return pulumi.get(self, "amazon_eks_instance_profiles")

    @property
    @pulumi.getter(name="amazonEksUserImpersonations")
    def amazon_eks_user_impersonations(self) -> Sequence['outputs.GetResourceResourceAmazonEksUserImpersonationResult']:
        return pulumi.get(self, "amazon_eks_user_impersonations")

    @property
    @pulumi.getter(name="amazonEs")
    def amazon_es(self) -> Sequence['outputs.GetResourceResourceAmazonEResult']:
        return pulumi.get(self, "amazon_es")

    @property
    @pulumi.getter(name="amazonmqAmqp091s")
    def amazonmq_amqp091s(self) -> Sequence['outputs.GetResourceResourceAmazonmqAmqp091Result']:
        return pulumi.get(self, "amazonmq_amqp091s")

    @property
    @pulumi.getter
    def athenas(self) -> Sequence['outputs.GetResourceResourceAthenaResult']:
        return pulumi.get(self, "athenas")

    @property
    @pulumi.getter(name="auroraMysqls")
    def aurora_mysqls(self) -> Sequence['outputs.GetResourceResourceAuroraMysqlResult']:
        return pulumi.get(self, "aurora_mysqls")

    @property
    @pulumi.getter(name="auroraPostgres")
    def aurora_postgres(self) -> Sequence['outputs.GetResourceResourceAuroraPostgreResult']:
        return pulumi.get(self, "aurora_postgres")

    @property
    @pulumi.getter(name="auroraPostgresIams")
    def aurora_postgres_iams(self) -> Sequence['outputs.GetResourceResourceAuroraPostgresIamResult']:
        return pulumi.get(self, "aurora_postgres_iams")

    @property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetResourceResourceAwResult']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="awsConsoleStaticKeyPairs")
    def aws_console_static_key_pairs(self) -> Sequence['outputs.GetResourceResourceAwsConsoleStaticKeyPairResult']:
        return pulumi.get(self, "aws_console_static_key_pairs")

    @property
    @pulumi.getter(name="awsConsoles")
    def aws_consoles(self) -> Sequence['outputs.GetResourceResourceAwsConsoleResult']:
        return pulumi.get(self, "aws_consoles")

    @property
    @pulumi.getter(name="azureCertificates")
    def azure_certificates(self) -> Sequence['outputs.GetResourceResourceAzureCertificateResult']:
        return pulumi.get(self, "azure_certificates")

    @property
    @pulumi.getter(name="azureMysqls")
    def azure_mysqls(self) -> Sequence['outputs.GetResourceResourceAzureMysqlResult']:
        return pulumi.get(self, "azure_mysqls")

    @property
    @pulumi.getter(name="azurePostgres")
    def azure_postgres(self) -> Sequence['outputs.GetResourceResourceAzurePostgreResult']:
        return pulumi.get(self, "azure_postgres")

    @property
    @pulumi.getter(name="azurePostgresManagedIdentities")
    def azure_postgres_managed_identities(self) -> Sequence['outputs.GetResourceResourceAzurePostgresManagedIdentityResult']:
        return pulumi.get(self, "azure_postgres_managed_identities")

    @property
    @pulumi.getter
    def azures(self) -> Sequence['outputs.GetResourceResourceAzureResult']:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter(name="bigQueries")
    def big_queries(self) -> Sequence['outputs.GetResourceResourceBigQueryResult']:
        return pulumi.get(self, "big_queries")

    @property
    @pulumi.getter
    def cassandras(self) -> Sequence['outputs.GetResourceResourceCassandraResult']:
        return pulumi.get(self, "cassandras")

    @property
    @pulumi.getter
    def cituses(self) -> Sequence['outputs.GetResourceResourceCitusResult']:
        return pulumi.get(self, "cituses")

    @property
    @pulumi.getter
    def clustrixes(self) -> Sequence['outputs.GetResourceResourceClustrixResult']:
        return pulumi.get(self, "clustrixes")

    @property
    @pulumi.getter
    def cockroaches(self) -> Sequence['outputs.GetResourceResourceCockroachResult']:
        return pulumi.get(self, "cockroaches")

    @property
    @pulumi.getter(name="db2Is")
    def db2_is(self) -> Sequence['outputs.GetResourceResourceDb2IResult']:
        return pulumi.get(self, "db2_is")

    @property
    @pulumi.getter(name="db2Luws")
    def db2_luws(self) -> Sequence['outputs.GetResourceResourceDb2LuwResult']:
        return pulumi.get(self, "db2_luws")

    @property
    @pulumi.getter(name="documentDbHosts")
    def document_db_hosts(self) -> Sequence['outputs.GetResourceResourceDocumentDbHostResult']:
        return pulumi.get(self, "document_db_hosts")

    @property
    @pulumi.getter(name="documentDbReplicaSets")
    def document_db_replica_sets(self) -> Sequence['outputs.GetResourceResourceDocumentDbReplicaSetResult']:
        return pulumi.get(self, "document_db_replica_sets")

    @property
    @pulumi.getter
    def druids(self) -> Sequence['outputs.GetResourceResourceDruidResult']:
        return pulumi.get(self, "druids")

    @property
    @pulumi.getter(name="dynamoDbs")
    def dynamo_dbs(self) -> Sequence['outputs.GetResourceResourceDynamoDbResult']:
        return pulumi.get(self, "dynamo_dbs")

    @property
    @pulumi.getter(name="elasticacheRedis")
    def elasticache_redis(self) -> Sequence['outputs.GetResourceResourceElasticacheRediResult']:
        return pulumi.get(self, "elasticache_redis")

    @property
    @pulumi.getter
    def elastics(self) -> Sequence['outputs.GetResourceResourceElasticResult']:
        return pulumi.get(self, "elastics")

    @property
    @pulumi.getter
    def gcps(self) -> Sequence['outputs.GetResourceResourceGcpResult']:
        return pulumi.get(self, "gcps")

    @property
    @pulumi.getter(name="googleGkeUserImpersonations")
    def google_gke_user_impersonations(self) -> Sequence['outputs.GetResourceResourceGoogleGkeUserImpersonationResult']:
        return pulumi.get(self, "google_gke_user_impersonations")

    @property
    @pulumi.getter(name="googleGkes")
    def google_gkes(self) -> Sequence['outputs.GetResourceResourceGoogleGkeResult']:
        return pulumi.get(self, "google_gkes")

    @property
    @pulumi.getter
    def greenplums(self) -> Sequence['outputs.GetResourceResourceGreenplumResult']:
        return pulumi.get(self, "greenplums")

    @property
    @pulumi.getter(name="httpAuths")
    def http_auths(self) -> Sequence['outputs.GetResourceResourceHttpAuthResult']:
        return pulumi.get(self, "http_auths")

    @property
    @pulumi.getter(name="httpBasicAuths")
    def http_basic_auths(self) -> Sequence['outputs.GetResourceResourceHttpBasicAuthResult']:
        return pulumi.get(self, "http_basic_auths")

    @property
    @pulumi.getter(name="httpNoAuths")
    def http_no_auths(self) -> Sequence['outputs.GetResourceResourceHttpNoAuthResult']:
        return pulumi.get(self, "http_no_auths")

    @property
    @pulumi.getter
    def kubernetes(self) -> Sequence['outputs.GetResourceResourceKuberneteResult']:
        return pulumi.get(self, "kubernetes")

    @property
    @pulumi.getter(name="kubernetesBasicAuths")
    def kubernetes_basic_auths(self) -> Sequence['outputs.GetResourceResourceKubernetesBasicAuthResult']:
        return pulumi.get(self, "kubernetes_basic_auths")

    @property
    @pulumi.getter(name="kubernetesServiceAccountUserImpersonations")
    def kubernetes_service_account_user_impersonations(self) -> Sequence['outputs.GetResourceResourceKubernetesServiceAccountUserImpersonationResult']:
        return pulumi.get(self, "kubernetes_service_account_user_impersonations")

    @property
    @pulumi.getter(name="kubernetesServiceAccounts")
    def kubernetes_service_accounts(self) -> Sequence['outputs.GetResourceResourceKubernetesServiceAccountResult']:
        return pulumi.get(self, "kubernetes_service_accounts")

    @property
    @pulumi.getter(name="kubernetesUserImpersonations")
    def kubernetes_user_impersonations(self) -> Sequence['outputs.GetResourceResourceKubernetesUserImpersonationResult']:
        return pulumi.get(self, "kubernetes_user_impersonations")

    @property
    @pulumi.getter
    def marias(self) -> Sequence['outputs.GetResourceResourceMariaResult']:
        return pulumi.get(self, "marias")

    @property
    @pulumi.getter
    def memcacheds(self) -> Sequence['outputs.GetResourceResourceMemcachedResult']:
        return pulumi.get(self, "memcacheds")

    @property
    @pulumi.getter
    def memsqls(self) -> Sequence['outputs.GetResourceResourceMemsqlResult']:
        return pulumi.get(self, "memsqls")

    @property
    @pulumi.getter(name="mongoHosts")
    def mongo_hosts(self) -> Sequence['outputs.GetResourceResourceMongoHostResult']:
        return pulumi.get(self, "mongo_hosts")

    @property
    @pulumi.getter(name="mongoLegacyHosts")
    def mongo_legacy_hosts(self) -> Sequence['outputs.GetResourceResourceMongoLegacyHostResult']:
        return pulumi.get(self, "mongo_legacy_hosts")

    @property
    @pulumi.getter(name="mongoLegacyReplicasets")
    def mongo_legacy_replicasets(self) -> Sequence['outputs.GetResourceResourceMongoLegacyReplicasetResult']:
        return pulumi.get(self, "mongo_legacy_replicasets")

    @property
    @pulumi.getter(name="mongoReplicaSets")
    def mongo_replica_sets(self) -> Sequence['outputs.GetResourceResourceMongoReplicaSetResult']:
        return pulumi.get(self, "mongo_replica_sets")

    @property
    @pulumi.getter(name="mongoShardedClusters")
    def mongo_sharded_clusters(self) -> Sequence['outputs.GetResourceResourceMongoShardedClusterResult']:
        return pulumi.get(self, "mongo_sharded_clusters")

    @property
    @pulumi.getter(name="mtlsMysqls")
    def mtls_mysqls(self) -> Sequence['outputs.GetResourceResourceMtlsMysqlResult']:
        return pulumi.get(self, "mtls_mysqls")

    @property
    @pulumi.getter(name="mtlsPostgres")
    def mtls_postgres(self) -> Sequence['outputs.GetResourceResourceMtlsPostgreResult']:
        return pulumi.get(self, "mtls_postgres")

    @property
    @pulumi.getter
    def mysqls(self) -> Sequence['outputs.GetResourceResourceMysqlResult']:
        return pulumi.get(self, "mysqls")

    @property
    @pulumi.getter(name="neptuneIams")
    def neptune_iams(self) -> Sequence['outputs.GetResourceResourceNeptuneIamResult']:
        return pulumi.get(self, "neptune_iams")

    @property
    @pulumi.getter
    def neptunes(self) -> Sequence['outputs.GetResourceResourceNeptuneResult']:
        return pulumi.get(self, "neptunes")

    @property
    @pulumi.getter
    def oracles(self) -> Sequence['outputs.GetResourceResourceOracleResult']:
        return pulumi.get(self, "oracles")

    @property
    @pulumi.getter
    def postgres(self) -> Sequence['outputs.GetResourceResourcePostgreResult']:
        return pulumi.get(self, "postgres")

    @property
    @pulumi.getter
    def prestos(self) -> Sequence['outputs.GetResourceResourcePrestoResult']:
        return pulumi.get(self, "prestos")

    @property
    @pulumi.getter(name="rabbitmqAmqp091s")
    def rabbitmq_amqp091s(self) -> Sequence['outputs.GetResourceResourceRabbitmqAmqp091Result']:
        return pulumi.get(self, "rabbitmq_amqp091s")

    @property
    @pulumi.getter(name="rawTcps")
    def raw_tcps(self) -> Sequence['outputs.GetResourceResourceRawTcpResult']:
        return pulumi.get(self, "raw_tcps")

    @property
    @pulumi.getter(name="rdpCerts")
    def rdp_certs(self) -> Sequence['outputs.GetResourceResourceRdpCertResult']:
        return pulumi.get(self, "rdp_certs")

    @property
    @pulumi.getter
    def rdps(self) -> Sequence['outputs.GetResourceResourceRdpResult']:
        return pulumi.get(self, "rdps")

    @property
    @pulumi.getter(name="rdsPostgresIams")
    def rds_postgres_iams(self) -> Sequence['outputs.GetResourceResourceRdsPostgresIamResult']:
        return pulumi.get(self, "rds_postgres_iams")

    @property
    @pulumi.getter
    def redis(self) -> Sequence['outputs.GetResourceResourceRediResult']:
        return pulumi.get(self, "redis")

    @property
    @pulumi.getter
    def redshifts(self) -> Sequence['outputs.GetResourceResourceRedshiftResult']:
        return pulumi.get(self, "redshifts")

    @property
    @pulumi.getter(name="singleStores")
    def single_stores(self) -> Sequence['outputs.GetResourceResourceSingleStoreResult']:
        return pulumi.get(self, "single_stores")

    @property
    @pulumi.getter
    def snowflakes(self) -> Sequence['outputs.GetResourceResourceSnowflakeResult']:
        return pulumi.get(self, "snowflakes")

    @property
    @pulumi.getter
    def snowsights(self) -> Sequence['outputs.GetResourceResourceSnowsightResult']:
        return pulumi.get(self, "snowsights")

    @property
    @pulumi.getter(name="sqlServerAzureAds")
    def sql_server_azure_ads(self) -> Sequence['outputs.GetResourceResourceSqlServerAzureAdResult']:
        return pulumi.get(self, "sql_server_azure_ads")

    @property
    @pulumi.getter(name="sqlServerKerberosAds")
    def sql_server_kerberos_ads(self) -> Sequence['outputs.GetResourceResourceSqlServerKerberosAdResult']:
        return pulumi.get(self, "sql_server_kerberos_ads")

    @property
    @pulumi.getter(name="sqlServers")
    def sql_servers(self) -> Sequence['outputs.GetResourceResourceSqlServerResult']:
        return pulumi.get(self, "sql_servers")

    @property
    @pulumi.getter(name="sshCerts")
    def ssh_certs(self) -> Sequence['outputs.GetResourceResourceSshCertResult']:
        return pulumi.get(self, "ssh_certs")

    @property
    @pulumi.getter(name="sshCustomerKeys")
    def ssh_customer_keys(self) -> Sequence['outputs.GetResourceResourceSshCustomerKeyResult']:
        return pulumi.get(self, "ssh_customer_keys")

    @property
    @pulumi.getter(name="sshPasswords")
    def ssh_passwords(self) -> Sequence['outputs.GetResourceResourceSshPasswordResult']:
        return pulumi.get(self, "ssh_passwords")

    @property
    @pulumi.getter
    def sshes(self) -> Sequence['outputs.GetResourceResourceSshResult']:
        return pulumi.get(self, "sshes")

    @property
    @pulumi.getter(name="sybaseIqs")
    def sybase_iqs(self) -> Sequence['outputs.GetResourceResourceSybaseIqResult']:
        return pulumi.get(self, "sybase_iqs")

    @property
    @pulumi.getter
    def sybases(self) -> Sequence['outputs.GetResourceResourceSybaseResult']:
        return pulumi.get(self, "sybases")

    @property
    @pulumi.getter
    def teradatas(self) -> Sequence['outputs.GetResourceResourceTeradataResult']:
        return pulumi.get(self, "teradatas")

    @property
    @pulumi.getter
    def trinos(self) -> Sequence['outputs.GetResourceResourceTrinoResult']:
        return pulumi.get(self, "trinos")


@pulumi.output_type
class GetResourceResourceAkResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAksBasicAuthResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAksServiceAccountResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetResourceResourceAksServiceAccountUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetResourceResourceAksUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEkResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str cluster_name: The name of the cluster to connect to.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEksInstanceProfileResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str cluster_name: The name of the cluster to connect to.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEksInstanceProfileUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str cluster_name: The name of the cluster to connect to.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonEksUserImpersonationResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str cluster_name: The name of the cluster to connect to.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAmazonmqAmqp091Result(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAthenaResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 output: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str output: The AWS S3 output location.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def output(self) -> Optional[str]:
        """
        The AWS S3 output location.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAuroraMysqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAuroraPostgreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAuroraPostgresIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_assumption_arn: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAwResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_region: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_region: The AWS region healthcheck requests should attempt to connect to.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_region is not None:
            pulumi.set(__self__, "healthcheck_region", healthcheck_region)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckRegion")
    def healthcheck_region(self) -> Optional[str]:
        """
        The AWS region healthcheck requests should attempt to connect to.
        """
        return pulumi.get(self, "healthcheck_region")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAwsConsoleResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 enable_env_variables: Optional[bool] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 session_expiry: Optional[int] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param bool enable_env_variables: If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param int session_expiry: The length of time in seconds AWS console sessions will live before needing to reauthenticate.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if enable_env_variables is not None:
            pulumi.set(__self__, "enable_env_variables", enable_env_variables)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="enableEnvVariables")
    def enable_env_variables(self) -> Optional[bool]:
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        return pulumi.get(self, "enable_env_variables")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[int]:
        """
        The length of time in seconds AWS console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAwsConsoleStaticKeyPairResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 session_expiry: Optional[int] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param int session_expiry: The length of time in seconds AWS console sessions will live before needing to reauthenticate.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[int]:
        """
        The length of time in seconds AWS console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceAzureResult(dict):
    def __init__(__self__, *,
                 app_id: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str app_id: The application ID to authenticate with.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[str]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetResourceResourceAzureCertificateResult(dict):
    def __init__(__self__, *,
                 app_id: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str app_id: The application ID to authenticate with.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[str]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetResourceResourceAzureMysqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAzurePostgreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceAzurePostgresManagedIdentityResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceBigQueryResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 private_key: Optional[str] = None,
                 project: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str private_key: The private key used to authenticate with the server.
        :param str project: The project to connect to.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        The project to connect to.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceCassandraResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceCitusResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceClustrixResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceCockroachResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDb2IResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDb2LuwResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDocumentDbHostResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDocumentDbReplicaSetResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 connect_to_replica: Optional[bool] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 replica_set: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str replica_set: The name of the mongo replicaset.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[str]:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDruidResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceDynamoDbResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceElasticResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceElasticacheRediResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceGcpResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 id: Optional[str] = None,
                 keyfile: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 scopes: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str id: Unique identifier of the Resource.
        :param str keyfile: The service account keyfile to authenticate with.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str scopes: Space separated scopes that this login should assume into when authenticating.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def keyfile(self) -> Optional[str]:
        """
        The service account keyfile to authenticate with.
        """
        return pulumi.get(self, "keyfile")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[str]:
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceGoogleGkeResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 service_account_key: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str service_account_key: The service account key to authenticate with.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[str]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceGoogleGkeUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 service_account_key: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str service_account_key: The service account key to authenticate with.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[str]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceGreenplumResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceHttpAuthResult(dict):
    def __init__(__self__, *,
                 auth_header: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 default_path: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 headers_blacklist: Optional[str] = None,
                 healthcheck_path: Optional[str] = None,
                 host_override: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 url: Optional[str] = None):
        """
        :param str auth_header: The content to set as the authorization header.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str default_path: Automatically redirect to this path upon connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param str healthcheck_path: This path will be used to check the health of your site.
        :param str host_override: The host header will be overwritten with this field if provided.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str url: The base address of your website without the path.
               * kubernetes:
        """
        if auth_header is not None:
            pulumi.set(__self__, "auth_header", auth_header)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if healthcheck_path is not None:
            pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="authHeader")
    def auth_header(self) -> Optional[str]:
        """
        The content to set as the authorization header.
        """
        return pulumi.get(self, "auth_header")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> Optional[str]:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetResourceResourceHttpBasicAuthResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 default_path: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 headers_blacklist: Optional[str] = None,
                 healthcheck_path: Optional[str] = None,
                 host_override: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str default_path: Automatically redirect to this path upon connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param str healthcheck_path: This path will be used to check the health of your site.
        :param str host_override: The host header will be overwritten with this field if provided.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str url: The base address of your website without the path.
               * kubernetes:
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if healthcheck_path is not None:
            pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> Optional[str]:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceHttpNoAuthResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 default_path: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 headers_blacklist: Optional[str] = None,
                 healthcheck_path: Optional[str] = None,
                 host_override: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 url: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str default_path: Automatically redirect to this path upon connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param str healthcheck_path: This path will be used to check the health of your site.
        :param str host_override: The host header will be overwritten with this field if provided.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str url: The base address of your website without the path.
               * kubernetes:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if healthcheck_path is not None:
            pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[str]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[str]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> Optional[str]:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[str]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetResourceResourceKuberneteResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceKubernetesBasicAuthResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceKubernetesServiceAccountResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 discovery_enabled: Optional[bool] = None,
                 discovery_username: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool discovery_enabled: If true, configures discovery of a cluster to be run from a node.
        :param str discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[bool]:
        """
        If true, configures discovery of a cluster to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[str]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetResourceResourceKubernetesServiceAccountUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 token: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetResourceResourceKubernetesUserImpersonationResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_namespace: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[str]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceMariaResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMemcachedResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceMemsqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoHostResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoLegacyHostResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoLegacyReplicasetResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 connect_to_replica: Optional[bool] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 replica_set: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str replica_set: The name of the mongo replicaset.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[str]:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoReplicaSetResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 connect_to_replica: Optional[bool] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 replica_set: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool connect_to_replica: Set to connect to a replica instead of the primary node.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str replica_set: The name of the mongo replicaset.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[bool]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[str]:
        """
        The name of the mongo replicaset.
        """
        return pulumi.get(self, "replica_set")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMongoShardedClusterResult(dict):
    def __init__(__self__, *,
                 auth_database: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str auth_database: The authentication database to use.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if auth_database is not None:
            pulumi.set(__self__, "auth_database", auth_database)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> Optional[str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMtlsMysqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 server_name: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMtlsPostgreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 certificate_authority: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 server_name: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str certificate_authority: The CA to authenticate TLS connections with.
        :param str client_certificate: The certificate to authenticate TLS connections with.
        :param str client_key: The key to authenticate TLS connections with.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[str]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceMysqlResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceNeptuneResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceNeptuneIamResult(dict):
    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 role_external_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str access_key: The Access Key ID to use to authenticate.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_arn: The role to assume after logging in.
        :param str role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param str secret_access_key: The Secret Access Key to use to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[str]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceOracleResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourcePostgreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourcePrestoResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRabbitmqAmqp091Result(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRawTcpResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceRdpResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 downgrade_nla_connections: Optional[bool] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 lock_required: Optional[bool] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param bool downgrade_nla_connections: When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param bool lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if downgrade_nla_connections is not None:
            pulumi.set(__self__, "downgrade_nla_connections", downgrade_nla_connections)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="downgradeNlaConnections")
    def downgrade_nla_connections(self) -> Optional[bool]:
        """
        When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        """
        return pulumi.get(self, "downgrade_nla_connections")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[bool]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRdpCertResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRdsPostgresIamResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 region: Optional[str] = None,
                 role_assumption_arn: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str region: The AWS region to connect to.
        :param str role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[str]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRediResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tls_required: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool tls_required: If set, TLS must be used to connect to this resource.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[bool]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceRedshiftResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSingleStoreResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 require_native_auth: Optional[bool] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 use_azure_single_server_usernames: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param bool require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param bool use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[bool]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[bool]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSnowflakeResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port_override: Optional[int] = None,
                 schema: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str schema: The Schema to use to direct initial requests.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSnowsightResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 healthcheck_username: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_override: Optional[int] = None,
                 saml_metadata: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str healthcheck_username: The StrongDM user email to use for healthchecks.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str saml_metadata: The Metadata for your snowflake IDP integration
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_username is not None:
            pulumi.set(__self__, "healthcheck_username", healthcheck_username)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if saml_metadata is not None:
            pulumi.set(__self__, "saml_metadata", saml_metadata)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter(name="healthcheckUsername")
    def healthcheck_username(self) -> Optional[str]:
        """
        The StrongDM user email to use for healthchecks.
        """
        return pulumi.get(self, "healthcheck_username")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="samlMetadata")
    def saml_metadata(self) -> Optional[str]:
        """
        The Metadata for your snowflake IDP integration
        """
        return pulumi.get(self, "saml_metadata")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetResourceResourceSqlServerResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_encryption: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 schema: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str schema: The Schema to use to direct initial requests.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSqlServerAzureAdResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_encryption: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 client_id: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 schema: Optional[str] = None,
                 secret: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str client_id: The Azure AD application (client) ID with which to authenticate.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str schema: The Schema to use to direct initial requests.
        :param str secret: The Azure AD client secret (application password) with which to authenticate.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Azure AD application (client) ID with which to authenticate.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        The Azure AD client secret (application password) with which to authenticate.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetResourceResourceSqlServerKerberosAdResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_encryption: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 keytab: Optional[str] = None,
                 krb_config: Optional[str] = None,
                 name: Optional[str] = None,
                 override_database: Optional[bool] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 realm: Optional[str] = None,
                 schema: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 server_spn: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param bool allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str keytab: The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        :param str krb_config: The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        :param str name: Unique human-readable name of the Resource.
        :param bool override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str realm: The Active Directory domain (realm) to which the configured username belongs.
        :param str schema: The Schema to use to direct initial requests.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str server_spn: The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keytab is not None:
            pulumi.set(__self__, "keytab", keytab)
        if krb_config is not None:
            pulumi.set(__self__, "krb_config", krb_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_spn is not None:
            pulumi.set(__self__, "server_spn", server_spn)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[bool]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def keytab(self) -> Optional[str]:
        """
        The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        """
        return pulumi.get(self, "keytab")

    @property
    @pulumi.getter(name="krbConfig")
    def krb_config(self) -> Optional[str]:
        """
        The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        """
        return pulumi.get(self, "krb_config")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[bool]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter
    def realm(self) -> Optional[str]:
        """
        The Active Directory domain (realm) to which the configured username belongs.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter(name="serverSpn")
    def server_spn(self) -> Optional[str]:
        """
        The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        """
        return pulumi.get(self, "server_spn")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSshResult(dict):
    def __init__(__self__, *,
                 public_key: str,
                 allow_deprecated_key_exchanges: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 key_type: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_forwarding: Optional[bool] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str public_key: The public key to append to a server's authorized keys. This will be generated after resource creation.
        :param bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str key_type: The key type to use e.g. rsa-2048 or ed25519
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param bool port_forwarding: Whether port forwarding is allowed through this server.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        pulumi.set(__self__, "public_key", public_key)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The public key to append to a server's authorized keys. This will be generated after resource creation.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[str]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSshCertResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_key_exchanges: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 identity_alias_healthcheck_username: Optional[str] = None,
                 identity_set_id: Optional[str] = None,
                 key_type: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_forwarding: Optional[bool] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param str identity_set_id: The ID of the identity set to use for identity connections.
        :param str key_type: The key type to use e.g. rsa-2048 or ed25519
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param bool port_forwarding: Whether port forwarding is allowed through this server.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[str]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[str]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSshCustomerKeyResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_key_exchanges: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_forwarding: Optional[bool] = None,
                 port_override: Optional[int] = None,
                 private_key: Optional[str] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param bool port_forwarding: Whether port forwarding is allowed through this server.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str private_key: The private key used to authenticate with the server.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSshPasswordResult(dict):
    def __init__(__self__, *,
                 allow_deprecated_key_exchanges: Optional[bool] = None,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_forwarding: Optional[bool] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param bool allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param bool port_forwarding: Whether port forwarding is allowed through this server.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[bool]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[bool]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSybaseResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceSybaseIqResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceTeradataResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceResourceTrinoResult(dict):
    def __init__(__self__, *,
                 bind_interface: Optional[str] = None,
                 database: Optional[str] = None,
                 egress_filter: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 port_override: Optional[int] = None,
                 secret_store_id: Optional[str] = None,
                 subdomain: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 username: Optional[str] = None):
        """
        :param str bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        :param str database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param str egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param str hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param str id: Unique identifier of the Resource.
        :param str name: Unique human-readable name of the Resource.
        :param str password: The password to authenticate with.
        :param int port: The port to dial to initiate a connection from the egress node to this resource.
        :param int port_override: The local port used by clients to connect to this resource.
        :param str secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param str subdomain: Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str username: The username to authenticate with.
        """
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[str]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
        """
        return pulumi.get(self, "bind_interface")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[str]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[int]:
        """
        The local port used by clients to connect to this resource.
        """
        return pulumi.get(self, "port_override")

    @property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[str]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetRoleRoleResult(dict):
    def __init__(__self__, *,
                 managed_by: str,
                 access_rules: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str managed_by: Managed By is a read only field for what service manages this role, e.g. StrongDM, Okta, Azure.
        :param str access_rules: AccessRules is a list of access rules defining the resources this Role has access to.
        :param str id: Unique identifier of the Role.
        :param str name: Unique human-readable name of the Role.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "managed_by", managed_by)
        if access_rules is not None:
            pulumi.set(__self__, "access_rules", access_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="managedBy")
    def managed_by(self) -> str:
        """
        Managed By is a read only field for what service manages this role, e.g. StrongDM, Okta, Azure.
        """
        return pulumi.get(self, "managed_by")

    @property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> Optional[str]:
        """
        AccessRules is a list of access rules defining the resources this Role has access to.
        """
        return pulumi.get(self, "access_rules")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Role.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Role.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreResult(dict):
    def __init__(__self__, *,
                 active_directory_stores: Sequence['outputs.GetSecretStoreSecretStoreActiveDirectoryStoreResult'],
                 aws: Sequence['outputs.GetSecretStoreSecretStoreAwResult'],
                 aws_cert_x509s: Sequence['outputs.GetSecretStoreSecretStoreAwsCertX509Result'],
                 azure_stores: Sequence['outputs.GetSecretStoreSecretStoreAzureStoreResult'],
                 cyberark_conjurs: Sequence['outputs.GetSecretStoreSecretStoreCyberarkConjurResult'],
                 cyberark_pam_experimentals: Sequence['outputs.GetSecretStoreSecretStoreCyberarkPamExperimentalResult'],
                 cyberark_pams: Sequence['outputs.GetSecretStoreSecretStoreCyberarkPamResult'],
                 delinea_stores: Sequence['outputs.GetSecretStoreSecretStoreDelineaStoreResult'],
                 gcp_cert_x509_stores: Sequence['outputs.GetSecretStoreSecretStoreGcpCertX509StoreResult'],
                 gcp_stores: Sequence['outputs.GetSecretStoreSecretStoreGcpStoreResult'],
                 keyfactor_ssh_stores: Sequence['outputs.GetSecretStoreSecretStoreKeyfactorSshStoreResult'],
                 keyfactor_x509_stores: Sequence['outputs.GetSecretStoreSecretStoreKeyfactorX509StoreResult'],
                 vault_approle_cert_sshes: Sequence['outputs.GetSecretStoreSecretStoreVaultApproleCertSshResult'],
                 vault_approle_cert_x509s: Sequence['outputs.GetSecretStoreSecretStoreVaultApproleCertX509Result'],
                 vault_approles: Sequence['outputs.GetSecretStoreSecretStoreVaultApproleResult'],
                 vault_aws_ec2s: Sequence['outputs.GetSecretStoreSecretStoreVaultAwsEc2Result'],
                 vault_aws_iams: Sequence['outputs.GetSecretStoreSecretStoreVaultAwsIamResult'],
                 vault_tls: Sequence['outputs.GetSecretStoreSecretStoreVaultTlResult'],
                 vault_tls_cert_sshes: Sequence['outputs.GetSecretStoreSecretStoreVaultTlsCertSshResult'],
                 vault_tls_cert_x509s: Sequence['outputs.GetSecretStoreSecretStoreVaultTlsCertX509Result'],
                 vault_token_cert_sshes: Sequence['outputs.GetSecretStoreSecretStoreVaultTokenCertSshResult'],
                 vault_token_cert_x509s: Sequence['outputs.GetSecretStoreSecretStoreVaultTokenCertX509Result'],
                 vault_tokens: Sequence['outputs.GetSecretStoreSecretStoreVaultTokenResult']):
        pulumi.set(__self__, "active_directory_stores", active_directory_stores)
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "aws_cert_x509s", aws_cert_x509s)
        pulumi.set(__self__, "azure_stores", azure_stores)
        pulumi.set(__self__, "cyberark_conjurs", cyberark_conjurs)
        pulumi.set(__self__, "cyberark_pam_experimentals", cyberark_pam_experimentals)
        pulumi.set(__self__, "cyberark_pams", cyberark_pams)
        pulumi.set(__self__, "delinea_stores", delinea_stores)
        pulumi.set(__self__, "gcp_cert_x509_stores", gcp_cert_x509_stores)
        pulumi.set(__self__, "gcp_stores", gcp_stores)
        pulumi.set(__self__, "keyfactor_ssh_stores", keyfactor_ssh_stores)
        pulumi.set(__self__, "keyfactor_x509_stores", keyfactor_x509_stores)
        pulumi.set(__self__, "vault_approle_cert_sshes", vault_approle_cert_sshes)
        pulumi.set(__self__, "vault_approle_cert_x509s", vault_approle_cert_x509s)
        pulumi.set(__self__, "vault_approles", vault_approles)
        pulumi.set(__self__, "vault_aws_ec2s", vault_aws_ec2s)
        pulumi.set(__self__, "vault_aws_iams", vault_aws_iams)
        pulumi.set(__self__, "vault_tls", vault_tls)
        pulumi.set(__self__, "vault_tls_cert_sshes", vault_tls_cert_sshes)
        pulumi.set(__self__, "vault_tls_cert_x509s", vault_tls_cert_x509s)
        pulumi.set(__self__, "vault_token_cert_sshes", vault_token_cert_sshes)
        pulumi.set(__self__, "vault_token_cert_x509s", vault_token_cert_x509s)
        pulumi.set(__self__, "vault_tokens", vault_tokens)

    @property
    @pulumi.getter(name="activeDirectoryStores")
    def active_directory_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreActiveDirectoryStoreResult']:
        return pulumi.get(self, "active_directory_stores")

    @property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetSecretStoreSecretStoreAwResult']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="awsCertX509s")
    def aws_cert_x509s(self) -> Sequence['outputs.GetSecretStoreSecretStoreAwsCertX509Result']:
        return pulumi.get(self, "aws_cert_x509s")

    @property
    @pulumi.getter(name="azureStores")
    def azure_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreAzureStoreResult']:
        return pulumi.get(self, "azure_stores")

    @property
    @pulumi.getter(name="cyberarkConjurs")
    def cyberark_conjurs(self) -> Sequence['outputs.GetSecretStoreSecretStoreCyberarkConjurResult']:
        return pulumi.get(self, "cyberark_conjurs")

    @property
    @pulumi.getter(name="cyberarkPamExperimentals")
    def cyberark_pam_experimentals(self) -> Sequence['outputs.GetSecretStoreSecretStoreCyberarkPamExperimentalResult']:
        return pulumi.get(self, "cyberark_pam_experimentals")

    @property
    @pulumi.getter(name="cyberarkPams")
    def cyberark_pams(self) -> Sequence['outputs.GetSecretStoreSecretStoreCyberarkPamResult']:
        return pulumi.get(self, "cyberark_pams")

    @property
    @pulumi.getter(name="delineaStores")
    def delinea_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreDelineaStoreResult']:
        return pulumi.get(self, "delinea_stores")

    @property
    @pulumi.getter(name="gcpCertX509Stores")
    def gcp_cert_x509_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreGcpCertX509StoreResult']:
        return pulumi.get(self, "gcp_cert_x509_stores")

    @property
    @pulumi.getter(name="gcpStores")
    def gcp_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreGcpStoreResult']:
        return pulumi.get(self, "gcp_stores")

    @property
    @pulumi.getter(name="keyfactorSshStores")
    def keyfactor_ssh_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreKeyfactorSshStoreResult']:
        return pulumi.get(self, "keyfactor_ssh_stores")

    @property
    @pulumi.getter(name="keyfactorX509Stores")
    def keyfactor_x509_stores(self) -> Sequence['outputs.GetSecretStoreSecretStoreKeyfactorX509StoreResult']:
        return pulumi.get(self, "keyfactor_x509_stores")

    @property
    @pulumi.getter(name="vaultApproleCertSshes")
    def vault_approle_cert_sshes(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultApproleCertSshResult']:
        return pulumi.get(self, "vault_approle_cert_sshes")

    @property
    @pulumi.getter(name="vaultApproleCertX509s")
    def vault_approle_cert_x509s(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultApproleCertX509Result']:
        return pulumi.get(self, "vault_approle_cert_x509s")

    @property
    @pulumi.getter(name="vaultApproles")
    def vault_approles(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultApproleResult']:
        return pulumi.get(self, "vault_approles")

    @property
    @pulumi.getter(name="vaultAwsEc2s")
    def vault_aws_ec2s(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultAwsEc2Result']:
        return pulumi.get(self, "vault_aws_ec2s")

    @property
    @pulumi.getter(name="vaultAwsIams")
    def vault_aws_iams(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultAwsIamResult']:
        return pulumi.get(self, "vault_aws_iams")

    @property
    @pulumi.getter(name="vaultTls")
    def vault_tls(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTlResult']:
        return pulumi.get(self, "vault_tls")

    @property
    @pulumi.getter(name="vaultTlsCertSshes")
    def vault_tls_cert_sshes(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTlsCertSshResult']:
        return pulumi.get(self, "vault_tls_cert_sshes")

    @property
    @pulumi.getter(name="vaultTlsCertX509s")
    def vault_tls_cert_x509s(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTlsCertX509Result']:
        return pulumi.get(self, "vault_tls_cert_x509s")

    @property
    @pulumi.getter(name="vaultTokenCertSshes")
    def vault_token_cert_sshes(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTokenCertSshResult']:
        return pulumi.get(self, "vault_token_cert_sshes")

    @property
    @pulumi.getter(name="vaultTokenCertX509s")
    def vault_token_cert_x509s(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTokenCertX509Result']:
        return pulumi.get(self, "vault_token_cert_x509s")

    @property
    @pulumi.getter(name="vaultTokens")
    def vault_tokens(self) -> Sequence['outputs.GetSecretStoreSecretStoreVaultTokenResult']:
        return pulumi.get(self, "vault_tokens")


@pulumi.output_type
class GetSecretStoreSecretStoreActiveDirectoryStoreResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 server_address: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreAwResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 region: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param str region: The AWS region to target e.g. us-east-1
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreAwsCertX509Result(dict):
    def __init__(__self__, *,
                 ca_arn: Optional[str] = None,
                 certificate_template_arn: Optional[str] = None,
                 id: Optional[str] = None,
                 issued_cert_ttl_minutes: Optional[int] = None,
                 name: Optional[str] = None,
                 region: Optional[str] = None,
                 signing_algo: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str ca_arn: The ARN of the CA in AWS Private CA
        :param str certificate_template_arn: The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        :param str id: Unique identifier of the SecretStore.
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str region: The AWS region to target e.g. us-east-1
        :param str signing_algo: The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if ca_arn is not None:
            pulumi.set(__self__, "ca_arn", ca_arn)
        if certificate_template_arn is not None:
            pulumi.set(__self__, "certificate_template_arn", certificate_template_arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if signing_algo is not None:
            pulumi.set(__self__, "signing_algo", signing_algo)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="caArn")
    def ca_arn(self) -> Optional[str]:
        """
        The ARN of the CA in AWS Private CA
        """
        return pulumi.get(self, "ca_arn")

    @property
    @pulumi.getter(name="certificateTemplateArn")
    def certificate_template_arn(self) -> Optional[str]:
        """
        The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        """
        return pulumi.get(self, "certificate_template_arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="signingAlgo")
    def signing_algo(self) -> Optional[str]:
        """
        The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        """
        return pulumi.get(self, "signing_algo")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreAzureStoreResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 vault_uri: Optional[str] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str vault_uri: The URI of the key vault to target e.g. https://myvault.vault.azure.net
               * cyberark_conjur:
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vault_uri is not None:
            pulumi.set(__self__, "vault_uri", vault_uri)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> Optional[str]:
        """
        The URI of the key vault to target e.g. https://myvault.vault.azure.net
        * cyberark_conjur:
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class GetSecretStoreSecretStoreCyberarkConjurResult(dict):
    def __init__(__self__, *,
                 app_url: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str app_url: The URL of the Cyberark instance
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if app_url is not None:
            pulumi.set(__self__, "app_url", app_url)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> Optional[str]:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreCyberarkPamResult(dict):
    def __init__(__self__, *,
                 app_url: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str app_url: The URL of the Cyberark instance
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if app_url is not None:
            pulumi.set(__self__, "app_url", app_url)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> Optional[str]:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreCyberarkPamExperimentalResult(dict):
    def __init__(__self__, *,
                 app_url: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str app_url: The URL of the Cyberark instance
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if app_url is not None:
            pulumi.set(__self__, "app_url", app_url)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> Optional[str]:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreDelineaStoreResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 server_url: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tenant_name: Optional[str] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_url: The URL of the Delinea instance
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        :param str tenant_name: The tenant name to target
               * gcp_store:
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[str]:
        """
        The URL of the Delinea instance
        """
        return pulumi.get(self, "server_url")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[str]:
        """
        The tenant name to target
        * gcp_store:
        """
        return pulumi.get(self, "tenant_name")


@pulumi.output_type
class GetSecretStoreSecretStoreGcpCertX509StoreResult(dict):
    def __init__(__self__, *,
                 ca_id: Optional[str] = None,
                 ca_pool_id: Optional[str] = None,
                 id: Optional[str] = None,
                 issued_cert_ttl_minutes: Optional[int] = None,
                 location: Optional[str] = None,
                 name: Optional[str] = None,
                 project_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str ca_id: The ID of the target CA
        :param str ca_pool_id: The ID of the target CA pool
        :param str id: Unique identifier of the SecretStore.
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str location: The Region for the CA in GCP format e.g. us-west1
        :param str name: Unique human-readable name of the SecretStore.
        :param str project_id: The GCP project ID to target.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if ca_id is not None:
            pulumi.set(__self__, "ca_id", ca_id)
        if ca_pool_id is not None:
            pulumi.set(__self__, "ca_pool_id", ca_pool_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="caId")
    def ca_id(self) -> Optional[str]:
        """
        The ID of the target CA
        """
        return pulumi.get(self, "ca_id")

    @property
    @pulumi.getter(name="caPoolId")
    def ca_pool_id(self) -> Optional[str]:
        """
        The ID of the target CA pool
        """
        return pulumi.get(self, "ca_pool_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The Region for the CA in GCP format e.g. us-west1
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreGcpStoreResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 project_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param str project_id: The GCP project ID to target.
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreKeyfactorSshStoreResult(dict):
    def __init__(__self__, *,
                 ca_file_path: Optional[str] = None,
                 certificate_file_path: Optional[str] = None,
                 default_certificate_authority_name: Optional[str] = None,
                 default_certificate_profile_name: Optional[str] = None,
                 default_end_entity_profile_name: Optional[str] = None,
                 enrollment_code_env_var: Optional[str] = None,
                 enrollment_username_env_var: Optional[str] = None,
                 id: Optional[str] = None,
                 key_file_path: Optional[str] = None,
                 name: Optional[str] = None,
                 server_address: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param str certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param str default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param str default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param str default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param str enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param str enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param str id: Unique identifier of the SecretStore.
        :param str key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if certificate_file_path is not None:
            pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        if default_certificate_authority_name is not None:
            pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        if default_certificate_profile_name is not None:
            pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        if default_end_entity_profile_name is not None:
            pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[str]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> Optional[str]:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> Optional[str]:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> Optional[str]:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> Optional[str]:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[str]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[str]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[str]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreKeyfactorX509StoreResult(dict):
    def __init__(__self__, *,
                 ca_file_path: Optional[str] = None,
                 certificate_file_path: Optional[str] = None,
                 default_certificate_authority_name: Optional[str] = None,
                 default_certificate_profile_name: Optional[str] = None,
                 default_end_entity_profile_name: Optional[str] = None,
                 enrollment_code_env_var: Optional[str] = None,
                 enrollment_username_env_var: Optional[str] = None,
                 id: Optional[str] = None,
                 key_file_path: Optional[str] = None,
                 name: Optional[str] = None,
                 server_address: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param str certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param str default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param str default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param str default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param str enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param str enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param str id: Unique identifier of the SecretStore.
        :param str key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param str name: Unique human-readable name of the SecretStore.
        :param str server_address: The URL of the Vault to target
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if certificate_file_path is not None:
            pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        if default_certificate_authority_name is not None:
            pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        if default_certificate_profile_name is not None:
            pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        if default_end_entity_profile_name is not None:
            pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[str]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> Optional[str]:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> Optional[str]:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> Optional[str]:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> Optional[str]:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[str]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[str]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[str]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultApproleResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server_address: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str server_address: The URL of the Vault to target
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultApproleCertSshResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 issued_cert_ttl_minutes: Optional[int] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server_address: Optional[str] = None,
                 signing_role: Optional[str] = None,
                 ssh_mount_point: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if ssh_mount_point is not None:
            pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> Optional[str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultApproleCertX509Result(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 issued_cert_ttl_minutes: Optional[int] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 pki_mount_point: Optional[str] = None,
                 server_address: Optional[str] = None,
                 signing_role: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if pki_mount_point is not None:
            pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> Optional[str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultAwsEc2Result(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server_address: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str server_address: The URL of the Vault to target
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultAwsIamResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server_address: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str server_address: The URL of the Vault to target
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTlResult(dict):
    def __init__(__self__, *,
                 ca_cert_path: Optional[str] = None,
                 client_cert_path: Optional[str] = None,
                 client_key_path: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server_address: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str ca_cert_path: A path to a CA file accessible by a Node
        :param str client_cert_path: A path to a client certificate file accessible by a Node
        :param str client_key_path: A path to a client key file accessible by a Node
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str server_address: The URL of the Vault to target
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if client_cert_path is not None:
            pulumi.set(__self__, "client_cert_path", client_cert_path)
        if client_key_path is not None:
            pulumi.set(__self__, "client_key_path", client_key_path)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> Optional[str]:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> Optional[str]:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTlsCertSshResult(dict):
    def __init__(__self__, *,
                 ca_cert_path: Optional[str] = None,
                 client_cert_path: Optional[str] = None,
                 client_key_path: Optional[str] = None,
                 id: Optional[str] = None,
                 issued_cert_ttl_minutes: Optional[int] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server_address: Optional[str] = None,
                 signing_role: Optional[str] = None,
                 ssh_mount_point: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str ca_cert_path: A path to a CA file accessible by a Node
        :param str client_cert_path: A path to a client certificate file accessible by a Node
        :param str client_key_path: A path to a client key file accessible by a Node
        :param str id: Unique identifier of the SecretStore.
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if client_cert_path is not None:
            pulumi.set(__self__, "client_cert_path", client_cert_path)
        if client_key_path is not None:
            pulumi.set(__self__, "client_key_path", client_key_path)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if ssh_mount_point is not None:
            pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> Optional[str]:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> Optional[str]:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> Optional[str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTlsCertX509Result(dict):
    def __init__(__self__, *,
                 ca_cert_path: Optional[str] = None,
                 client_cert_path: Optional[str] = None,
                 client_key_path: Optional[str] = None,
                 id: Optional[str] = None,
                 issued_cert_ttl_minutes: Optional[int] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 pki_mount_point: Optional[str] = None,
                 server_address: Optional[str] = None,
                 signing_role: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str ca_cert_path: A path to a CA file accessible by a Node
        :param str client_cert_path: A path to a client certificate file accessible by a Node
        :param str client_key_path: A path to a client key file accessible by a Node
        :param str id: Unique identifier of the SecretStore.
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if client_cert_path is not None:
            pulumi.set(__self__, "client_cert_path", client_cert_path)
        if client_key_path is not None:
            pulumi.set(__self__, "client_key_path", client_key_path)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if pki_mount_point is not None:
            pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[str]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> Optional[str]:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> Optional[str]:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> Optional[str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTokenResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server_address: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str server_address: The URL of the Vault to target
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTokenCertSshResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 issued_cert_ttl_minutes: Optional[int] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server_address: Optional[str] = None,
                 signing_role: Optional[str] = None,
                 ssh_mount_point: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param str ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if ssh_mount_point is not None:
            pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> Optional[str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecretStoreSecretStoreVaultTokenCertX509Result(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 issued_cert_ttl_minutes: Optional[int] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 pki_mount_point: Optional[str] = None,
                 server_address: Optional[str] = None,
                 signing_role: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: Unique identifier of the SecretStore.
        :param int issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param str name: Unique human-readable name of the SecretStore.
        :param str namespace: The namespace to make requests within
        :param str pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param str server_address: The URL of the Vault to target
        :param str signing_role: The signing role to be used for signing certificates
        :param Mapping[str, str] tags: Tags is a map of key, value pairs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issued_cert_ttl_minutes is not None:
            pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if pki_mount_point is not None:
            pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if signing_role is not None:
            pulumi.set(__self__, "signing_role", signing_role)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the SecretStore.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> Optional[int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> Optional[str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> Optional[str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetWorkflowApproverWorkflowApproverResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 id: Optional[str] = None,
                 role_id: Optional[str] = None,
                 workflow_id: Optional[str] = None):
        """
        :param str account_id: The approver account id.
        :param str id: Unique identifier of the WorkflowApprover.
        :param str role_id: The approver role id
        :param str workflow_id: The workflow id.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if workflow_id is not None:
            pulumi.set(__self__, "workflow_id", workflow_id)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The approver account id.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the WorkflowApprover.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[str]:
        """
        The approver role id
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> Optional[str]:
        """
        The workflow id.
        """
        return pulumi.get(self, "workflow_id")


@pulumi.output_type
class GetWorkflowRoleWorkflowRoleResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 role_id: Optional[str] = None,
                 workflow_id: Optional[str] = None):
        """
        :param str id: Unique identifier of the WorkflowRole.
        :param str role_id: The role id.
        :param str workflow_id: The workflow id.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if workflow_id is not None:
            pulumi.set(__self__, "workflow_id", workflow_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the WorkflowRole.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[str]:
        """
        The role id.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> Optional[str]:
        """
        The workflow id.
        """
        return pulumi.get(self, "workflow_id")


@pulumi.output_type
class GetWorkflowWorkflowResult(dict):
    def __init__(__self__, *,
                 access_rules: Optional[str] = None,
                 approval_flow_id: Optional[str] = None,
                 auto_grant: Optional[bool] = None,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str access_rules: AccessRules is a list of access rules defining the resources this Workflow provides access to.
        :param str approval_flow_id: Optional approval flow ID identifies an approval flow that linked to the workflow
        :param bool auto_grant: Optional auto grant setting to automatically approve requests or not, defaults to false.
        :param str description: Optional description of the Workflow.
        :param bool enabled: Optional enabled state for workflow. This setting may be overridden by the system if the workflow doesn't meet the requirements to be enabled or if other conditions prevent enabling the workflow. The requirements to enable a workflow are that the workflow must be either set up for with auto grant enabled or have one or more WorkflowApprovers created for the workflow.
        :param str id: Unique identifier of the Workflow.
        :param str name: Unique human-readable name of the Workflow.
        :param int weight: Optional weight for workflow to specify it's priority in matching a request.
        """
        if access_rules is not None:
            pulumi.set(__self__, "access_rules", access_rules)
        if approval_flow_id is not None:
            pulumi.set(__self__, "approval_flow_id", approval_flow_id)
        if auto_grant is not None:
            pulumi.set(__self__, "auto_grant", auto_grant)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> Optional[str]:
        """
        AccessRules is a list of access rules defining the resources this Workflow provides access to.
        """
        return pulumi.get(self, "access_rules")

    @property
    @pulumi.getter(name="approvalFlowId")
    def approval_flow_id(self) -> Optional[str]:
        """
        Optional approval flow ID identifies an approval flow that linked to the workflow
        """
        return pulumi.get(self, "approval_flow_id")

    @property
    @pulumi.getter(name="autoGrant")
    def auto_grant(self) -> Optional[bool]:
        """
        Optional auto grant setting to automatically approve requests or not, defaults to false.
        """
        return pulumi.get(self, "auto_grant")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Optional description of the Workflow.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Optional enabled state for workflow. This setting may be overridden by the system if the workflow doesn't meet the requirements to be enabled or if other conditions prevent enabling the workflow. The requirements to enable a workflow are that the workflow must be either set up for with auto grant enabled or have one or more WorkflowApprovers created for the workflow.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the Workflow.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique human-readable name of the Workflow.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Optional weight for workflow to specify it's priority in matching a request.
        """
        return pulumi.get(self, "weight")


