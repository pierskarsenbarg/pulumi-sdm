# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccountServiceArgs',
    'AccountServiceArgsDict',
    'AccountUserArgs',
    'AccountUserArgsDict',
    'ApprovalWorkflowApprovalStepArgs',
    'ApprovalWorkflowApprovalStepArgsDict',
    'ApprovalWorkflowApprovalStepApproverArgs',
    'ApprovalWorkflowApprovalStepApproverArgsDict',
    'ConnectorAwsArgs',
    'ConnectorAwsArgsDict',
    'ConnectorAwsExcludeTagArgs',
    'ConnectorAwsExcludeTagArgsDict',
    'ConnectorAwsIncludeTagArgs',
    'ConnectorAwsIncludeTagArgsDict',
    'ConnectorAzureArgs',
    'ConnectorAzureArgsDict',
    'ConnectorAzureExcludeTagArgs',
    'ConnectorAzureExcludeTagArgsDict',
    'ConnectorAzureIncludeTagArgs',
    'ConnectorAzureIncludeTagArgsDict',
    'ConnectorGcpArgs',
    'ConnectorGcpArgsDict',
    'ConnectorGcpExcludeTagArgs',
    'ConnectorGcpExcludeTagArgsDict',
    'ConnectorGcpIncludeTagArgs',
    'ConnectorGcpIncludeTagArgsDict',
    'NodeGatewayArgs',
    'NodeGatewayArgsDict',
    'NodeGatewayMaintenanceWindowArgs',
    'NodeGatewayMaintenanceWindowArgsDict',
    'NodeProxyClusterArgs',
    'NodeProxyClusterArgsDict',
    'NodeProxyClusterMaintenanceWindowArgs',
    'NodeProxyClusterMaintenanceWindowArgsDict',
    'NodeRelayArgs',
    'NodeRelayArgsDict',
    'NodeRelayMaintenanceWindowArgs',
    'NodeRelayMaintenanceWindowArgsDict',
    'ResourceAerospikeArgs',
    'ResourceAerospikeArgsDict',
    'ResourceAksArgs',
    'ResourceAksArgsDict',
    'ResourceAksBasicAuthArgs',
    'ResourceAksBasicAuthArgsDict',
    'ResourceAksServiceAccountArgs',
    'ResourceAksServiceAccountArgsDict',
    'ResourceAksServiceAccountUserImpersonationArgs',
    'ResourceAksServiceAccountUserImpersonationArgsDict',
    'ResourceAksUserImpersonationArgs',
    'ResourceAksUserImpersonationArgsDict',
    'ResourceAmazonEksArgs',
    'ResourceAmazonEksArgsDict',
    'ResourceAmazonEksInstanceProfileArgs',
    'ResourceAmazonEksInstanceProfileArgsDict',
    'ResourceAmazonEksInstanceProfileUserImpersonationArgs',
    'ResourceAmazonEksInstanceProfileUserImpersonationArgsDict',
    'ResourceAmazonEksUserImpersonationArgs',
    'ResourceAmazonEksUserImpersonationArgsDict',
    'ResourceAmazonEsArgs',
    'ResourceAmazonEsArgsDict',
    'ResourceAmazonEsiamArgs',
    'ResourceAmazonEsiamArgsDict',
    'ResourceAmazonmqAmqp091Args',
    'ResourceAmazonmqAmqp091ArgsDict',
    'ResourceAmazonmqAmqpArgs',
    'ResourceAmazonmqAmqpArgsDict',
    'ResourceAthenaArgs',
    'ResourceAthenaArgsDict',
    'ResourceAthenaIamArgs',
    'ResourceAthenaIamArgsDict',
    'ResourceAuroraMysqlArgs',
    'ResourceAuroraMysqlArgsDict',
    'ResourceAuroraMysqlIamArgs',
    'ResourceAuroraMysqlIamArgsDict',
    'ResourceAuroraPostgresArgs',
    'ResourceAuroraPostgresArgsDict',
    'ResourceAuroraPostgresIamArgs',
    'ResourceAuroraPostgresIamArgsDict',
    'ResourceAwsArgs',
    'ResourceAwsArgsDict',
    'ResourceAwsConsoleArgs',
    'ResourceAwsConsoleArgsDict',
    'ResourceAwsConsoleStaticKeyPairArgs',
    'ResourceAwsConsoleStaticKeyPairArgsDict',
    'ResourceAwsInstanceProfileArgs',
    'ResourceAwsInstanceProfileArgsDict',
    'ResourceAzureArgs',
    'ResourceAzureArgsDict',
    'ResourceAzureCertificateArgs',
    'ResourceAzureCertificateArgsDict',
    'ResourceAzureMysqlArgs',
    'ResourceAzureMysqlArgsDict',
    'ResourceAzureMysqlManagedIdentityArgs',
    'ResourceAzureMysqlManagedIdentityArgsDict',
    'ResourceAzurePostgresArgs',
    'ResourceAzurePostgresArgsDict',
    'ResourceAzurePostgresManagedIdentityArgs',
    'ResourceAzurePostgresManagedIdentityArgsDict',
    'ResourceBigQueryArgs',
    'ResourceBigQueryArgsDict',
    'ResourceCassandraArgs',
    'ResourceCassandraArgsDict',
    'ResourceCitusArgs',
    'ResourceCitusArgsDict',
    'ResourceClickHouseHttpArgs',
    'ResourceClickHouseHttpArgsDict',
    'ResourceClickHouseMySqlArgs',
    'ResourceClickHouseMySqlArgsDict',
    'ResourceClickHouseTcpArgs',
    'ResourceClickHouseTcpArgsDict',
    'ResourceClustrixArgs',
    'ResourceClustrixArgsDict',
    'ResourceCockroachArgs',
    'ResourceCockroachArgsDict',
    'ResourceCouchbaseDatabaseArgs',
    'ResourceCouchbaseDatabaseArgsDict',
    'ResourceCouchbaseWebUiArgs',
    'ResourceCouchbaseWebUiArgsDict',
    'ResourceDb2IArgs',
    'ResourceDb2IArgsDict',
    'ResourceDb2LuwArgs',
    'ResourceDb2LuwArgsDict',
    'ResourceDocumentDbHostArgs',
    'ResourceDocumentDbHostArgsDict',
    'ResourceDocumentDbHostIamArgs',
    'ResourceDocumentDbHostIamArgsDict',
    'ResourceDocumentDbReplicaSetArgs',
    'ResourceDocumentDbReplicaSetArgsDict',
    'ResourceDocumentDbReplicaSetIamArgs',
    'ResourceDocumentDbReplicaSetIamArgsDict',
    'ResourceDruidArgs',
    'ResourceDruidArgsDict',
    'ResourceDynamoDbArgs',
    'ResourceDynamoDbArgsDict',
    'ResourceDynamoDbiamArgs',
    'ResourceDynamoDbiamArgsDict',
    'ResourceElasticArgs',
    'ResourceElasticArgsDict',
    'ResourceElasticacheRedisArgs',
    'ResourceElasticacheRedisArgsDict',
    'ResourceElasticacheRedisIamArgs',
    'ResourceElasticacheRedisIamArgsDict',
    'ResourceEntraIdArgs',
    'ResourceEntraIdArgsDict',
    'ResourceGcpArgs',
    'ResourceGcpArgsDict',
    'ResourceGcpConsoleArgs',
    'ResourceGcpConsoleArgsDict',
    'ResourceGcpwifArgs',
    'ResourceGcpwifArgsDict',
    'ResourceGoogleGkeArgs',
    'ResourceGoogleGkeArgsDict',
    'ResourceGoogleGkeUserImpersonationArgs',
    'ResourceGoogleGkeUserImpersonationArgsDict',
    'ResourceGoogleSpannerArgs',
    'ResourceGoogleSpannerArgsDict',
    'ResourceGreenplumArgs',
    'ResourceGreenplumArgsDict',
    'ResourceHttpAuthArgs',
    'ResourceHttpAuthArgsDict',
    'ResourceHttpBasicAuthArgs',
    'ResourceHttpBasicAuthArgsDict',
    'ResourceHttpNoAuthArgs',
    'ResourceHttpNoAuthArgsDict',
    'ResourceKubernetesArgs',
    'ResourceKubernetesArgsDict',
    'ResourceKubernetesBasicAuthArgs',
    'ResourceKubernetesBasicAuthArgsDict',
    'ResourceKubernetesPodIdentityArgs',
    'ResourceKubernetesPodIdentityArgsDict',
    'ResourceKubernetesServiceAccountArgs',
    'ResourceKubernetesServiceAccountArgsDict',
    'ResourceKubernetesServiceAccountUserImpersonationArgs',
    'ResourceKubernetesServiceAccountUserImpersonationArgsDict',
    'ResourceKubernetesUserImpersonationArgs',
    'ResourceKubernetesUserImpersonationArgsDict',
    'ResourceMariaArgs',
    'ResourceMariaArgsDict',
    'ResourceMcpArgs',
    'ResourceMcpArgsDict',
    'ResourceMemcachedArgs',
    'ResourceMemcachedArgsDict',
    'ResourceMemsqlArgs',
    'ResourceMemsqlArgsDict',
    'ResourceMongoHostArgs',
    'ResourceMongoHostArgsDict',
    'ResourceMongoLegacyHostArgs',
    'ResourceMongoLegacyHostArgsDict',
    'ResourceMongoLegacyReplicasetArgs',
    'ResourceMongoLegacyReplicasetArgsDict',
    'ResourceMongoReplicaSetArgs',
    'ResourceMongoReplicaSetArgsDict',
    'ResourceMongoShardedClusterArgs',
    'ResourceMongoShardedClusterArgsDict',
    'ResourceMtlsMysqlArgs',
    'ResourceMtlsMysqlArgsDict',
    'ResourceMtlsPostgresArgs',
    'ResourceMtlsPostgresArgsDict',
    'ResourceMysqlArgs',
    'ResourceMysqlArgsDict',
    'ResourceNeptuneArgs',
    'ResourceNeptuneArgsDict',
    'ResourceNeptuneIamArgs',
    'ResourceNeptuneIamArgsDict',
    'ResourceOktaGroupsArgs',
    'ResourceOktaGroupsArgsDict',
    'ResourceOracleArgs',
    'ResourceOracleArgsDict',
    'ResourceOracleNneArgs',
    'ResourceOracleNneArgsDict',
    'ResourcePostgresArgs',
    'ResourcePostgresArgsDict',
    'ResourcePrestoArgs',
    'ResourcePrestoArgsDict',
    'ResourceRabbitmqAmqp091Args',
    'ResourceRabbitmqAmqp091ArgsDict',
    'ResourceRawTcpArgs',
    'ResourceRawTcpArgsDict',
    'ResourceRdpArgs',
    'ResourceRdpArgsDict',
    'ResourceRdpCertArgs',
    'ResourceRdpCertArgsDict',
    'ResourceRdsPostgresIamArgs',
    'ResourceRdsPostgresIamArgsDict',
    'ResourceRedisArgs',
    'ResourceRedisArgsDict',
    'ResourceRedisClusterArgs',
    'ResourceRedisClusterArgsDict',
    'ResourceRedshiftArgs',
    'ResourceRedshiftArgsDict',
    'ResourceRedshiftIamArgs',
    'ResourceRedshiftIamArgsDict',
    'ResourceRedshiftServerlessIamArgs',
    'ResourceRedshiftServerlessIamArgsDict',
    'ResourceSingleStoreArgs',
    'ResourceSingleStoreArgsDict',
    'ResourceSnowflakeArgs',
    'ResourceSnowflakeArgsDict',
    'ResourceSnowsightArgs',
    'ResourceSnowsightArgsDict',
    'ResourceSqlServerArgs',
    'ResourceSqlServerArgsDict',
    'ResourceSqlServerAzureAdArgs',
    'ResourceSqlServerAzureAdArgsDict',
    'ResourceSqlServerKerberosAdArgs',
    'ResourceSqlServerKerberosAdArgsDict',
    'ResourceSshArgs',
    'ResourceSshArgsDict',
    'ResourceSshCertArgs',
    'ResourceSshCertArgsDict',
    'ResourceSshCustomerKeyArgs',
    'ResourceSshCustomerKeyArgsDict',
    'ResourceSshPasswordArgs',
    'ResourceSshPasswordArgsDict',
    'ResourceSybaseArgs',
    'ResourceSybaseArgsDict',
    'ResourceSybaseIqArgs',
    'ResourceSybaseIqArgsDict',
    'ResourceTeradataArgs',
    'ResourceTeradataArgsDict',
    'ResourceTrinoArgs',
    'ResourceTrinoArgsDict',
    'ResourceVerticaArgs',
    'ResourceVerticaArgsDict',
    'SecretEngineActiveDirectoryArgs',
    'SecretEngineActiveDirectoryArgsDict',
    'SecretEngineKeyValueArgs',
    'SecretEngineKeyValueArgsDict',
    'SecretEngineMysqlSecretEngineArgs',
    'SecretEngineMysqlSecretEngineArgsDict',
    'SecretEnginePostgresSecretEngineArgs',
    'SecretEnginePostgresSecretEngineArgsDict',
    'SecretEngineSqlserverSecretEngineArgs',
    'SecretEngineSqlserverSecretEngineArgsDict',
    'SecretStoreActiveDirectoryStoreArgs',
    'SecretStoreActiveDirectoryStoreArgsDict',
    'SecretStoreAwsArgs',
    'SecretStoreAwsArgsDict',
    'SecretStoreAwsCertX509Args',
    'SecretStoreAwsCertX509ArgsDict',
    'SecretStoreAzureStoreArgs',
    'SecretStoreAzureStoreArgsDict',
    'SecretStoreCyberarkConjurArgs',
    'SecretStoreCyberarkConjurArgsDict',
    'SecretStoreCyberarkPamArgs',
    'SecretStoreCyberarkPamArgsDict',
    'SecretStoreCyberarkPamExperimentalArgs',
    'SecretStoreCyberarkPamExperimentalArgsDict',
    'SecretStoreDelineaStoreArgs',
    'SecretStoreDelineaStoreArgsDict',
    'SecretStoreGcpCertX509StoreArgs',
    'SecretStoreGcpCertX509StoreArgsDict',
    'SecretStoreGcpStoreArgs',
    'SecretStoreGcpStoreArgsDict',
    'SecretStoreKeyfactorSshStoreArgs',
    'SecretStoreKeyfactorSshStoreArgsDict',
    'SecretStoreKeyfactorX509StoreArgs',
    'SecretStoreKeyfactorX509StoreArgsDict',
    'SecretStoreStrongVaultArgs',
    'SecretStoreStrongVaultArgsDict',
    'SecretStoreVaultApproleArgs',
    'SecretStoreVaultApproleArgsDict',
    'SecretStoreVaultApproleCertSshArgs',
    'SecretStoreVaultApproleCertSshArgsDict',
    'SecretStoreVaultApproleCertX509Args',
    'SecretStoreVaultApproleCertX509ArgsDict',
    'SecretStoreVaultAwsEc2Args',
    'SecretStoreVaultAwsEc2ArgsDict',
    'SecretStoreVaultAwsEc2CertSshArgs',
    'SecretStoreVaultAwsEc2CertSshArgsDict',
    'SecretStoreVaultAwsEc2CertX509Args',
    'SecretStoreVaultAwsEc2CertX509ArgsDict',
    'SecretStoreVaultAwsIamArgs',
    'SecretStoreVaultAwsIamArgsDict',
    'SecretStoreVaultAwsIamCertSshArgs',
    'SecretStoreVaultAwsIamCertSshArgsDict',
    'SecretStoreVaultAwsIamCertX509Args',
    'SecretStoreVaultAwsIamCertX509ArgsDict',
    'SecretStoreVaultTlsArgs',
    'SecretStoreVaultTlsArgsDict',
    'SecretStoreVaultTlsCertSshArgs',
    'SecretStoreVaultTlsCertSshArgsDict',
    'SecretStoreVaultTlsCertX509Args',
    'SecretStoreVaultTlsCertX509ArgsDict',
    'SecretStoreVaultTokenArgs',
    'SecretStoreVaultTokenArgsDict',
    'SecretStoreVaultTokenCertSshArgs',
    'SecretStoreVaultTokenCertSshArgsDict',
    'SecretStoreVaultTokenCertX509Args',
    'SecretStoreVaultTokenCertX509ArgsDict',
    'GetApprovalWorkflowApprovalStepArgs',
    'GetApprovalWorkflowApprovalStepArgsDict',
    'GetApprovalWorkflowApprovalStepApproverArgs',
    'GetApprovalWorkflowApprovalStepApproverArgsDict',
]

MYPY = False

if not MYPY:
    class AccountServiceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Service.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        CreatedAt is the timestamp when the user was created
        """
        suspended: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The Service's suspended state.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AccountServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 suspended: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Service.
        :param pulumi.Input[_builtins.str] created_at: CreatedAt is the timestamp when the user was created
        :param pulumi.Input[_builtins.bool] suspended: The Service's suspended state.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CreatedAt is the timestamp when the user was created
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def suspended(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The Service's suspended state.
        """
        return pulumi.get(self, "suspended")

    @suspended.setter
    def suspended(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "suspended", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AccountUserArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The User's email address. Must be unique.
        """
        first_name: pulumi.Input[_builtins.str]
        """
        The User's first name.
        """
        last_name: pulumi.Input[_builtins.str]
        """
        The User's last name.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        CreatedAt is the timestamp when the user was created
        """
        employee_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Internal employee ID used to identify the user.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        External ID is an alternative unique ID this user is represented by within an external service.
        """
        managed_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        """
        manager_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Manager ID is the ID of the user's manager. This field is empty when the user has no manager.
        """
        permission_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        PermissionLevel is the user's permission level e.g. admin, DBA, user.
        """
        resolved_manager_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolved Manager ID is the ID of the user's manager derived from the manager_id, if present, or from the SCIM metadata. This is a read-only field that's only populated for get and list.
        """
        scim: NotRequired[pulumi.Input[_builtins.str]]
        """
        SCIM contains the raw SCIM metadata for the user. This is a read-only field.
        """
        suspended: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The Service's suspended state.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    AccountUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountUserArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 first_name: pulumi.Input[_builtins.str],
                 last_name: pulumi.Input[_builtins.str],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 employee_number: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 managed_by: Optional[pulumi.Input[_builtins.str]] = None,
                 manager_id: Optional[pulumi.Input[_builtins.str]] = None,
                 permission_level: Optional[pulumi.Input[_builtins.str]] = None,
                 resolved_manager_id: Optional[pulumi.Input[_builtins.str]] = None,
                 scim: Optional[pulumi.Input[_builtins.str]] = None,
                 suspended: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] email: The User's email address. Must be unique.
        :param pulumi.Input[_builtins.str] first_name: The User's first name.
        :param pulumi.Input[_builtins.str] last_name: The User's last name.
        :param pulumi.Input[_builtins.str] created_at: CreatedAt is the timestamp when the user was created
        :param pulumi.Input[_builtins.str] employee_number: Internal employee ID used to identify the user.
        :param pulumi.Input[_builtins.str] external_id: External ID is an alternative unique ID this user is represented by within an external service.
        :param pulumi.Input[_builtins.str] managed_by: Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        :param pulumi.Input[_builtins.str] manager_id: Manager ID is the ID of the user's manager. This field is empty when the user has no manager.
        :param pulumi.Input[_builtins.str] permission_level: PermissionLevel is the user's permission level e.g. admin, DBA, user.
        :param pulumi.Input[_builtins.str] resolved_manager_id: Resolved Manager ID is the ID of the user's manager derived from the manager_id, if present, or from the SCIM metadata. This is a read-only field that's only populated for get and list.
        :param pulumi.Input[_builtins.str] scim: SCIM contains the raw SCIM metadata for the user. This is a read-only field.
        :param pulumi.Input[_builtins.bool] suspended: The Service's suspended state.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if employee_number is not None:
            pulumi.set(__self__, "employee_number", employee_number)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if managed_by is not None:
            pulumi.set(__self__, "managed_by", managed_by)
        if manager_id is not None:
            pulumi.set(__self__, "manager_id", manager_id)
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if resolved_manager_id is not None:
            pulumi.set(__self__, "resolved_manager_id", resolved_manager_id)
        if scim is not None:
            pulumi.set(__self__, "scim", scim)
        if suspended is not None:
            pulumi.set(__self__, "suspended", suspended)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The User's email address. Must be unique.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> pulumi.Input[_builtins.str]:
        """
        The User's first name.
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> pulumi.Input[_builtins.str]:
        """
        The User's last name.
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CreatedAt is the timestamp when the user was created
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="employeeNumber")
    def employee_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Internal employee ID used to identify the user.
        """
        return pulumi.get(self, "employee_number")

    @employee_number.setter
    def employee_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "employee_number", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        External ID is an alternative unique ID this user is represented by within an external service.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="managedBy")
    def managed_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
        """
        return pulumi.get(self, "managed_by")

    @managed_by.setter
    def managed_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_by", value)

    @_builtins.property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Manager ID is the ID of the user's manager. This field is empty when the user has no manager.
        """
        return pulumi.get(self, "manager_id")

    @manager_id.setter
    def manager_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "manager_id", value)

    @_builtins.property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        PermissionLevel is the user's permission level e.g. admin, DBA, user.
        """
        return pulumi.get(self, "permission_level")

    @permission_level.setter
    def permission_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission_level", value)

    @_builtins.property
    @pulumi.getter(name="resolvedManagerId")
    def resolved_manager_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolved Manager ID is the ID of the user's manager derived from the manager_id, if present, or from the SCIM metadata. This is a read-only field that's only populated for get and list.
        """
        return pulumi.get(self, "resolved_manager_id")

    @resolved_manager_id.setter
    def resolved_manager_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolved_manager_id", value)

    @_builtins.property
    @pulumi.getter
    def scim(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SCIM contains the raw SCIM metadata for the user. This is a read-only field.
        """
        return pulumi.get(self, "scim")

    @scim.setter
    def scim(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scim", value)

    @_builtins.property
    @pulumi.getter
    def suspended(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The Service's suspended state.
        """
        return pulumi.get(self, "suspended")

    @suspended.setter
    def suspended(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "suspended", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ApprovalWorkflowApprovalStepArgsDict(TypedDict):
        approvers: pulumi.Input[Sequence[pulumi.Input['ApprovalWorkflowApprovalStepApproverArgsDict']]]
        """
        The approvers for this approval step
        """
        quantifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        """
        skip_after: NotRequired[pulumi.Input[_builtins.str]]
        """
        Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
elif False:
    ApprovalWorkflowApprovalStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApprovalWorkflowApprovalStepArgs:
    def __init__(__self__, *,
                 approvers: pulumi.Input[Sequence[pulumi.Input['ApprovalWorkflowApprovalStepApproverArgs']]],
                 quantifier: Optional[pulumi.Input[_builtins.str]] = None,
                 skip_after: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApprovalWorkflowApprovalStepApproverArgs']]] approvers: The approvers for this approval step
        :param pulumi.Input[_builtins.str] quantifier: Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        :param pulumi.Input[_builtins.str] skip_after: Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        pulumi.set(__self__, "approvers", approvers)
        if quantifier is not None:
            pulumi.set(__self__, "quantifier", quantifier)
        if skip_after is not None:
            pulumi.set(__self__, "skip_after", skip_after)

    @_builtins.property
    @pulumi.getter
    def approvers(self) -> pulumi.Input[Sequence[pulumi.Input['ApprovalWorkflowApprovalStepApproverArgs']]]:
        """
        The approvers for this approval step
        """
        return pulumi.get(self, "approvers")

    @approvers.setter
    def approvers(self, value: pulumi.Input[Sequence[pulumi.Input['ApprovalWorkflowApprovalStepApproverArgs']]]):
        pulumi.set(self, "approvers", value)

    @_builtins.property
    @pulumi.getter
    def quantifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        """
        return pulumi.get(self, "quantifier")

    @quantifier.setter
    def quantifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quantifier", value)

    @_builtins.property
    @pulumi.getter(name="skipAfter")
    def skip_after(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        return pulumi.get(self, "skip_after")

    @skip_after.setter
    def skip_after(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "skip_after", value)


if not MYPY:
    class ApprovalWorkflowApprovalStepApproverArgsDict(TypedDict):
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The group id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        reference: NotRequired[pulumi.Input[_builtins.str]]
        """
        A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        role_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
elif False:
    ApprovalWorkflowApprovalStepApproverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApprovalWorkflowApprovalStepApproverArgs:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 reference: Optional[pulumi.Input[_builtins.str]] = None,
                 role_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_id: The account id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        :param pulumi.Input[_builtins.str] group_id: The group id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        :param pulumi.Input[_builtins.str] reference: A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, group id, or reference may be present for one approver)
        :param pulumi.Input[_builtins.str] role_id: The role id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The group id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter
    def reference(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        return pulumi.get(self, "reference")

    @reference.setter
    def reference(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reference", value)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_id", value)


if not MYPY:
    class ConnectorAwsArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Connector.
        """
        account_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        AccountIds is the list of AWS Accounts to scan
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Connector.
        """
        exclude_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectorAwsExcludeTagArgsDict']]]]
        """
        ExcludeTags filters out discovered resources that have the tag and value. We do allow duplicate tag names for ExcludeTags to support multiple excluded values for the tag.
        """
        include_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectorAwsIncludeTagArgsDict']]]]
        """
        IncludeTags only discovers cloud resources that have one of the included tags. We do not allow duplicate tag names for IncludeTags
        """
        role_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        RoleName is the Role we're assuming into for an account
        """
        scan_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        ScanPeriod identifies which remote system this Connector discovers
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Services is a list of services this connector should scan.
        """
elif False:
    ConnectorAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAwsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_tags: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAwsExcludeTagArgs']]]] = None,
                 include_tags: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAwsIncludeTagArgs']]]] = None,
                 role_name: Optional[pulumi.Input[_builtins.str]] = None,
                 scan_period: Optional[pulumi.Input[_builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Connector.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] account_ids: AccountIds is the list of AWS Accounts to scan
        :param pulumi.Input[_builtins.str] description: Description of the Connector.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorAwsExcludeTagArgs']]] exclude_tags: ExcludeTags filters out discovered resources that have the tag and value. We do allow duplicate tag names for ExcludeTags to support multiple excluded values for the tag.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorAwsIncludeTagArgs']]] include_tags: IncludeTags only discovers cloud resources that have one of the included tags. We do not allow duplicate tag names for IncludeTags
        :param pulumi.Input[_builtins.str] role_name: RoleName is the Role we're assuming into for an account
        :param pulumi.Input[_builtins.str] scan_period: ScanPeriod identifies which remote system this Connector discovers
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] services: Services is a list of services this connector should scan.
        """
        pulumi.set(__self__, "name", name)
        if account_ids is not None:
            pulumi.set(__self__, "account_ids", account_ids)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_tags is not None:
            pulumi.set(__self__, "exclude_tags", exclude_tags)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)
        if scan_period is not None:
            pulumi.set(__self__, "scan_period", scan_period)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        AccountIds is the list of AWS Accounts to scan
        """
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "account_ids", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Connector.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="excludeTags")
    def exclude_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAwsExcludeTagArgs']]]]:
        """
        ExcludeTags filters out discovered resources that have the tag and value. We do allow duplicate tag names for ExcludeTags to support multiple excluded values for the tag.
        """
        return pulumi.get(self, "exclude_tags")

    @exclude_tags.setter
    def exclude_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAwsExcludeTagArgs']]]]):
        pulumi.set(self, "exclude_tags", value)

    @_builtins.property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAwsIncludeTagArgs']]]]:
        """
        IncludeTags only discovers cloud resources that have one of the included tags. We do not allow duplicate tag names for IncludeTags
        """
        return pulumi.get(self, "include_tags")

    @include_tags.setter
    def include_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAwsIncludeTagArgs']]]]):
        pulumi.set(self, "include_tags", value)

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RoleName is the Role we're assuming into for an account
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_name", value)

    @_builtins.property
    @pulumi.getter(name="scanPeriod")
    def scan_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ScanPeriod identifies which remote system this Connector discovers
        """
        return pulumi.get(self, "scan_period")

    @scan_period.setter
    def scan_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scan_period", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Services is a list of services this connector should scan.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class ConnectorAwsExcludeTagArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique human-readable name of the Connector.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of this tag.
        """
elif False:
    ConnectorAwsExcludeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAwsExcludeTagArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Connector.
        :param pulumi.Input[_builtins.str] value: The value of this tag.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique human-readable name of the Connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of this tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectorAwsIncludeTagArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique human-readable name of the Connector.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of this tag.
        """
elif False:
    ConnectorAwsIncludeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAwsIncludeTagArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Connector.
        :param pulumi.Input[_builtins.str] value: The value of this tag.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique human-readable name of the Connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of this tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectorAzureArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Connector.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ClientId is the ID of the Application / Service Account we're acting as
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Connector.
        """
        exclude_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectorAzureExcludeTagArgsDict']]]]
        """
        ExcludeTags filters out discovered resources that have the tag and value. We do allow duplicate tag names for ExcludeTags to support multiple excluded values for the tag.
        """
        include_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectorAzureIncludeTagArgsDict']]]]
        """
        IncludeTags only discovers cloud resources that have one of the included tags. We do not allow duplicate tag names for IncludeTags
        """
        scan_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        ScanPeriod identifies which remote system this Connector discovers
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Services is a list of services this connector should scan.
        """
        subscription_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        SubscriptionIds are the targets of discovery.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        TenantId is the Azure Tenant we're discovering in
        * gcp:
        """
elif False:
    ConnectorAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAzureArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_tags: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAzureExcludeTagArgs']]]] = None,
                 include_tags: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAzureIncludeTagArgs']]]] = None,
                 scan_period: Optional[pulumi.Input[_builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subscription_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Connector.
        :param pulumi.Input[_builtins.str] client_id: ClientId is the ID of the Application / Service Account we're acting as
        :param pulumi.Input[_builtins.str] description: Description of the Connector.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorAzureExcludeTagArgs']]] exclude_tags: ExcludeTags filters out discovered resources that have the tag and value. We do allow duplicate tag names for ExcludeTags to support multiple excluded values for the tag.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorAzureIncludeTagArgs']]] include_tags: IncludeTags only discovers cloud resources that have one of the included tags. We do not allow duplicate tag names for IncludeTags
        :param pulumi.Input[_builtins.str] scan_period: ScanPeriod identifies which remote system this Connector discovers
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] services: Services is a list of services this connector should scan.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subscription_ids: SubscriptionIds are the targets of discovery.
        :param pulumi.Input[_builtins.str] tenant_id: TenantId is the Azure Tenant we're discovering in
               * gcp:
        """
        pulumi.set(__self__, "name", name)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_tags is not None:
            pulumi.set(__self__, "exclude_tags", exclude_tags)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if scan_period is not None:
            pulumi.set(__self__, "scan_period", scan_period)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if subscription_ids is not None:
            pulumi.set(__self__, "subscription_ids", subscription_ids)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ClientId is the ID of the Application / Service Account we're acting as
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Connector.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="excludeTags")
    def exclude_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAzureExcludeTagArgs']]]]:
        """
        ExcludeTags filters out discovered resources that have the tag and value. We do allow duplicate tag names for ExcludeTags to support multiple excluded values for the tag.
        """
        return pulumi.get(self, "exclude_tags")

    @exclude_tags.setter
    def exclude_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAzureExcludeTagArgs']]]]):
        pulumi.set(self, "exclude_tags", value)

    @_builtins.property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAzureIncludeTagArgs']]]]:
        """
        IncludeTags only discovers cloud resources that have one of the included tags. We do not allow duplicate tag names for IncludeTags
        """
        return pulumi.get(self, "include_tags")

    @include_tags.setter
    def include_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorAzureIncludeTagArgs']]]]):
        pulumi.set(self, "include_tags", value)

    @_builtins.property
    @pulumi.getter(name="scanPeriod")
    def scan_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ScanPeriod identifies which remote system this Connector discovers
        """
        return pulumi.get(self, "scan_period")

    @scan_period.setter
    def scan_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scan_period", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Services is a list of services this connector should scan.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionIds")
    def subscription_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        SubscriptionIds are the targets of discovery.
        """
        return pulumi.get(self, "subscription_ids")

    @subscription_ids.setter
    def subscription_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subscription_ids", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        TenantId is the Azure Tenant we're discovering in
        * gcp:
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ConnectorAzureExcludeTagArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique human-readable name of the Connector.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of this tag.
        """
elif False:
    ConnectorAzureExcludeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAzureExcludeTagArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Connector.
        :param pulumi.Input[_builtins.str] value: The value of this tag.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique human-readable name of the Connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of this tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectorAzureIncludeTagArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique human-readable name of the Connector.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of this tag.
        """
elif False:
    ConnectorAzureIncludeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAzureIncludeTagArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Connector.
        :param pulumi.Input[_builtins.str] value: The value of this tag.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique human-readable name of the Connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of this tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectorGcpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Connector.
        """
        exclude_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectorGcpExcludeTagArgsDict']]]]
        """
        ExcludeTags filters out discovered resources that have the tag and value. We do allow duplicate tag names for ExcludeTags to support multiple excluded values for the tag.
        """
        include_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectorGcpIncludeTagArgsDict']]]]
        """
        IncludeTags only discovers cloud resources that have one of the included tags. We do not allow duplicate tag names for IncludeTags
        """
        project_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        ProjectIds is the list of GCP Projects the connector will scan
        """
        scan_period: NotRequired[pulumi.Input[_builtins.str]]
        """
        ScanPeriod identifies which remote system this Connector discovers
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Services is a list of services this connector should scan.
        """
        workload_pool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        WorkloadPoolId is the GCP Workload Pool Identifier used to authenticate our JWT
        """
        workload_project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        WorkloadProjectId is the GCP Project ID where the Workload Pool is defined
        """
        workload_project_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        WorkloadProjectNumber is the GCP Project Number where the Workload Pool is defined
        """
        workload_provider_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        WorkloadProviderId is the GCP Workload Provider Identifier used to authenticate our JWT
        """
elif False:
    ConnectorGcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorGcpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_tags: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorGcpExcludeTagArgs']]]] = None,
                 include_tags: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorGcpIncludeTagArgs']]]] = None,
                 project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 scan_period: Optional[pulumi.Input[_builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 workload_pool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 workload_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 workload_project_number: Optional[pulumi.Input[_builtins.str]] = None,
                 workload_provider_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Connector.
        :param pulumi.Input[_builtins.str] description: Description of the Connector.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorGcpExcludeTagArgs']]] exclude_tags: ExcludeTags filters out discovered resources that have the tag and value. We do allow duplicate tag names for ExcludeTags to support multiple excluded values for the tag.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorGcpIncludeTagArgs']]] include_tags: IncludeTags only discovers cloud resources that have one of the included tags. We do not allow duplicate tag names for IncludeTags
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] project_ids: ProjectIds is the list of GCP Projects the connector will scan
        :param pulumi.Input[_builtins.str] scan_period: ScanPeriod identifies which remote system this Connector discovers
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] services: Services is a list of services this connector should scan.
        :param pulumi.Input[_builtins.str] workload_pool_id: WorkloadPoolId is the GCP Workload Pool Identifier used to authenticate our JWT
        :param pulumi.Input[_builtins.str] workload_project_id: WorkloadProjectId is the GCP Project ID where the Workload Pool is defined
        :param pulumi.Input[_builtins.str] workload_project_number: WorkloadProjectNumber is the GCP Project Number where the Workload Pool is defined
        :param pulumi.Input[_builtins.str] workload_provider_id: WorkloadProviderId is the GCP Workload Provider Identifier used to authenticate our JWT
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_tags is not None:
            pulumi.set(__self__, "exclude_tags", exclude_tags)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)
        if scan_period is not None:
            pulumi.set(__self__, "scan_period", scan_period)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if workload_pool_id is not None:
            pulumi.set(__self__, "workload_pool_id", workload_pool_id)
        if workload_project_id is not None:
            pulumi.set(__self__, "workload_project_id", workload_project_id)
        if workload_project_number is not None:
            pulumi.set(__self__, "workload_project_number", workload_project_number)
        if workload_provider_id is not None:
            pulumi.set(__self__, "workload_provider_id", workload_provider_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Connector.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="excludeTags")
    def exclude_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorGcpExcludeTagArgs']]]]:
        """
        ExcludeTags filters out discovered resources that have the tag and value. We do allow duplicate tag names for ExcludeTags to support multiple excluded values for the tag.
        """
        return pulumi.get(self, "exclude_tags")

    @exclude_tags.setter
    def exclude_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorGcpExcludeTagArgs']]]]):
        pulumi.set(self, "exclude_tags", value)

    @_builtins.property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorGcpIncludeTagArgs']]]]:
        """
        IncludeTags only discovers cloud resources that have one of the included tags. We do not allow duplicate tag names for IncludeTags
        """
        return pulumi.get(self, "include_tags")

    @include_tags.setter
    def include_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorGcpIncludeTagArgs']]]]):
        pulumi.set(self, "include_tags", value)

    @_builtins.property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        ProjectIds is the list of GCP Projects the connector will scan
        """
        return pulumi.get(self, "project_ids")

    @project_ids.setter
    def project_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "project_ids", value)

    @_builtins.property
    @pulumi.getter(name="scanPeriod")
    def scan_period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ScanPeriod identifies which remote system this Connector discovers
        """
        return pulumi.get(self, "scan_period")

    @scan_period.setter
    def scan_period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scan_period", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Services is a list of services this connector should scan.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        WorkloadPoolId is the GCP Workload Pool Identifier used to authenticate our JWT
        """
        return pulumi.get(self, "workload_pool_id")

    @workload_pool_id.setter
    def workload_pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workload_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="workloadProjectId")
    def workload_project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        WorkloadProjectId is the GCP Project ID where the Workload Pool is defined
        """
        return pulumi.get(self, "workload_project_id")

    @workload_project_id.setter
    def workload_project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workload_project_id", value)

    @_builtins.property
    @pulumi.getter(name="workloadProjectNumber")
    def workload_project_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        WorkloadProjectNumber is the GCP Project Number where the Workload Pool is defined
        """
        return pulumi.get(self, "workload_project_number")

    @workload_project_number.setter
    def workload_project_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workload_project_number", value)

    @_builtins.property
    @pulumi.getter(name="workloadProviderId")
    def workload_provider_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        WorkloadProviderId is the GCP Workload Provider Identifier used to authenticate our JWT
        """
        return pulumi.get(self, "workload_provider_id")

    @workload_provider_id.setter
    def workload_provider_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workload_provider_id", value)


if not MYPY:
    class ConnectorGcpExcludeTagArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique human-readable name of the Connector.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of this tag.
        """
elif False:
    ConnectorGcpExcludeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorGcpExcludeTagArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Connector.
        :param pulumi.Input[_builtins.str] value: The value of this tag.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique human-readable name of the Connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of this tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectorGcpIncludeTagArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique human-readable name of the Connector.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of this tag.
        """
elif False:
    ConnectorGcpIncludeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorGcpIncludeTagArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Connector.
        :param pulumi.Input[_builtins.str] value: The value of this tag.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique human-readable name of the Connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of this tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NodeGatewayArgsDict(TypedDict):
        listen_address: pulumi.Input[_builtins.str]
        """
        The public hostname/port tuple at which the gateway will be accessible to clients.
        """
        bind_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        """
        device: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        gateway_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        maintenance_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeGatewayMaintenanceWindowArgsDict']]]]
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
elif False:
    NodeGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGatewayArgs:
    def __init__(__self__, *,
                 listen_address: pulumi.Input[_builtins.str],
                 bind_address: Optional[pulumi.Input[_builtins.str]] = None,
                 device: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 maintenance_windows: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGatewayMaintenanceWindowArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] listen_address: The public hostname/port tuple at which the gateway will be accessible to clients.
        :param pulumi.Input[_builtins.str] bind_address: The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        :param pulumi.Input[_builtins.str] device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param pulumi.Input[_builtins.str] gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param pulumi.Input[_builtins.str] location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param pulumi.Input[Sequence[pulumi.Input['NodeGatewayMaintenanceWindowArgs']]] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        pulumi.set(__self__, "listen_address", listen_address)
        if bind_address is not None:
            pulumi.set(__self__, "bind_address", bind_address)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> pulumi.Input[_builtins.str]:
        """
        The public hostname/port tuple at which the gateway will be accessible to clients.
        """
        return pulumi.get(self, "listen_address")

    @listen_address.setter
    def listen_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "listen_address", value)

    @_builtins.property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        """
        return pulumi.get(self, "bind_address")

    @bind_address.setter
    def bind_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_address", value)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @gateway_filter.setter
    def gateway_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway_filter", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeGatewayMaintenanceWindowArgs']]]]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @maintenance_windows.setter
    def maintenance_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeGatewayMaintenanceWindowArgs']]]]):
        pulumi.set(self, "maintenance_windows", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class NodeGatewayMaintenanceWindowArgsDict(TypedDict):
        cron_schedule: pulumi.Input[_builtins.str]
        require_idleness: pulumi.Input[_builtins.bool]
elif False:
    NodeGatewayMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGatewayMaintenanceWindowArgs:
    def __init__(__self__, *,
                 cron_schedule: pulumi.Input[_builtins.str],
                 require_idleness: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @_builtins.property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cron_schedule")

    @cron_schedule.setter
    def cron_schedule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron_schedule", value)

    @_builtins.property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "require_idleness")

    @require_idleness.setter
    def require_idleness(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "require_idleness", value)


if not MYPY:
    class NodeProxyClusterArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        The public hostname/port tuple at which the proxy cluster will be accessible to clients.
        """
        maintenance_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeProxyClusterMaintenanceWindowArgsDict']]]]
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    NodeProxyClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeProxyClusterArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 maintenance_windows: Optional[pulumi.Input[Sequence[pulumi.Input['NodeProxyClusterMaintenanceWindowArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The public hostname/port tuple at which the proxy cluster will be accessible to clients.
        :param pulumi.Input[Sequence[pulumi.Input['NodeProxyClusterMaintenanceWindowArgs']]] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "address", address)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        The public hostname/port tuple at which the proxy cluster will be accessible to clients.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeProxyClusterMaintenanceWindowArgs']]]]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @maintenance_windows.setter
    def maintenance_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeProxyClusterMaintenanceWindowArgs']]]]):
        pulumi.set(self, "maintenance_windows", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NodeProxyClusterMaintenanceWindowArgsDict(TypedDict):
        cron_schedule: pulumi.Input[_builtins.str]
        require_idleness: pulumi.Input[_builtins.bool]
elif False:
    NodeProxyClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeProxyClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 cron_schedule: pulumi.Input[_builtins.str],
                 require_idleness: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @_builtins.property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cron_schedule")

    @cron_schedule.setter
    def cron_schedule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron_schedule", value)

    @_builtins.property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "require_idleness")

    @require_idleness.setter
    def require_idleness(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "require_idleness", value)


if not MYPY:
    class NodeRelayArgsDict(TypedDict):
        device: NotRequired[pulumi.Input[_builtins.str]]
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        gateway_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        maintenance_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['NodeRelayMaintenanceWindowArgsDict']]]]
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
elif False:
    NodeRelayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeRelayArgs:
    def __init__(__self__, *,
                 device: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 maintenance_windows: Optional[pulumi.Input[Sequence[pulumi.Input['NodeRelayMaintenanceWindowArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device: Device is a read only device name uploaded by the gateway process when it comes online.
        :param pulumi.Input[_builtins.str] gateway_filter: GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        :param pulumi.Input[_builtins.str] location: Location is a read only network location uploaded by the gateway process when it comes online.
        :param pulumi.Input[Sequence[pulumi.Input['NodeRelayMaintenanceWindowArgs']]] maintenance_windows: Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] version: Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        if device is not None:
            pulumi.set(__self__, "device", device)
        if gateway_filter is not None:
            pulumi.set(__self__, "gateway_filter", gateway_filter)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Device is a read only device name uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter(name="gatewayFilter")
    def gateway_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
        """
        return pulumi.get(self, "gateway_filter")

    @gateway_filter.setter
    def gateway_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway_filter", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Location is a read only network location uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeRelayMaintenanceWindowArgs']]]]:
        """
        Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
        """
        return pulumi.get(self, "maintenance_windows")

    @maintenance_windows.setter
    def maintenance_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeRelayMaintenanceWindowArgs']]]]):
        pulumi.set(self, "maintenance_windows", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version is a read only sdm binary version uploaded by the gateway process when it comes online.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class NodeRelayMaintenanceWindowArgsDict(TypedDict):
        cron_schedule: pulumi.Input[_builtins.str]
        require_idleness: pulumi.Input[_builtins.bool]
elif False:
    NodeRelayMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeRelayMaintenanceWindowArgs:
    def __init__(__self__, *,
                 cron_schedule: pulumi.Input[_builtins.str],
                 require_idleness: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "require_idleness", require_idleness)

    @_builtins.property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cron_schedule")

    @cron_schedule.setter
    def cron_schedule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron_schedule", value)

    @_builtins.property
    @pulumi.getter(name="requireIdleness")
    def require_idleness(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "require_idleness")

    @require_idleness.setter
    def require_idleness(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "require_idleness", value)


if not MYPY:
    class ResourceAerospikeArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_services_alternate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, uses UseServicesAlternates directive for Aerospike connection
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAerospikeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAerospikeArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_services_alternate: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_services_alternate: If true, uses UseServicesAlternates directive for Aerospike connection
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_services_alternate is not None:
            pulumi.set(__self__, "use_services_alternate", use_services_alternate)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useServicesAlternate")
    def use_services_alternate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, uses UseServicesAlternates directive for Aerospike connection
        """
        return pulumi.get(self, "use_services_alternate")

    @use_services_alternate.setter
    def use_services_alternate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_services_alternate", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAksArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        allow_resource_role_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate to authenticate TLS connections with.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key to authenticate TLS connections with.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        discovery_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAksArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 allow_resource_role_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 discovery_username: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.bool] allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_certificate: The certificate to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_key: The key to authenticate TLS connections with.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @allow_resource_role_bypass.setter
    def allow_resource_role_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_resource_role_bypass", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @discovery_username.setter
    def discovery_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_username", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAksBasicAuthArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAksBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAksBasicAuthArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAksServiceAccountArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        allow_resource_role_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        discovery_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
elif False:
    ResourceAksServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAksServiceAccountArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 allow_resource_role_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 discovery_username: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.bool] allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @allow_resource_role_bypass.setter
    def allow_resource_role_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_resource_role_bypass", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @discovery_username.setter
    def discovery_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_username", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ResourceAksServiceAccountUserImpersonationArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
elif False:
    ResourceAksServiceAccountUserImpersonationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAksServiceAccountUserImpersonationArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ResourceAksUserImpersonationArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate to authenticate TLS connections with.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key to authenticate TLS connections with.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAksUserImpersonationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAksUserImpersonationArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_certificate: The certificate to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_key: The key to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAmazonEksArgsDict(TypedDict):
        cluster_name: pulumi.Input[_builtins.str]
        """
        The name of the cluster to connect to.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access Key ID to use to authenticate.
        """
        allow_resource_role_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        discovery_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Secret Access Key to use to authenticate.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAmazonEksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAmazonEksArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 allow_resource_role_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 discovery_username: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_name: The name of the cluster to connect to.
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] access_key: The Access Key ID to use to authenticate.
        :param pulumi.Input[_builtins.bool] allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_access_key: The Secret Access Key to use to authenticate.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @allow_resource_role_bypass.setter
    def allow_resource_role_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_resource_role_bypass", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @discovery_username.setter
    def discovery_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_username", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAmazonEksInstanceProfileArgsDict(TypedDict):
        cluster_name: pulumi.Input[_builtins.str]
        """
        The name of the cluster to connect to.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        allow_resource_role_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        discovery_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAmazonEksInstanceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAmazonEksInstanceProfileArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 allow_resource_role_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 discovery_username: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_name: The name of the cluster to connect to.
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.bool] allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @allow_resource_role_bypass.setter
    def allow_resource_role_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_resource_role_bypass", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @discovery_username.setter
    def discovery_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_username", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAmazonEksInstanceProfileUserImpersonationArgsDict(TypedDict):
        cluster_name: pulumi.Input[_builtins.str]
        """
        The name of the cluster to connect to.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAmazonEksInstanceProfileUserImpersonationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAmazonEksInstanceProfileUserImpersonationArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_name: The name of the cluster to connect to.
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAmazonEksUserImpersonationArgsDict(TypedDict):
        cluster_name: pulumi.Input[_builtins.str]
        """
        The name of the cluster to connect to.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access Key ID to use to authenticate.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Secret Access Key to use to authenticate.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAmazonEksUserImpersonationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAmazonEksUserImpersonationArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_name: The name of the cluster to connect to.
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] access_key: The Access Key ID to use to authenticate.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_access_key: The Secret Access Key to use to authenticate.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAmazonEsArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access Key ID to use to authenticate.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Secret Access Key to use to authenticate.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAmazonEsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAmazonEsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] access_key: The Access Key ID to use to authenticate.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_access_key: The Secret Access Key to use to authenticate.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAmazonEsiamArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
elif False:
    ResourceAmazonEsiamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAmazonEsiamArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)


if not MYPY:
    class ResourceAmazonmqAmqp091ArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAmazonmqAmqp091ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAmazonmqAmqp091Args:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAmazonmqAmqpArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAmazonmqAmqpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAmazonmqAmqpArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAthenaArgsDict(TypedDict):
        athena_output: pulumi.Input[_builtins.str]
        """
        The AWS S3 output location.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access Key ID to use to authenticate.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS region to connect to.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Secret Access Key to use to authenticate.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAthenaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAthenaArgs:
    def __init__(__self__, *,
                 athena_output: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] athena_output: The AWS S3 output location.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] access_key: The Access Key ID to use to authenticate.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_access_key: The Secret Access Key to use to authenticate.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "athena_output", athena_output)
        pulumi.set(__self__, "name", name)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="athenaOutput")
    def athena_output(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS S3 output location.
        """
        return pulumi.get(self, "athena_output")

    @athena_output.setter
    def athena_output(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "athena_output", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAthenaIamArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        output: pulumi.Input[_builtins.str]
        """
        The AWS S3 output location.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS region to connect to.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAthenaIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAthenaIamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 output: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] output: The AWS S3 output location.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output", output)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def output(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS S3 output location.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAuroraMysqlArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        require_native_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAuroraMysqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAuroraMysqlArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 require_native_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.bool] require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @require_native_auth.setter
    def require_native_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_native_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAuroraMysqlIamArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_assumption_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAuroraMysqlIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAuroraMysqlIamArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_assumption_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @role_assumption_arn.setter
    def role_assumption_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_assumption_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAuroraPostgresArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAuroraPostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAuroraPostgresArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAuroraPostgresIamArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_assumption_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAuroraPostgresIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAuroraPostgresIamArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_assumption_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @role_assumption_arn.setter
    def role_assumption_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_assumption_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAwsArgsDict(TypedDict):
        healthcheck_region: pulumi.Input[_builtins.str]
        """
        The AWS region healthcheck requests should attempt to connect to.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access Key ID to use to authenticate.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Secret Access Key to use to authenticate.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAwsArgs:
    def __init__(__self__, *,
                 healthcheck_region: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] healthcheck_region: The AWS region healthcheck requests should attempt to connect to.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] access_key: The Access Key ID to use to authenticate.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_access_key: The Secret Access Key to use to authenticate.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_region", healthcheck_region)
        pulumi.set(__self__, "name", name)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="healthcheckRegion")
    def healthcheck_region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region healthcheck requests should attempt to connect to.
        """
        return pulumi.get(self, "healthcheck_region")

    @healthcheck_region.setter
    def healthcheck_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "healthcheck_region", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAwsConsoleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        enable_env_variables: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        session_expiry: NotRequired[pulumi.Input[_builtins.int]]
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAwsConsoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAwsConsoleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_env_variables: Optional[pulumi.Input[_builtins.bool]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 session_expiry: Optional[pulumi.Input[_builtins.int]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] enable_env_variables: If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.int] session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "subdomain", subdomain)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if enable_env_variables is not None:
            pulumi.set(__self__, "enable_env_variables", enable_env_variables)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="enableEnvVariables")
    def enable_env_variables(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        return pulumi.get(self, "enable_env_variables")

    @enable_env_variables.setter
    def enable_env_variables(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_env_variables", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @session_expiry.setter
    def session_expiry(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "session_expiry", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAwsConsoleStaticKeyPairArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access Key ID to use to authenticate.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Secret Access Key to use to authenticate.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        session_expiry: NotRequired[pulumi.Input[_builtins.int]]
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAwsConsoleStaticKeyPairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAwsConsoleStaticKeyPairArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 session_expiry: Optional[pulumi.Input[_builtins.int]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[_builtins.str] access_key: The Access Key ID to use to authenticate.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_access_key: The Secret Access Key to use to authenticate.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.int] session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "subdomain", subdomain)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @session_expiry.setter
    def session_expiry(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "session_expiry", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAwsInstanceProfileArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        enable_env_variables: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceAwsInstanceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAwsInstanceProfileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_env_variables: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] enable_env_variables: If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if enable_env_variables is not None:
            pulumi.set(__self__, "enable_env_variables", enable_env_variables)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="enableEnvVariables")
    def enable_env_variables(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
        """
        return pulumi.get(self, "enable_env_variables")

    @enable_env_variables.setter
    def enable_env_variables(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_env_variables", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceAzureArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        app_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The application ID to authenticate with.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
elif False:
    ResourceAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAzureArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 app_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] app_id: The application ID to authenticate with.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        pulumi.set(__self__, "name", name)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_id", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ResourceAzureCertificateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        app_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The application ID to authenticate with.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate to authenticate TLS connections with.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
elif False:
    ResourceAzureCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAzureCertificateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 app_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] app_id: The application ID to authenticate with.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] client_certificate: The certificate to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        pulumi.set(__self__, "name", name)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The application ID to authenticate with.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_id", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ResourceAzureMysqlArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        require_native_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAzureMysqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAzureMysqlArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 require_native_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.bool] require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @require_native_auth.setter
    def require_native_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_native_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAzureMysqlManagedIdentityArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAzureMysqlManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAzureMysqlManagedIdentityArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAzurePostgresArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAzurePostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAzurePostgresArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceAzurePostgresManagedIdentityArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceAzurePostgresManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceAzurePostgresManagedIdentityArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceBigQueryArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        project: pulumi.Input[_builtins.str]
        """
        The GCP project ID containing the Spanner database.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key used to authenticate with the server.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceBigQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceBigQueryArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] project: The GCP project ID containing the Spanner database.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] private_key: The private key used to authenticate with the server.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> pulumi.Input[_builtins.str]:
        """
        The GCP project ID containing the Spanner database.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceCassandraArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceCassandraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceCassandraArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceCitusArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceCitusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceCitusArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceClickHouseHttpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        url: pulumi.Input[_builtins.str]
        """
        The base address of your website without the path.
        * kubernetes:
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceClickHouseHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceClickHouseHttpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] url: The base address of your website without the path.
               * kubernetes:
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceClickHouseMySqlArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        require_native_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceClickHouseMySqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceClickHouseMySqlArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 require_native_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.bool] require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @require_native_auth.setter
    def require_native_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_native_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceClickHouseTcpArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceClickHouseTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceClickHouseTcpArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceClustrixArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        require_native_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceClustrixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceClustrixArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 require_native_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.bool] require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @require_native_auth.setter
    def require_native_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_native_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceCockroachArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceCockroachArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceCockroachArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceCouchbaseDatabaseArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        n1_ql_port: pulumi.Input[_builtins.int]
        """
        The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceCouchbaseDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceCouchbaseDatabaseArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 n1_ql_port: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] n1_ql_port: The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "n1_ql_port", n1_ql_port)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="n1QlPort")
    def n1_ql_port(self) -> pulumi.Input[_builtins.int]:
        """
        The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.
        """
        return pulumi.get(self, "n1_ql_port")

    @n1_ql_port.setter
    def n1_ql_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "n1_ql_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceCouchbaseWebUiArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        url: pulumi.Input[_builtins.str]
        """
        The base address of your website without the path.
        * kubernetes:
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceCouchbaseWebUiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceCouchbaseWebUiArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[_builtins.str] url: The base address of your website without the path.
               * kubernetes:
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceDb2IArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceDb2IArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDb2IArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceDb2LuwArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceDb2LuwArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDb2LuwArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceDocumentDbHostArgsDict(TypedDict):
        auth_database: pulumi.Input[_builtins.str]
        """
        The authentication database to use.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceDocumentDbHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDocumentDbHostArgs:
    def __init__(__self__, *,
                 auth_database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_database: The authentication database to use.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @auth_database.setter
    def auth_database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceDocumentDbHostIamArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceDocumentDbHostIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDocumentDbHostIamArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceDocumentDbReplicaSetArgsDict(TypedDict):
        auth_database: pulumi.Input[_builtins.str]
        """
        The authentication database to use.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        connect_to_replica: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to connect to a replica instead of the primary node.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceDocumentDbReplicaSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDocumentDbReplicaSetArgs:
    def __init__(__self__, *,
                 auth_database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_to_replica: Optional[pulumi.Input[_builtins.bool]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_database: The authentication database to use.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] connect_to_replica: Set to connect to a replica instead of the primary node.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @auth_database.setter
    def auth_database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @connect_to_replica.setter
    def connect_to_replica(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "connect_to_replica", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceDocumentDbReplicaSetIamArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        connect_to_replica: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to connect to a replica instead of the primary node.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceDocumentDbReplicaSetIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDocumentDbReplicaSetIamArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_to_replica: Optional[pulumi.Input[_builtins.bool]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] connect_to_replica: Set to connect to a replica instead of the primary node.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @connect_to_replica.setter
    def connect_to_replica(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "connect_to_replica", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceDruidArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceDruidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDruidArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceDynamoDbArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access Key ID to use to authenticate.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Secret Access Key to use to authenticate.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceDynamoDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDynamoDbArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] access_key: The Access Key ID to use to authenticate.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_access_key: The Secret Access Key to use to authenticate.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceDynamoDbiamArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceDynamoDbiamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDynamoDbiamArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceElasticArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceElasticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceElasticArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceElasticacheRedisArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceElasticacheRedisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceElasticacheRedisArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceElasticacheRedisIamArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_assumption_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceElasticacheRedisIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceElasticacheRedisIamArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_assumption_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @role_assumption_arn.setter
    def role_assumption_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_assumption_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceEntraIdArgsDict(TypedDict):
        identity_set_id: pulumi.Input[_builtins.str]
        """
        The ID of the identity set to use for identity connections.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        tenant_id: pulumi.Input[_builtins.str]
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        group_names: NotRequired[pulumi.Input[_builtins.str]]
        """
        comma separated list of group names to filter by. Supports wildcards (*)
        """
        management_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The management group ID to authenticate scope Privileges to.
        """
        privilege_levels: NotRequired[pulumi.Input[_builtins.str]]
        """
        The privilege levels specify which Groups are managed externally
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        resource_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        filters discovered groups to the specified Resource Group
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        subscription_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subscription ID to authenticate scope Privileges to.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceEntraIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceEntraIdArgs:
    def __init__(__self__, *,
                 identity_set_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 tenant_id: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 group_names: Optional[pulumi.Input[_builtins.str]] = None,
                 management_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 privilege_levels: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 subscription_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] group_names: comma separated list of group names to filter by. Supports wildcards (*)
        :param pulumi.Input[_builtins.str] management_group_id: The management group ID to authenticate scope Privileges to.
        :param pulumi.Input[_builtins.str] privilege_levels: The privilege levels specify which Groups are managed externally
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] resource_group_id: filters discovered groups to the specified Resource Group
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[_builtins.str] subscription_id: The subscription ID to authenticate scope Privileges to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "identity_set_id", identity_set_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if group_names is not None:
            pulumi.set(__self__, "group_names", group_names)
        if management_group_id is not None:
            pulumi.set(__self__, "management_group_id", management_group_id)
        if privilege_levels is not None:
            pulumi.set(__self__, "privilege_levels", privilege_levels)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if resource_group_id is not None:
            pulumi.set(__self__, "resource_group_id", resource_group_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="groupNames")
    def group_names(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        comma separated list of group names to filter by. Supports wildcards (*)
        """
        return pulumi.get(self, "group_names")

    @group_names.setter
    def group_names(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_names", value)

    @_builtins.property
    @pulumi.getter(name="managementGroupId")
    def management_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The management group ID to authenticate scope Privileges to.
        """
        return pulumi.get(self, "management_group_id")

    @management_group_id.setter
    def management_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "management_group_id", value)

    @_builtins.property
    @pulumi.getter(name="privilegeLevels")
    def privilege_levels(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The privilege levels specify which Groups are managed externally
        """
        return pulumi.get(self, "privilege_levels")

    @privilege_levels.setter
    def privilege_levels(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "privilege_levels", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        filters discovered groups to the specified Resource Group
        """
        return pulumi.get(self, "resource_group_id")

    @resource_group_id.setter
    def resource_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subscription ID to authenticate scope Privileges to.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subscription_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceGcpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        scopes: pulumi.Input[_builtins.str]
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        keyfile: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service account keyfile to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceGcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGcpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 scopes: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 keyfile: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] scopes: Space separated scopes that this login should assume into when authenticating.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] keyfile: The service account keyfile to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if keyfile is not None:
            pulumi.set(__self__, "keyfile", keyfile)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[_builtins.str]:
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def keyfile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service account keyfile to authenticate with.
        """
        return pulumi.get(self, "keyfile")

    @keyfile.setter
    def keyfile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keyfile", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceGcpConsoleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        workforce_pool_id: pulumi.Input[_builtins.str]
        """
        The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        """
        workforce_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of the Workforce Identity Provider in GCP to use for federated authentication.
        * google_gke:
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        session_expiry: NotRequired[pulumi.Input[_builtins.int]]
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceGcpConsoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGcpConsoleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str],
                 workforce_pool_id: pulumi.Input[_builtins.str],
                 workforce_provider_id: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 session_expiry: Optional[pulumi.Input[_builtins.int]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[_builtins.str] workforce_pool_id: The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        :param pulumi.Input[_builtins.str] workforce_provider_id: The ID of the Workforce Identity Provider in GCP to use for federated authentication.
               * google_gke:
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.int] session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "workforce_pool_id", workforce_pool_id)
        pulumi.set(__self__, "workforce_provider_id", workforce_provider_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter(name="workforcePoolId")
    def workforce_pool_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        """
        return pulumi.get(self, "workforce_pool_id")

    @workforce_pool_id.setter
    def workforce_pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workforce_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="workforceProviderId")
    def workforce_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Workforce Identity Provider in GCP to use for federated authentication.
        * google_gke:
        """
        return pulumi.get(self, "workforce_provider_id")

    @workforce_provider_id.setter
    def workforce_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workforce_provider_id", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @session_expiry.setter
    def session_expiry(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "session_expiry", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceGcpwifArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        scopes: pulumi.Input[_builtins.str]
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        workforce_pool_id: pulumi.Input[_builtins.str]
        """
        The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        """
        workforce_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of the Workforce Identity Provider in GCP to use for federated authentication.
        * google_gke:
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        When specified, all project scoped requests will use this Project ID, overriding the project ID specified by clients
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        session_expiry: NotRequired[pulumi.Input[_builtins.int]]
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceGcpwifArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGcpwifArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 scopes: pulumi.Input[_builtins.str],
                 workforce_pool_id: pulumi.Input[_builtins.str],
                 workforce_provider_id: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 session_expiry: Optional[pulumi.Input[_builtins.int]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] scopes: Space separated scopes that this login should assume into when authenticating.
        :param pulumi.Input[_builtins.str] workforce_pool_id: The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        :param pulumi.Input[_builtins.str] workforce_provider_id: The ID of the Workforce Identity Provider in GCP to use for federated authentication.
               * google_gke:
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] project_id: When specified, all project scoped requests will use this Project ID, overriding the project ID specified by clients
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.int] session_expiry: The length of time in seconds console sessions will live before needing to reauthenticate.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "workforce_pool_id", workforce_pool_id)
        pulumi.set(__self__, "workforce_provider_id", workforce_provider_id)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if session_expiry is not None:
            pulumi.set(__self__, "session_expiry", session_expiry)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[_builtins.str]:
        """
        Space separated scopes that this login should assume into when authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="workforcePoolId")
    def workforce_pool_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Workforce Identity Pool in GCP to use for federated authentication.
        """
        return pulumi.get(self, "workforce_pool_id")

    @workforce_pool_id.setter
    def workforce_pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workforce_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="workforceProviderId")
    def workforce_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Workforce Identity Provider in GCP to use for federated authentication.
        * google_gke:
        """
        return pulumi.get(self, "workforce_provider_id")

    @workforce_provider_id.setter
    def workforce_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workforce_provider_id", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When specified, all project scoped requests will use this Project ID, overriding the project ID specified by clients
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="sessionExpiry")
    def session_expiry(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The length of time in seconds console sessions will live before needing to reauthenticate.
        """
        return pulumi.get(self, "session_expiry")

    @session_expiry.setter
    def session_expiry(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "session_expiry", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceGoogleGkeArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        allow_resource_role_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        discovery_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        service_account_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service account key to authenticate with.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceGoogleGkeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGoogleGkeArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 allow_resource_role_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 discovery_username: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_account_key: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.bool] allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] service_account_key: The service account key to authenticate with.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @allow_resource_role_bypass.setter
    def allow_resource_role_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_resource_role_bypass", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @discovery_username.setter
    def discovery_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_username", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @service_account_key.setter
    def service_account_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account_key", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceGoogleGkeUserImpersonationArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        service_account_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service account key to authenticate with.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceGoogleGkeUserImpersonationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGoogleGkeUserImpersonationArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_account_key: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] service_account_key: The service account key to authenticate with.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service account key to authenticate with.
        """
        return pulumi.get(self, "service_account_key")

    @service_account_key.setter
    def service_account_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account_key", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceGoogleSpannerArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        instance: pulumi.Input[_builtins.str]
        """
        The Spanner instance ID within the GCP project.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        project: pulumi.Input[_builtins.str]
        """
        The GCP project ID containing the Spanner database.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        service_account_to_impersonate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional service account email to impersonate. When set, the relay's Application Default Credentials will impersonate this service account to access Spanner. This allows role separation where the relay uses one service account but operates as another.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceGoogleSpannerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGoogleSpannerArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 instance: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 service_account_to_impersonate: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] instance: The Spanner instance ID within the GCP project.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] project: The GCP project ID containing the Spanner database.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] service_account_to_impersonate: Optional service account email to impersonate. When set, the relay's Application Default Credentials will impersonate this service account to access Spanner. This allows role separation where the relay uses one service account but operates as another.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "instance", instance)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if service_account_to_impersonate is not None:
            pulumi.set(__self__, "service_account_to_impersonate", service_account_to_impersonate)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def instance(self) -> pulumi.Input[_builtins.str]:
        """
        The Spanner instance ID within the GCP project.
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> pulumi.Input[_builtins.str]:
        """
        The GCP project ID containing the Spanner database.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountToImpersonate")
    def service_account_to_impersonate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional service account email to impersonate. When set, the relay's Application Default Credentials will impersonate this service account to access Spanner. This allows role separation where the relay uses one service account but operates as another.
        """
        return pulumi.get(self, "service_account_to_impersonate")

    @service_account_to_impersonate.setter
    def service_account_to_impersonate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account_to_impersonate", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceGreenplumArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceGreenplumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGreenplumArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceHttpAuthArgsDict(TypedDict):
        healthcheck_path: pulumi.Input[_builtins.str]
        """
        This path will be used to check the health of your site.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        url: pulumi.Input[_builtins.str]
        """
        The base address of your website without the path.
        * kubernetes:
        """
        auth_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        The content to set as the authorization header.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        default_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Automatically redirect to this path upon connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        headers_blacklist: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        host_override: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host header will be overwritten with this field if provided.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceHttpAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceHttpAuthArgs:
    def __init__(__self__, *,
                 healthcheck_path: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 auth_header: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 default_path: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 headers_blacklist: Optional[pulumi.Input[_builtins.str]] = None,
                 host_override: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] healthcheck_path: This path will be used to check the health of your site.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[_builtins.str] url: The base address of your website without the path.
               * kubernetes:
        :param pulumi.Input[_builtins.str] auth_header: The content to set as the authorization header.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] default_path: Automatically redirect to this path upon connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param pulumi.Input[_builtins.str] host_override: The host header will be overwritten with this field if provided.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if auth_header is not None:
            pulumi.set(__self__, "auth_header", auth_header)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> pulumi.Input[_builtins.str]:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @healthcheck_path.setter
    def healthcheck_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "healthcheck_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="authHeader")
    def auth_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The content to set as the authorization header.
        """
        return pulumi.get(self, "auth_header")

    @auth_header.setter
    def auth_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_header", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @default_path.setter
    def default_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_path", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @headers_blacklist.setter
    def headers_blacklist(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "headers_blacklist", value)

    @_builtins.property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @host_override.setter
    def host_override(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_override", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceHttpBasicAuthArgsDict(TypedDict):
        healthcheck_path: pulumi.Input[_builtins.str]
        """
        This path will be used to check the health of your site.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        url: pulumi.Input[_builtins.str]
        """
        The base address of your website without the path.
        * kubernetes:
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        default_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Automatically redirect to this path upon connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        headers_blacklist: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        host_override: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host header will be overwritten with this field if provided.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceHttpBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceHttpBasicAuthArgs:
    def __init__(__self__, *,
                 healthcheck_path: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 default_path: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 headers_blacklist: Optional[pulumi.Input[_builtins.str]] = None,
                 host_override: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] healthcheck_path: This path will be used to check the health of your site.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[_builtins.str] url: The base address of your website without the path.
               * kubernetes:
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] default_path: Automatically redirect to this path upon connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param pulumi.Input[_builtins.str] host_override: The host header will be overwritten with this field if provided.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> pulumi.Input[_builtins.str]:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @healthcheck_path.setter
    def healthcheck_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "healthcheck_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @default_path.setter
    def default_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_path", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @headers_blacklist.setter
    def headers_blacklist(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "headers_blacklist", value)

    @_builtins.property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @host_override.setter
    def host_override(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_override", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceHttpNoAuthArgsDict(TypedDict):
        healthcheck_path: pulumi.Input[_builtins.str]
        """
        This path will be used to check the health of your site.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        url: pulumi.Input[_builtins.str]
        """
        The base address of your website without the path.
        * kubernetes:
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        default_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Automatically redirect to this path upon connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        headers_blacklist: NotRequired[pulumi.Input[_builtins.str]]
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        host_override: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host header will be overwritten with this field if provided.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceHttpNoAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceHttpNoAuthArgs:
    def __init__(__self__, *,
                 healthcheck_path: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 default_path: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 headers_blacklist: Optional[pulumi.Input[_builtins.str]] = None,
                 host_override: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] healthcheck_path: This path will be used to check the health of your site.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[_builtins.str] url: The base address of your website without the path.
               * kubernetes:
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] default_path: Automatically redirect to this path upon connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] headers_blacklist: Header names (e.g. Authorization), to omit from logs.
        :param pulumi.Input[_builtins.str] host_override: The host header will be overwritten with this field if provided.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_path", healthcheck_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "url", url)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if default_path is not None:
            pulumi.set(__self__, "default_path", default_path)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if headers_blacklist is not None:
            pulumi.set(__self__, "headers_blacklist", headers_blacklist)
        if host_override is not None:
            pulumi.set(__self__, "host_override", host_override)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="healthcheckPath")
    def healthcheck_path(self) -> pulumi.Input[_builtins.str]:
        """
        This path will be used to check the health of your site.
        """
        return pulumi.get(self, "healthcheck_path")

    @healthcheck_path.setter
    def healthcheck_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "healthcheck_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The base address of your website without the path.
        * kubernetes:
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="defaultPath")
    def default_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Automatically redirect to this path upon connecting.
        """
        return pulumi.get(self, "default_path")

    @default_path.setter
    def default_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_path", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="headersBlacklist")
    def headers_blacklist(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Header names (e.g. Authorization), to omit from logs.
        """
        return pulumi.get(self, "headers_blacklist")

    @headers_blacklist.setter
    def headers_blacklist(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "headers_blacklist", value)

    @_builtins.property
    @pulumi.getter(name="hostOverride")
    def host_override(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host header will be overwritten with this field if provided.
        """
        return pulumi.get(self, "host_override")

    @host_override.setter
    def host_override(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_override", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceKubernetesArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        allow_resource_role_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate to authenticate TLS connections with.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key to authenticate TLS connections with.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        discovery_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceKubernetesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceKubernetesArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 allow_resource_role_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 discovery_username: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.bool] allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_certificate: The certificate to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_key: The key to authenticate TLS connections with.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @allow_resource_role_bypass.setter
    def allow_resource_role_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_resource_role_bypass", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @discovery_username.setter
    def discovery_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_username", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceKubernetesBasicAuthArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceKubernetesBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceKubernetesBasicAuthArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceKubernetesPodIdentityArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        allow_resource_role_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        discovery_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceKubernetesPodIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceKubernetesPodIdentityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 allow_resource_role_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 discovery_username: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.bool] allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @allow_resource_role_bypass.setter
    def allow_resource_role_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_resource_role_bypass", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @discovery_username.setter
    def discovery_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_username", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceKubernetesServiceAccountArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        allow_resource_role_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        discovery_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
elif False:
    ResourceKubernetesServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceKubernetesServiceAccountArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 allow_resource_role_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 discovery_username: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.bool] allow_resource_role_bypass: If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] discovery_username: If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_resource_role_bypass is not None:
            pulumi.set(__self__, "allow_resource_role_bypass", allow_resource_role_bypass)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if discovery_username is not None:
            pulumi.set(__self__, "discovery_username", discovery_username)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="allowResourceRoleBypass")
    def allow_resource_role_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
        """
        return pulumi.get(self, "allow_resource_role_bypass")

    @allow_resource_role_bypass.setter
    def allow_resource_role_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_resource_role_bypass", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUsername")
    def discovery_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
        """
        return pulumi.get(self, "discovery_username")

    @discovery_username.setter
    def discovery_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_username", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ResourceKubernetesServiceAccountUserImpersonationArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
elif False:
    ResourceKubernetesServiceAccountUserImpersonationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceKubernetesServiceAccountUserImpersonationArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] token: The API token to authenticate with.
               * kubernetes_user_impersonation:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The API token to authenticate with.
        * kubernetes_user_impersonation:
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ResourceKubernetesUserImpersonationArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate to authenticate TLS connections with.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key to authenticate TLS connections with.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        healthcheck_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceKubernetesUserImpersonationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceKubernetesUserImpersonationArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_certificate: The certificate to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_key: The key to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] healthcheck_namespace: The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if healthcheck_namespace is not None:
            pulumi.set(__self__, "healthcheck_namespace", healthcheck_namespace)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckNamespace")
    def healthcheck_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
        """
        return pulumi.get(self, "healthcheck_namespace")

    @healthcheck_namespace.setter
    def healthcheck_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_namespace", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceMariaArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        require_native_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMariaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMariaArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 require_native_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.bool] require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @require_native_auth.setter
    def require_native_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_native_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceMcpArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        oauth_auth_endpoint: pulumi.Input[_builtins.str]
        """
        The OAuth 2.0 authorization endpoint URL.
        """
        oauth_token_endpoint: pulumi.Input[_builtins.str]
        """
        The OAuth 2.0 token endpoint URL.
        """
        username: pulumi.Input[_builtins.str]
        """
        The username to authenticate with.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        oauth_register_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OAuth 2.0 dynamic client registration endpoint URL.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceMcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMcpArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 oauth_auth_endpoint: pulumi.Input[_builtins.str],
                 oauth_token_endpoint: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_register_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] oauth_auth_endpoint: The OAuth 2.0 authorization endpoint URL.
        :param pulumi.Input[_builtins.str] oauth_token_endpoint: The OAuth 2.0 token endpoint URL.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] oauth_register_endpoint: The OAuth 2.0 dynamic client registration endpoint URL.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "oauth_auth_endpoint", oauth_auth_endpoint)
        pulumi.set(__self__, "oauth_token_endpoint", oauth_token_endpoint)
        pulumi.set(__self__, "username", username)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if oauth_register_endpoint is not None:
            pulumi.set(__self__, "oauth_register_endpoint", oauth_register_endpoint)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="oauthAuthEndpoint")
    def oauth_auth_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The OAuth 2.0 authorization endpoint URL.
        """
        return pulumi.get(self, "oauth_auth_endpoint")

    @oauth_auth_endpoint.setter
    def oauth_auth_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oauth_auth_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="oauthTokenEndpoint")
    def oauth_token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The OAuth 2.0 token endpoint URL.
        """
        return pulumi.get(self, "oauth_token_endpoint")

    @oauth_token_endpoint.setter
    def oauth_token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oauth_token_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="oauthRegisterEndpoint")
    def oauth_register_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OAuth 2.0 dynamic client registration endpoint URL.
        """
        return pulumi.get(self, "oauth_register_endpoint")

    @oauth_register_endpoint.setter
    def oauth_register_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_register_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceMemcachedArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceMemcachedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMemcachedArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceMemsqlArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        require_native_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMemsqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMemsqlArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 require_native_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.bool] require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @require_native_auth.setter
    def require_native_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_native_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceMongoHostArgsDict(TypedDict):
        auth_database: pulumi.Input[_builtins.str]
        """
        The authentication database to use.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMongoHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMongoHostArgs:
    def __init__(__self__, *,
                 auth_database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_database: The authentication database to use.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @auth_database.setter
    def auth_database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceMongoLegacyHostArgsDict(TypedDict):
        auth_database: pulumi.Input[_builtins.str]
        """
        The authentication database to use.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMongoLegacyHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMongoLegacyHostArgs:
    def __init__(__self__, *,
                 auth_database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_database: The authentication database to use.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @auth_database.setter
    def auth_database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceMongoLegacyReplicasetArgsDict(TypedDict):
        auth_database: pulumi.Input[_builtins.str]
        """
        The authentication database to use.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        connect_to_replica: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to connect to a replica instead of the primary node.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMongoLegacyReplicasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMongoLegacyReplicasetArgs:
    def __init__(__self__, *,
                 auth_database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_to_replica: Optional[pulumi.Input[_builtins.bool]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_database: The authentication database to use.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] connect_to_replica: Set to connect to a replica instead of the primary node.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @auth_database.setter
    def auth_database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @connect_to_replica.setter
    def connect_to_replica(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "connect_to_replica", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceMongoReplicaSetArgsDict(TypedDict):
        auth_database: pulumi.Input[_builtins.str]
        """
        The authentication database to use.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        connect_to_replica: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to connect to a replica instead of the primary node.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMongoReplicaSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMongoReplicaSetArgs:
    def __init__(__self__, *,
                 auth_database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_to_replica: Optional[pulumi.Input[_builtins.bool]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_database: The authentication database to use.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] connect_to_replica: Set to connect to a replica instead of the primary node.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_replica is not None:
            pulumi.set(__self__, "connect_to_replica", connect_to_replica)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @auth_database.setter
    def auth_database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="connectToReplica")
    def connect_to_replica(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to connect to a replica instead of the primary node.
        """
        return pulumi.get(self, "connect_to_replica")

    @connect_to_replica.setter
    def connect_to_replica(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "connect_to_replica", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceMongoShardedClusterArgsDict(TypedDict):
        auth_database: pulumi.Input[_builtins.str]
        """
        The authentication database to use.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMongoShardedClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMongoShardedClusterArgs:
    def __init__(__self__, *,
                 auth_database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_database: The authentication database to use.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "auth_database", auth_database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authDatabase")
    def auth_database(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication database to use.
        """
        return pulumi.get(self, "auth_database")

    @auth_database.setter
    def auth_database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceMtlsMysqlArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate to authenticate TLS connections with.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key to authenticate TLS connections with.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        require_native_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        server_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMtlsMysqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMtlsMysqlArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 require_native_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 server_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_certificate: The certificate to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_key: The key to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.bool] require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @require_native_auth.setter
    def require_native_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_native_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_name", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceMtlsPostgresArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CA to authenticate TLS connections with.
        """
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate to authenticate TLS connections with.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key to authenticate TLS connections with.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        server_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMtlsPostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMtlsPostgresArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 server_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] certificate_authority: The CA to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_certificate: The certificate to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] client_key: The key to authenticate TLS connections with.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] server_name: Server name for TLS verification (unverified by StrongDM if empty)
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CA to authenticate TLS connections with.
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key to authenticate TLS connections with.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Server name for TLS verification (unverified by StrongDM if empty)
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_name", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceMysqlArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        require_native_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceMysqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceMysqlArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 require_native_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.bool] require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @require_native_auth.setter
    def require_native_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_native_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceNeptuneArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceNeptuneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceNeptuneArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceNeptuneIamArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access Key ID to use to authenticate.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Secret Access Key to use to authenticate.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceNeptuneIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceNeptuneIamArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] access_key: The Access Key ID to use to authenticate.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[_builtins.str] secret_access_key: The Secret Access Key to use to authenticate.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access Key ID to use to authenticate.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Secret Access Key to use to authenticate.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceOktaGroupsArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        Represents the Okta Org Client URL
        """
        identity_set_id: pulumi.Input[_builtins.str]
        """
        The ID of the identity set to use for identity connections.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        discovery_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        group_names: NotRequired[pulumi.Input[_builtins.str]]
        """
        comma separated list of group names to filter by. Supports wildcards (*)
        """
        privilege_levels: NotRequired[pulumi.Input[_builtins.str]]
        """
        The privilege levels specify which Groups are managed externally
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceOktaGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceOktaGroupsArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str],
                 identity_set_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 discovery_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 group_names: Optional[pulumi.Input[_builtins.str]] = None,
                 privilege_levels: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] domain: Represents the Okta Org Client URL
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] discovery_enabled: If true, configures discovery of the Okta org to be run from a node.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] group_names: comma separated list of group names to filter by. Supports wildcards (*)
        :param pulumi.Input[_builtins.str] privilege_levels: The privilege levels specify which Groups are managed externally
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "identity_set_id", identity_set_id)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if discovery_enabled is not None:
            pulumi.set(__self__, "discovery_enabled", discovery_enabled)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if group_names is not None:
            pulumi.set(__self__, "group_names", group_names)
        if privilege_levels is not None:
            pulumi.set(__self__, "privilege_levels", privilege_levels)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        Represents the Okta Org Client URL
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="discoveryEnabled")
    def discovery_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, configures discovery of the Okta org to be run from a node.
        """
        return pulumi.get(self, "discovery_enabled")

    @discovery_enabled.setter
    def discovery_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "discovery_enabled", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="groupNames")
    def group_names(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        comma separated list of group names to filter by. Supports wildcards (*)
        """
        return pulumi.get(self, "group_names")

    @group_names.setter
    def group_names(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_names", value)

    @_builtins.property
    @pulumi.getter(name="privilegeLevels")
    def privilege_levels(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The privilege levels specify which Groups are managed externally
        """
        return pulumi.get(self, "privilege_levels")

    @privilege_levels.setter
    def privilege_levels(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "privilege_levels", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceOracleArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceOracleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceOracleArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceOracleNneArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceOracleNneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceOracleNneArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourcePostgresArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourcePostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePostgresArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourcePrestoArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourcePrestoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePrestoArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceRabbitmqAmqp091ArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceRabbitmqAmqp091ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRabbitmqAmqp091Args:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceRawTcpArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceRawTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRawTcpArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceRdpArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        downgrade_nla_connections: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        lock_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceRdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRdpArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 downgrade_nla_connections: Optional[pulumi.Input[_builtins.bool]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 lock_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] downgrade_nla_connections: When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.bool] lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if downgrade_nla_connections is not None:
            pulumi.set(__self__, "downgrade_nla_connections", downgrade_nla_connections)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="downgradeNlaConnections")
    def downgrade_nla_connections(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
        """
        return pulumi.get(self, "downgrade_nla_connections")

    @downgrade_nla_connections.setter
    def downgrade_nla_connections(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "downgrade_nla_connections", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @lock_required.setter
    def lock_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lock_required", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceRdpCertArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        dc_hostnames: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma-separated list of Active Directory Domain Controller hostnames. Required in on-premises AD environments for Kerberos Network Level Authentication (NLA), and for LDAPS SID resolution for strong certificate mapping in full enforcement mode when the identity alias does not specify a SID. Unused for Entra ID.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        lock_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        server_fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fully-qualified DNS name of the target Windows server, including the AD domain. Must match the Service Principal Name (SPN) of the server in AD. Required in on-premises AD environments for Kerberos Network Level Authentication (NLA), unused for Entra ID.
        """
        sid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Windows Security Identifier (SID) of the configured Username, or AD service account if using LDAPS SID resolution. Required in on-premises AD environments for strong certificate mapping in full enforcement mode, unused for Entra ID.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceRdpCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRdpCertArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 dc_hostnames: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 lock_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 server_fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 sid: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] dc_hostnames: Comma-separated list of Active Directory Domain Controller hostnames. Required in on-premises AD environments for Kerberos Network Level Authentication (NLA), and for LDAPS SID resolution for strong certificate mapping in full enforcement mode when the identity alias does not specify a SID. Unused for Entra ID.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.bool] lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] server_fqdn: Fully-qualified DNS name of the target Windows server, including the AD domain. Must match the Service Principal Name (SPN) of the server in AD. Required in on-premises AD environments for Kerberos Network Level Authentication (NLA), unused for Entra ID.
        :param pulumi.Input[_builtins.str] sid: Windows Security Identifier (SID) of the configured Username, or AD service account if using LDAPS SID resolution. Required in on-premises AD environments for strong certificate mapping in full enforcement mode, unused for Entra ID.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if dc_hostnames is not None:
            pulumi.set(__self__, "dc_hostnames", dc_hostnames)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if server_fqdn is not None:
            pulumi.set(__self__, "server_fqdn", server_fqdn)
        if sid is not None:
            pulumi.set(__self__, "sid", sid)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="dcHostnames")
    def dc_hostnames(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma-separated list of Active Directory Domain Controller hostnames. Required in on-premises AD environments for Kerberos Network Level Authentication (NLA), and for LDAPS SID resolution for strong certificate mapping in full enforcement mode when the identity alias does not specify a SID. Unused for Entra ID.
        """
        return pulumi.get(self, "dc_hostnames")

    @dc_hostnames.setter
    def dc_hostnames(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dc_hostnames", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @lock_required.setter
    def lock_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lock_required", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="serverFqdn")
    def server_fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fully-qualified DNS name of the target Windows server, including the AD domain. Must match the Service Principal Name (SPN) of the server in AD. Required in on-premises AD environments for Kerberos Network Level Authentication (NLA), unused for Entra ID.
        """
        return pulumi.get(self, "server_fqdn")

    @server_fqdn.setter
    def server_fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_fqdn", value)

    @_builtins.property
    @pulumi.getter
    def sid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Windows Security Identifier (SID) of the configured Username, or AD service account if using LDAPS SID resolution. Required in on-premises AD environments for strong certificate mapping in full enforcement mode, unused for Entra ID.
        """
        return pulumi.get(self, "sid")

    @sid.setter
    def sid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sid", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceRdsPostgresIamArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_assumption_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceRdsPostgresIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRdsPostgresIamArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_assumption_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @role_assumption_arn.setter
    def role_assumption_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_assumption_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceRedisArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceRedisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRedisArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceRedisClusterArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceRedisClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRedisClusterArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceRedshiftArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceRedshiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRedshiftArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceRedshiftIamArgsDict(TypedDict):
        cluster_id: pulumi.Input[_builtins.str]
        """
        Cluster Identified of Redshift cluster
        """
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_assumption_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceRedshiftIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRedshiftIamArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[_builtins.str],
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_assumption_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: Cluster Identified of Redshift cluster
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[_builtins.str]:
        """
        Cluster Identified of Redshift cluster
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @role_assumption_arn.setter
    def role_assumption_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_assumption_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceRedshiftServerlessIamArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to connect to.
        """
        workgroup: pulumi.Input[_builtins.str]
        """
        Workgroup name in the serverless Redshift
        * single_store:
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        role_assumption_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceRedshiftServerlessIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRedshiftServerlessIamArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 workgroup: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_assumption_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] region: The AWS region to connect to.
        :param pulumi.Input[_builtins.str] workgroup: Workgroup name in the serverless Redshift
               * single_store:
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] role_assumption_arn: If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "workgroup", workgroup)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if role_assumption_arn is not None:
            pulumi.set(__self__, "role_assumption_arn", role_assumption_arn)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to connect to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def workgroup(self) -> pulumi.Input[_builtins.str]:
        """
        Workgroup name in the serverless Redshift
        * single_store:
        """
        return pulumi.get(self, "workgroup")

    @workgroup.setter
    def workgroup(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workgroup", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="roleAssumptionArn")
    def role_assumption_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
        """
        return pulumi.get(self, "role_assumption_arn")

    @role_assumption_arn.setter
    def role_assumption_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_assumption_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceSingleStoreArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        require_native_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        use_azure_single_server_usernames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSingleStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSingleStoreArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 require_native_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_azure_single_server_usernames: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.bool] require_native_auth: Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] use_azure_single_server_usernames: If true, appends the hostname to the username when hitting a database.azure.com address
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if require_native_auth is not None:
            pulumi.set(__self__, "require_native_auth", require_native_auth)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_azure_single_server_usernames is not None:
            pulumi.set(__self__, "use_azure_single_server_usernames", use_azure_single_server_usernames)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="requireNativeAuth")
    def require_native_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
        """
        return pulumi.get(self, "require_native_auth")

    @require_native_auth.setter
    def require_native_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_native_auth", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="useAzureSingleServerUsernames")
    def use_azure_single_server_usernames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, appends the hostname to the username when hitting a database.azure.com address
        """
        return pulumi.get(self, "use_azure_single_server_usernames")

    @use_azure_single_server_usernames.setter
    def use_azure_single_server_usernames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_azure_single_server_usernames", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceSnowflakeArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key used to authenticate with the server.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Schema to use to direct initial requests.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSnowflakeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSnowflakeArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] private_key: The private key used to authenticate with the server.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] schema: The Schema to use to direct initial requests.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceSnowsightArgsDict(TypedDict):
        healthcheck_username: pulumi.Input[_builtins.str]
        """
        The StrongDM user email to use for healthchecks.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        connect_to_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, select the ACS with isDefault=true
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        saml_metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Metadata for your snowflake IDP integration
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    ResourceSnowsightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSnowsightArgs:
    def __init__(__self__, *,
                 healthcheck_username: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_to_default: Optional[pulumi.Input[_builtins.bool]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 saml_metadata: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] healthcheck_username: The StrongDM user email to use for healthchecks.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.bool] connect_to_default: If true, select the ACS with isDefault=true
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] saml_metadata: The Metadata for your snowflake IDP integration
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "healthcheck_username", healthcheck_username)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if connect_to_default is not None:
            pulumi.set(__self__, "connect_to_default", connect_to_default)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if saml_metadata is not None:
            pulumi.set(__self__, "saml_metadata", saml_metadata)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="healthcheckUsername")
    def healthcheck_username(self) -> pulumi.Input[_builtins.str]:
        """
        The StrongDM user email to use for healthchecks.
        """
        return pulumi.get(self, "healthcheck_username")

    @healthcheck_username.setter
    def healthcheck_username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "healthcheck_username", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="connectToDefault")
    def connect_to_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, select the ACS with isDefault=true
        """
        return pulumi.get(self, "connect_to_default")

    @connect_to_default.setter
    def connect_to_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "connect_to_default", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="samlMetadata")
    def saml_metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Metadata for your snowflake IDP integration
        """
        return pulumi.get(self, "saml_metadata")

    @saml_metadata.setter
    def saml_metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "saml_metadata", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ResourceSqlServerArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        allow_deprecated_encryption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Schema to use to direct initial requests.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSqlServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSqlServerArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 allow_deprecated_encryption: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.bool] allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] schema: The Schema to use to direct initial requests.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @allow_deprecated_encryption.setter
    def allow_deprecated_encryption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_deprecated_encryption", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceSqlServerAzureAdArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        allow_deprecated_encryption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Azure AD application (client) ID with which to authenticate.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Schema to use to direct initial requests.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Azure AD client secret (application password) with which to authenticate.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
elif False:
    ResourceSqlServerAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSqlServerAzureAdArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 allow_deprecated_encryption: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.bool] allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] client_id: The Azure AD application (client) ID with which to authenticate.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] schema: The Schema to use to direct initial requests.
        :param pulumi.Input[_builtins.str] secret: The Azure AD client secret (application password) with which to authenticate.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] tenant_id: The Azure AD directory (tenant) ID with which to authenticate.
               * sql_server_kerberos_ad:
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @allow_deprecated_encryption.setter
    def allow_deprecated_encryption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_deprecated_encryption", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Azure AD application (client) ID with which to authenticate.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Azure AD client secret (application password) with which to authenticate.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Azure AD directory (tenant) ID with which to authenticate.
        * sql_server_kerberos_ad:
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ResourceSqlServerKerberosAdArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        server_spn: pulumi.Input[_builtins.str]
        """
        The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        """
        allow_deprecated_encryption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        keytab: NotRequired[pulumi.Input[_builtins.str]]
        """
        The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        """
        krb_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        """
        override_database: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        realm: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Active Directory domain (realm) to which the configured username belongs.
        """
        schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Schema to use to direct initial requests.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSqlServerKerberosAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSqlServerKerberosAdArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 server_spn: pulumi.Input[_builtins.str],
                 allow_deprecated_encryption: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 keytab: Optional[pulumi.Input[_builtins.str]] = None,
                 krb_config: Optional[pulumi.Input[_builtins.str]] = None,
                 override_database: Optional[pulumi.Input[_builtins.bool]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 realm: Optional[pulumi.Input[_builtins.str]] = None,
                 schema: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] server_spn: The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        :param pulumi.Input[_builtins.bool] allow_deprecated_encryption: Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] keytab: The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        :param pulumi.Input[_builtins.str] krb_config: The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        :param pulumi.Input[_builtins.bool] override_database: If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] realm: The Active Directory domain (realm) to which the configured username belongs.
        :param pulumi.Input[_builtins.str] schema: The Schema to use to direct initial requests.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_spn", server_spn)
        if allow_deprecated_encryption is not None:
            pulumi.set(__self__, "allow_deprecated_encryption", allow_deprecated_encryption)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if keytab is not None:
            pulumi.set(__self__, "keytab", keytab)
        if krb_config is not None:
            pulumi.set(__self__, "krb_config", krb_config)
        if override_database is not None:
            pulumi.set(__self__, "override_database", override_database)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverSpn")
    def server_spn(self) -> pulumi.Input[_builtins.str]:
        """
        The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
        """
        return pulumi.get(self, "server_spn")

    @server_spn.setter
    def server_spn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_spn", value)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedEncryption")
    def allow_deprecated_encryption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
        """
        return pulumi.get(self, "allow_deprecated_encryption")

    @allow_deprecated_encryption.setter
    def allow_deprecated_encryption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_deprecated_encryption", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def keytab(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
        """
        return pulumi.get(self, "keytab")

    @keytab.setter
    def keytab(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keytab", value)

    @_builtins.property
    @pulumi.getter(name="krbConfig")
    def krb_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
        """
        return pulumi.get(self, "krb_config")

    @krb_config.setter
    def krb_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "krb_config", value)

    @_builtins.property
    @pulumi.getter(name="overrideDatabase")
    def override_database(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
        """
        return pulumi.get(self, "override_database")

    @override_database.setter
    def override_database(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_database", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def realm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Active Directory domain (realm) to which the configured username belongs.
        """
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "realm", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Schema to use to direct initial requests.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceSshArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        allow_deprecated_key_exchanges: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        key_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        lock_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        port_forwarding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether port forwarding is allowed through this server.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public key to append to a server's authorized keys. This will be generated after resource creation.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSshArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 allow_deprecated_key_exchanges: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 lock_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_forwarding: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.bool] allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] key_type: The key type to use e.g. rsa-2048 or ed25519
        :param pulumi.Input[_builtins.bool] lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param pulumi.Input[_builtins.bool] port_forwarding: Whether port forwarding is allowed through this server.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] public_key: The public key to append to a server's authorized keys. This will be generated after resource creation.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @allow_deprecated_key_exchanges.setter
    def allow_deprecated_key_exchanges(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_deprecated_key_exchanges", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @lock_required.setter
    def lock_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lock_required", value)

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @port_forwarding.setter
    def port_forwarding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "port_forwarding", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public key to append to a server's authorized keys. This will be generated after resource creation.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceSshCertArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        allow_deprecated_key_exchanges: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        key_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        lock_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        port_forwarding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether port forwarding is allowed through this server.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSshCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSshCertArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 allow_deprecated_key_exchanges: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 lock_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_forwarding: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.bool] allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.str] key_type: The key type to use e.g. rsa-2048 or ed25519
        :param pulumi.Input[_builtins.bool] lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param pulumi.Input[_builtins.bool] port_forwarding: Whether port forwarding is allowed through this server.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @allow_deprecated_key_exchanges.setter
    def allow_deprecated_key_exchanges(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_deprecated_key_exchanges", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key type to use e.g. rsa-2048 or ed25519
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @lock_required.setter
    def lock_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lock_required", value)

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @port_forwarding.setter
    def port_forwarding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "port_forwarding", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceSshCustomerKeyArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        allow_deprecated_key_exchanges: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        identity_alias_healthcheck_username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        identity_set_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the identity set to use for identity connections.
        """
        lock_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        port_forwarding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether port forwarding is allowed through this server.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key used to authenticate with the server.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSshCustomerKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSshCustomerKeyArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 allow_deprecated_key_exchanges: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_alias_healthcheck_username: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_set_id: Optional[pulumi.Input[_builtins.str]] = None,
                 lock_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_forwarding: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.bool] allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] identity_alias_healthcheck_username: The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        :param pulumi.Input[_builtins.str] identity_set_id: The ID of the identity set to use for identity connections.
        :param pulumi.Input[_builtins.bool] lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param pulumi.Input[_builtins.bool] port_forwarding: Whether port forwarding is allowed through this server.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] private_key: The private key used to authenticate with the server.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if identity_alias_healthcheck_username is not None:
            pulumi.set(__self__, "identity_alias_healthcheck_username", identity_alias_healthcheck_username)
        if identity_set_id is not None:
            pulumi.set(__self__, "identity_set_id", identity_set_id)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @allow_deprecated_key_exchanges.setter
    def allow_deprecated_key_exchanges(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_deprecated_key_exchanges", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="identityAliasHealthcheckUsername")
    def identity_alias_healthcheck_username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
        """
        return pulumi.get(self, "identity_alias_healthcheck_username")

    @identity_alias_healthcheck_username.setter
    def identity_alias_healthcheck_username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_alias_healthcheck_username", value)

    @_builtins.property
    @pulumi.getter(name="identitySetId")
    def identity_set_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the identity set to use for identity connections.
        """
        return pulumi.get(self, "identity_set_id")

    @identity_set_id.setter
    def identity_set_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_set_id", value)

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @lock_required.setter
    def lock_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lock_required", value)

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @port_forwarding.setter
    def port_forwarding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "port_forwarding", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key used to authenticate with the server.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceSshPasswordArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        allow_deprecated_key_exchanges: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        lock_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port_forwarding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether port forwarding is allowed through this server.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSshPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSshPasswordArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 allow_deprecated_key_exchanges: Optional[pulumi.Input[_builtins.bool]] = None,
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 lock_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port_forwarding: Optional[pulumi.Input[_builtins.bool]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.bool] allow_deprecated_key_exchanges: Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.bool] lock_required: When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.bool] port_forwarding: Whether port forwarding is allowed through this server.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if allow_deprecated_key_exchanges is not None:
            pulumi.set(__self__, "allow_deprecated_key_exchanges", allow_deprecated_key_exchanges)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if lock_required is not None:
            pulumi.set(__self__, "lock_required", lock_required)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port_forwarding is not None:
            pulumi.set(__self__, "port_forwarding", port_forwarding)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="allowDeprecatedKeyExchanges")
    def allow_deprecated_key_exchanges(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
        """
        return pulumi.get(self, "allow_deprecated_key_exchanges")

    @allow_deprecated_key_exchanges.setter
    def allow_deprecated_key_exchanges(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_deprecated_key_exchanges", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter(name="lockRequired")
    def lock_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
        """
        return pulumi.get(self, "lock_required")

    @lock_required.setter
    def lock_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lock_required", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="portForwarding")
    def port_forwarding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether port forwarding is allowed through this server.
        """
        return pulumi.get(self, "port_forwarding")

    @port_forwarding.setter
    def port_forwarding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "port_forwarding", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceSybaseArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSybaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSybaseArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceSybaseIqArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceSybaseIqArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSybaseIqArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceTeradataArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceTeradataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceTeradataArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceTrinoArgsDict(TypedDict):
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, TLS must be used to connect to this resource.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceTrinoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceTrinoArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls_required: If set, TLS must be used to connect to this resource.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls_required is not None:
            pulumi.set(__self__, "tls_required", tls_required)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tlsRequired")
    def tls_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, TLS must be used to connect to this resource.
        """
        return pulumi.get(self, "tls_required")

    @tls_required.setter
    def tls_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_required", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceVerticaArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Resource.
        """
        bind_interface: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        egress_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password to authenticate with.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        port_override: NotRequired[pulumi.Input[_builtins.int]]
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        proxy_cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the proxy cluster for this resource, if any.
        """
        secret_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        subdomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username to authenticate with.
        """
elif False:
    ResourceVerticaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceVerticaArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 bind_interface: Optional[pulumi.Input[_builtins.str]] = None,
                 egress_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy_cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subdomain: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        :param pulumi.Input[_builtins.str] hostname: The host to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Resource.
        :param pulumi.Input[_builtins.str] bind_interface: The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        :param pulumi.Input[_builtins.str] egress_filter: A filter applied to the routing logic to pin datasource to nodes.
        :param pulumi.Input[_builtins.str] password: The password to authenticate with.
        :param pulumi.Input[_builtins.int] port: The port to dial to initiate a connection from the egress node to this resource.
        :param pulumi.Input[_builtins.int] port_override: The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        :param pulumi.Input[_builtins.str] proxy_cluster_id: ID of the proxy cluster for this resource, if any.
        :param pulumi.Input[_builtins.str] secret_store_id: ID of the secret store containing credentials for this resource, if any.
        :param pulumi.Input[_builtins.str] subdomain: DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] username: The username to authenticate with.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        if bind_interface is not None:
            pulumi.set(__self__, "bind_interface", bind_interface)
        if egress_filter is not None:
            pulumi.set(__self__, "egress_filter", egress_filter)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)
        if proxy_cluster_id is not None:
            pulumi.set(__self__, "proxy_cluster_id", proxy_cluster_id)
        if secret_store_id is not None:
            pulumi.set(__self__, "secret_store_id", secret_store_id)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The host to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bindInterface")
    def bind_interface(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
        """
        return pulumi.get(self, "bind_interface")

    @bind_interface.setter
    def bind_interface(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_interface", value)

    @_builtins.property
    @pulumi.getter(name="egressFilter")
    def egress_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the routing logic to pin datasource to nodes.
        """
        return pulumi.get(self, "egress_filter")

    @egress_filter.setter
    def egress_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "egress_filter", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password to authenticate with.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to dial to initiate a connection from the egress node to this resource.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
        """
        return pulumi.get(self, "port_override")

    @port_override.setter
    def port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_override", value)

    @_builtins.property
    @pulumi.getter(name="proxyClusterId")
    def proxy_cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the proxy cluster for this resource, if any.
        """
        return pulumi.get(self, "proxy_cluster_id")

    @proxy_cluster_id.setter
    def proxy_cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the secret store containing credentials for this resource, if any.
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username to authenticate with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class SecretEngineActiveDirectoryArgsDict(TypedDict):
        binddn: pulumi.Input[_builtins.str]
        """
        Distinguished name of object to bind when performing user and group search. Example: cn=vault,ou=Users,dc=example,dc=com
        """
        bindpass: pulumi.Input[_builtins.str]
        """
        Password to use along with binddn when performing user search.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Secret Engine.
        """
        secret_store_id: pulumi.Input[_builtins.str]
        """
        Backing secret store identifier
        """
        secret_store_root_path: pulumi.Input[_builtins.str]
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        url: pulumi.Input[_builtins.str]
        """
        The LDAP server to connect to.
        """
        after_read_ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.
        """
        connection_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
        """
        do_not_validate_timestamps: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true this will prevent password change timestamp validation in Active Directory when validating credentials
        """
        insecure_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, skips LDAP server SSL certificate verification - insecure, use with caution!
        """
        key_rotation_interval_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        An interval of public/private key rotation for secret engine in days
        """
        max_backoff_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will be retried in an increasing intervals until it reaches max_backoff_duration
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public key linked with a secret engine
        """
        request_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout, in seconds, for the connection when making requests against the server before returning back an error.
        """
        start_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, issues a StartTLS command after establishing an unencrypted connection.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        upndomain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain (userPrincipalDomain) used to construct a UPN string for authentication.
        """
        userdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com
        * key_value:
        """
elif False:
    SecretEngineActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretEngineActiveDirectoryArgs:
    def __init__(__self__, *,
                 binddn: pulumi.Input[_builtins.str],
                 bindpass: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 secret_store_id: pulumi.Input[_builtins.str],
                 secret_store_root_path: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 after_read_ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 do_not_validate_timestamps: Optional[pulumi.Input[_builtins.bool]] = None,
                 insecure_tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 key_rotation_interval_days: Optional[pulumi.Input[_builtins.int]] = None,
                 max_backoff_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 request_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 start_tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 upndomain: Optional[pulumi.Input[_builtins.str]] = None,
                 userdn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] binddn: Distinguished name of object to bind when performing user and group search. Example: cn=vault,ou=Users,dc=example,dc=com
        :param pulumi.Input[_builtins.str] bindpass: Password to use along with binddn when performing user search.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Secret Engine.
        :param pulumi.Input[_builtins.str] secret_store_id: Backing secret store identifier
        :param pulumi.Input[_builtins.str] secret_store_root_path: Backing Secret Store root path where managed secrets are going to be stored
        :param pulumi.Input[_builtins.str] url: The LDAP server to connect to.
        :param pulumi.Input[_builtins.str] after_read_ttl: The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        :param pulumi.Input[_builtins.str] certificate: CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.
        :param pulumi.Input[_builtins.int] connection_timeout: Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
        :param pulumi.Input[_builtins.bool] do_not_validate_timestamps: If set to true this will prevent password change timestamp validation in Active Directory when validating credentials
        :param pulumi.Input[_builtins.bool] insecure_tls: If true, skips LDAP server SSL certificate verification - insecure, use with caution!
        :param pulumi.Input[_builtins.int] key_rotation_interval_days: An interval of public/private key rotation for secret engine in days
        :param pulumi.Input[_builtins.str] max_backoff_duration: The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will be retried in an increasing intervals until it reaches max_backoff_duration
        :param pulumi.Input[_builtins.str] public_key: Public key linked with a secret engine
        :param pulumi.Input[_builtins.int] request_timeout: Timeout, in seconds, for the connection when making requests against the server before returning back an error.
        :param pulumi.Input[_builtins.bool] start_tls: If true, issues a StartTLS command after establishing an unencrypted connection.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] ttl: The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        :param pulumi.Input[_builtins.str] upndomain: The domain (userPrincipalDomain) used to construct a UPN string for authentication.
        :param pulumi.Input[_builtins.str] userdn: Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com
               * key_value:
        """
        pulumi.set(__self__, "binddn", binddn)
        pulumi.set(__self__, "bindpass", bindpass)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_store_id", secret_store_id)
        pulumi.set(__self__, "secret_store_root_path", secret_store_root_path)
        pulumi.set(__self__, "url", url)
        if after_read_ttl is not None:
            pulumi.set(__self__, "after_read_ttl", after_read_ttl)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if do_not_validate_timestamps is not None:
            pulumi.set(__self__, "do_not_validate_timestamps", do_not_validate_timestamps)
        if insecure_tls is not None:
            pulumi.set(__self__, "insecure_tls", insecure_tls)
        if key_rotation_interval_days is not None:
            pulumi.set(__self__, "key_rotation_interval_days", key_rotation_interval_days)
        if max_backoff_duration is not None:
            pulumi.set(__self__, "max_backoff_duration", max_backoff_duration)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if start_tls is not None:
            pulumi.set(__self__, "start_tls", start_tls)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if upndomain is not None:
            pulumi.set(__self__, "upndomain", upndomain)
        if userdn is not None:
            pulumi.set(__self__, "userdn", userdn)

    @_builtins.property
    @pulumi.getter
    def binddn(self) -> pulumi.Input[_builtins.str]:
        """
        Distinguished name of object to bind when performing user and group search. Example: cn=vault,ou=Users,dc=example,dc=com
        """
        return pulumi.get(self, "binddn")

    @binddn.setter
    def binddn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "binddn", value)

    @_builtins.property
    @pulumi.getter
    def bindpass(self) -> pulumi.Input[_builtins.str]:
        """
        Password to use along with binddn when performing user search.
        """
        return pulumi.get(self, "bindpass")

    @bindpass.setter
    def bindpass(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bindpass", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Secret Engine.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> pulumi.Input[_builtins.str]:
        """
        Backing secret store identifier
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreRootPath")
    def secret_store_root_path(self) -> pulumi.Input[_builtins.str]:
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        return pulumi.get(self, "secret_store_root_path")

    @secret_store_root_path.setter
    def secret_store_root_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_root_path", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The LDAP server to connect to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="afterReadTtl")
    def after_read_ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        return pulumi.get(self, "after_read_ttl")

    @after_read_ttl.setter
    def after_read_ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "after_read_ttl", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.
        """
        return pulumi.get(self, "connection_timeout")

    @connection_timeout.setter
    def connection_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_timeout", value)

    @_builtins.property
    @pulumi.getter(name="doNotValidateTimestamps")
    def do_not_validate_timestamps(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true this will prevent password change timestamp validation in Active Directory when validating credentials
        """
        return pulumi.get(self, "do_not_validate_timestamps")

    @do_not_validate_timestamps.setter
    def do_not_validate_timestamps(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "do_not_validate_timestamps", value)

    @_builtins.property
    @pulumi.getter(name="insecureTls")
    def insecure_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, skips LDAP server SSL certificate verification - insecure, use with caution!
        """
        return pulumi.get(self, "insecure_tls")

    @insecure_tls.setter
    def insecure_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure_tls", value)

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalDays")
    def key_rotation_interval_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        An interval of public/private key rotation for secret engine in days
        """
        return pulumi.get(self, "key_rotation_interval_days")

    @key_rotation_interval_days.setter
    def key_rotation_interval_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_rotation_interval_days", value)

    @_builtins.property
    @pulumi.getter(name="maxBackoffDuration")
    def max_backoff_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will be retried in an increasing intervals until it reaches max_backoff_duration
        """
        return pulumi.get(self, "max_backoff_duration")

    @max_backoff_duration.setter
    def max_backoff_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_backoff_duration", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public key linked with a secret engine
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout, in seconds, for the connection when making requests against the server before returning back an error.
        """
        return pulumi.get(self, "request_timeout")

    @request_timeout.setter
    def request_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_timeout", value)

    @_builtins.property
    @pulumi.getter(name="startTls")
    def start_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, issues a StartTLS command after establishing an unencrypted connection.
        """
        return pulumi.get(self, "start_tls")

    @start_tls.setter
    def start_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "start_tls", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def upndomain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain (userPrincipalDomain) used to construct a UPN string for authentication.
        """
        return pulumi.get(self, "upndomain")

    @upndomain.setter
    def upndomain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upndomain", value)

    @_builtins.property
    @pulumi.getter
    def userdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com
        * key_value:
        """
        return pulumi.get(self, "userdn")

    @userdn.setter
    def userdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "userdn", value)


if not MYPY:
    class SecretEngineKeyValueArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Secret Engine.
        """
        secret_store_id: pulumi.Input[_builtins.str]
        """
        Backing secret store identifier
        """
        secret_store_root_path: pulumi.Input[_builtins.str]
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        key_rotation_interval_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        An interval of public/private key rotation for secret engine in days
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public key linked with a secret engine
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretEngineKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretEngineKeyValueArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 secret_store_id: pulumi.Input[_builtins.str],
                 secret_store_root_path: pulumi.Input[_builtins.str],
                 key_rotation_interval_days: Optional[pulumi.Input[_builtins.int]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Secret Engine.
        :param pulumi.Input[_builtins.str] secret_store_id: Backing secret store identifier
        :param pulumi.Input[_builtins.str] secret_store_root_path: Backing Secret Store root path where managed secrets are going to be stored
        :param pulumi.Input[_builtins.int] key_rotation_interval_days: An interval of public/private key rotation for secret engine in days
        :param pulumi.Input[_builtins.str] public_key: Public key linked with a secret engine
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_store_id", secret_store_id)
        pulumi.set(__self__, "secret_store_root_path", secret_store_root_path)
        if key_rotation_interval_days is not None:
            pulumi.set(__self__, "key_rotation_interval_days", key_rotation_interval_days)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Secret Engine.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> pulumi.Input[_builtins.str]:
        """
        Backing secret store identifier
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreRootPath")
    def secret_store_root_path(self) -> pulumi.Input[_builtins.str]:
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        return pulumi.get(self, "secret_store_root_path")

    @secret_store_root_path.setter
    def secret_store_root_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_root_path", value)

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalDays")
    def key_rotation_interval_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        An interval of public/private key rotation for secret engine in days
        """
        return pulumi.get(self, "key_rotation_interval_days")

    @key_rotation_interval_days.setter
    def key_rotation_interval_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_rotation_interval_days", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public key linked with a secret engine
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretEngineMysqlSecretEngineArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        Database is the database to verify credential against.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        Hostname is the hostname or IP address of the SQL Server.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Secret Engine.
        """
        password: pulumi.Input[_builtins.str]
        """
        Password is the password to connect to the SQL Server server.
        """
        port: pulumi.Input[_builtins.int]
        """
        Port is the port number of the SQL Server server.
        """
        secret_store_id: pulumi.Input[_builtins.str]
        """
        Backing secret store identifier
        """
        secret_store_root_path: pulumi.Input[_builtins.str]
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        username: pulumi.Input[_builtins.str]
        """
        Username is the username to connect to the SQL Server.
        """
        after_read_ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        key_rotation_interval_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        An interval of public/private key rotation for secret engine in days
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public key linked with a secret engine
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        TLS enables TLS/SSL when connecting to the SQL Server server.
        """
        tls_skip_verify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        TLS disable certificate verification
        """
        ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
elif False:
    SecretEngineMysqlSecretEngineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretEngineMysqlSecretEngineArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 secret_store_id: pulumi.Input[_builtins.str],
                 secret_store_root_path: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 after_read_ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 key_rotation_interval_days: Optional[pulumi.Input[_builtins.int]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 tls_skip_verify: Optional[pulumi.Input[_builtins.bool]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: Database is the database to verify credential against.
        :param pulumi.Input[_builtins.str] hostname: Hostname is the hostname or IP address of the SQL Server.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Secret Engine.
        :param pulumi.Input[_builtins.str] password: Password is the password to connect to the SQL Server server.
        :param pulumi.Input[_builtins.int] port: Port is the port number of the SQL Server server.
        :param pulumi.Input[_builtins.str] secret_store_id: Backing secret store identifier
        :param pulumi.Input[_builtins.str] secret_store_root_path: Backing Secret Store root path where managed secrets are going to be stored
        :param pulumi.Input[_builtins.str] username: Username is the username to connect to the SQL Server.
        :param pulumi.Input[_builtins.str] after_read_ttl: The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        :param pulumi.Input[_builtins.int] key_rotation_interval_days: An interval of public/private key rotation for secret engine in days
        :param pulumi.Input[_builtins.str] public_key: Public key linked with a secret engine
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls: TLS enables TLS/SSL when connecting to the SQL Server server.
        :param pulumi.Input[_builtins.bool] tls_skip_verify: TLS disable certificate verification
        :param pulumi.Input[_builtins.str] ttl: The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "secret_store_id", secret_store_id)
        pulumi.set(__self__, "secret_store_root_path", secret_store_root_path)
        pulumi.set(__self__, "username", username)
        if after_read_ttl is not None:
            pulumi.set(__self__, "after_read_ttl", after_read_ttl)
        if key_rotation_interval_days is not None:
            pulumi.set(__self__, "key_rotation_interval_days", key_rotation_interval_days)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        Database is the database to verify credential against.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        Hostname is the hostname or IP address of the SQL Server.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Secret Engine.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password is the password to connect to the SQL Server server.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port is the port number of the SQL Server server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> pulumi.Input[_builtins.str]:
        """
        Backing secret store identifier
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreRootPath")
    def secret_store_root_path(self) -> pulumi.Input[_builtins.str]:
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        return pulumi.get(self, "secret_store_root_path")

    @secret_store_root_path.setter
    def secret_store_root_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_root_path", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username is the username to connect to the SQL Server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="afterReadTtl")
    def after_read_ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        return pulumi.get(self, "after_read_ttl")

    @after_read_ttl.setter
    def after_read_ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "after_read_ttl", value)

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalDays")
    def key_rotation_interval_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        An interval of public/private key rotation for secret engine in days
        """
        return pulumi.get(self, "key_rotation_interval_days")

    @key_rotation_interval_days.setter
    def key_rotation_interval_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_rotation_interval_days", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public key linked with a secret engine
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        TLS enables TLS/SSL when connecting to the SQL Server server.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls", value)

    @_builtins.property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        TLS disable certificate verification
        """
        return pulumi.get(self, "tls_skip_verify")

    @tls_skip_verify.setter
    def tls_skip_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_skip_verify", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class SecretEnginePostgresSecretEngineArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        Database is the database to verify credential against.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        Hostname is the hostname or IP address of the SQL Server.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Secret Engine.
        """
        password: pulumi.Input[_builtins.str]
        """
        Password is the password to connect to the SQL Server server.
        """
        port: pulumi.Input[_builtins.int]
        """
        Port is the port number of the SQL Server server.
        """
        secret_store_id: pulumi.Input[_builtins.str]
        """
        Backing secret store identifier
        """
        secret_store_root_path: pulumi.Input[_builtins.str]
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        username: pulumi.Input[_builtins.str]
        """
        Username is the username to connect to the SQL Server.
        """
        after_read_ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        key_rotation_interval_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        An interval of public/private key rotation for secret engine in days
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public key linked with a secret engine
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        TLS enables TLS/SSL when connecting to the SQL Server server.
        """
        ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
elif False:
    SecretEnginePostgresSecretEngineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretEnginePostgresSecretEngineArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 secret_store_id: pulumi.Input[_builtins.str],
                 secret_store_root_path: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 after_read_ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 key_rotation_interval_days: Optional[pulumi.Input[_builtins.int]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: Database is the database to verify credential against.
        :param pulumi.Input[_builtins.str] hostname: Hostname is the hostname or IP address of the SQL Server.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Secret Engine.
        :param pulumi.Input[_builtins.str] password: Password is the password to connect to the SQL Server server.
        :param pulumi.Input[_builtins.int] port: Port is the port number of the SQL Server server.
        :param pulumi.Input[_builtins.str] secret_store_id: Backing secret store identifier
        :param pulumi.Input[_builtins.str] secret_store_root_path: Backing Secret Store root path where managed secrets are going to be stored
        :param pulumi.Input[_builtins.str] username: Username is the username to connect to the SQL Server.
        :param pulumi.Input[_builtins.str] after_read_ttl: The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        :param pulumi.Input[_builtins.int] key_rotation_interval_days: An interval of public/private key rotation for secret engine in days
        :param pulumi.Input[_builtins.str] public_key: Public key linked with a secret engine
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls: TLS enables TLS/SSL when connecting to the SQL Server server.
        :param pulumi.Input[_builtins.str] ttl: The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "secret_store_id", secret_store_id)
        pulumi.set(__self__, "secret_store_root_path", secret_store_root_path)
        pulumi.set(__self__, "username", username)
        if after_read_ttl is not None:
            pulumi.set(__self__, "after_read_ttl", after_read_ttl)
        if key_rotation_interval_days is not None:
            pulumi.set(__self__, "key_rotation_interval_days", key_rotation_interval_days)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        Database is the database to verify credential against.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        Hostname is the hostname or IP address of the SQL Server.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Secret Engine.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password is the password to connect to the SQL Server server.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port is the port number of the SQL Server server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> pulumi.Input[_builtins.str]:
        """
        Backing secret store identifier
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreRootPath")
    def secret_store_root_path(self) -> pulumi.Input[_builtins.str]:
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        return pulumi.get(self, "secret_store_root_path")

    @secret_store_root_path.setter
    def secret_store_root_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_root_path", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username is the username to connect to the SQL Server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="afterReadTtl")
    def after_read_ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        return pulumi.get(self, "after_read_ttl")

    @after_read_ttl.setter
    def after_read_ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "after_read_ttl", value)

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalDays")
    def key_rotation_interval_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        An interval of public/private key rotation for secret engine in days
        """
        return pulumi.get(self, "key_rotation_interval_days")

    @key_rotation_interval_days.setter
    def key_rotation_interval_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_rotation_interval_days", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public key linked with a secret engine
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        TLS enables TLS/SSL when connecting to the SQL Server server.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class SecretEngineSqlserverSecretEngineArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        Database is the database to verify credential against.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        Hostname is the hostname or IP address of the SQL Server.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the Secret Engine.
        """
        password: pulumi.Input[_builtins.str]
        """
        Password is the password to connect to the SQL Server server.
        """
        port: pulumi.Input[_builtins.int]
        """
        Port is the port number of the SQL Server server.
        """
        secret_store_id: pulumi.Input[_builtins.str]
        """
        Backing secret store identifier
        """
        secret_store_root_path: pulumi.Input[_builtins.str]
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        username: pulumi.Input[_builtins.str]
        """
        Username is the username to connect to the SQL Server.
        """
        after_read_ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        key_rotation_interval_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        An interval of public/private key rotation for secret engine in days
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public key linked with a secret engine
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        TLS enables TLS/SSL when connecting to the SQL Server server.
        """
        tls_skip_verify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        TLS disable certificate verification
        """
        ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
elif False:
    SecretEngineSqlserverSecretEngineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretEngineSqlserverSecretEngineArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 secret_store_id: pulumi.Input[_builtins.str],
                 secret_store_root_path: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 after_read_ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 key_rotation_interval_days: Optional[pulumi.Input[_builtins.int]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 tls_skip_verify: Optional[pulumi.Input[_builtins.bool]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database: Database is the database to verify credential against.
        :param pulumi.Input[_builtins.str] hostname: Hostname is the hostname or IP address of the SQL Server.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the Secret Engine.
        :param pulumi.Input[_builtins.str] password: Password is the password to connect to the SQL Server server.
        :param pulumi.Input[_builtins.int] port: Port is the port number of the SQL Server server.
        :param pulumi.Input[_builtins.str] secret_store_id: Backing secret store identifier
        :param pulumi.Input[_builtins.str] secret_store_root_path: Backing Secret Store root path where managed secrets are going to be stored
        :param pulumi.Input[_builtins.str] username: Username is the username to connect to the SQL Server.
        :param pulumi.Input[_builtins.str] after_read_ttl: The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        :param pulumi.Input[_builtins.int] key_rotation_interval_days: An interval of public/private key rotation for secret engine in days
        :param pulumi.Input[_builtins.str] public_key: Public key linked with a secret engine
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.bool] tls: TLS enables TLS/SSL when connecting to the SQL Server server.
        :param pulumi.Input[_builtins.bool] tls_skip_verify: TLS disable certificate verification
        :param pulumi.Input[_builtins.str] ttl: The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "secret_store_id", secret_store_id)
        pulumi.set(__self__, "secret_store_root_path", secret_store_root_path)
        pulumi.set(__self__, "username", username)
        if after_read_ttl is not None:
            pulumi.set(__self__, "after_read_ttl", after_read_ttl)
        if key_rotation_interval_days is not None:
            pulumi.set(__self__, "key_rotation_interval_days", key_rotation_interval_days)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        Database is the database to verify credential against.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        Hostname is the hostname or IP address of the SQL Server.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the Secret Engine.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password is the password to connect to the SQL Server server.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port is the port number of the SQL Server server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreId")
    def secret_store_id(self) -> pulumi.Input[_builtins.str]:
        """
        Backing secret store identifier
        """
        return pulumi.get(self, "secret_store_id")

    @secret_store_id.setter
    def secret_store_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_id", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreRootPath")
    def secret_store_root_path(self) -> pulumi.Input[_builtins.str]:
        """
        Backing Secret Store root path where managed secrets are going to be stored
        """
        return pulumi.get(self, "secret_store_root_path")

    @secret_store_root_path.setter
    def secret_store_root_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_store_root_path", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username is the username to connect to the SQL Server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="afterReadTtl")
    def after_read_ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default time-to-live duration of the password after it's read. Once the ttl has passed, a password will be rotated.
        """
        return pulumi.get(self, "after_read_ttl")

    @after_read_ttl.setter
    def after_read_ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "after_read_ttl", value)

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalDays")
    def key_rotation_interval_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        An interval of public/private key rotation for secret engine in days
        """
        return pulumi.get(self, "key_rotation_interval_days")

    @key_rotation_interval_days.setter
    def key_rotation_interval_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_rotation_interval_days", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public key linked with a secret engine
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        TLS enables TLS/SSL when connecting to the SQL Server server.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls", value)

    @_builtins.property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        TLS disable certificate verification
        """
        return pulumi.get(self, "tls_skip_verify")

    @tls_skip_verify.setter
    def tls_skip_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_skip_verify", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default password time-to-live duration. Once the ttl has passed, a password will be rotated the next time it's requested.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class SecretStoreActiveDirectoryStoreArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreActiveDirectoryStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreActiveDirectoryStoreArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreAwsArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to target e.g. us-east-1
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role to assume after logging in.
        """
        role_external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreAwsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] region: The AWS region to target e.g. us-east-1
        :param pulumi.Input[_builtins.str] role_arn: The role to assume after logging in.
        :param pulumi.Input[_builtins.str] role_external_id: The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if role_external_id is not None:
            pulumi.set(__self__, "role_external_id", role_external_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role to assume after logging in.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleExternalId")
    def role_external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
        """
        return pulumi.get(self, "role_external_id")

    @role_external_id.setter
    def role_external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_external_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreAwsCertX509ArgsDict(TypedDict):
        ca_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the CA in AWS Private CA
        """
        certificate_template_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        """
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to target e.g. us-east-1
        """
        signing_algo: pulumi.Input[_builtins.str]
        """
        The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreAwsCertX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreAwsCertX509Args:
    def __init__(__self__, *,
                 ca_arn: pulumi.Input[_builtins.str],
                 certificate_template_arn: pulumi.Input[_builtins.str],
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 signing_algo: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] ca_arn: The ARN of the CA in AWS Private CA
        :param pulumi.Input[_builtins.str] certificate_template_arn: The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] region: The AWS region to target e.g. us-east-1
        :param pulumi.Input[_builtins.str] signing_algo: The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "ca_arn", ca_arn)
        pulumi.set(__self__, "certificate_template_arn", certificate_template_arn)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "signing_algo", signing_algo)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caArn")
    def ca_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the CA in AWS Private CA
        """
        return pulumi.get(self, "ca_arn")

    @ca_arn.setter
    def ca_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ca_arn", value)

    @_builtins.property
    @pulumi.getter(name="certificateTemplateArn")
    def certificate_template_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
        """
        return pulumi.get(self, "certificate_template_arn")

    @certificate_template_arn.setter
    def certificate_template_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_template_arn", value)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to target e.g. us-east-1
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="signingAlgo")
    def signing_algo(self) -> pulumi.Input[_builtins.str]:
        """
        The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
        """
        return pulumi.get(self, "signing_algo")

    @signing_algo.setter
    def signing_algo(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_algo", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreAzureStoreArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        vault_uri: pulumi.Input[_builtins.str]
        """
        The URI of the key vault to target e.g. https://myvault.vault.azure.net
        * cyberark_conjur:
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreAzureStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreAzureStoreArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 vault_uri: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] vault_uri: The URI of the key vault to target e.g. https://myvault.vault.azure.net
               * cyberark_conjur:
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vault_uri", vault_uri)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The URI of the key vault to target e.g. https://myvault.vault.azure.net
        * cyberark_conjur:
        """
        return pulumi.get(self, "vault_uri")

    @vault_uri.setter
    def vault_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vault_uri", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreCyberarkConjurArgsDict(TypedDict):
        app_url: pulumi.Input[_builtins.str]
        """
        The URL of the Cyberark instance
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreCyberarkConjurArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreCyberarkConjurArgs:
    def __init__(__self__, *,
                 app_url: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] app_url: The URL of the Cyberark instance
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "app_url", app_url)
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @app_url.setter
    def app_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_url", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreCyberarkPamArgsDict(TypedDict):
        app_url: pulumi.Input[_builtins.str]
        """
        The URL of the Cyberark instance
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreCyberarkPamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreCyberarkPamArgs:
    def __init__(__self__, *,
                 app_url: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] app_url: The URL of the Cyberark instance
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "app_url", app_url)
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @app_url.setter
    def app_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_url", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreCyberarkPamExperimentalArgsDict(TypedDict):
        app_url: pulumi.Input[_builtins.str]
        """
        The URL of the Cyberark instance
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreCyberarkPamExperimentalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreCyberarkPamExperimentalArgs:
    def __init__(__self__, *,
                 app_url: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] app_url: The URL of the Cyberark instance
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "app_url", app_url)
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Cyberark instance
        """
        return pulumi.get(self, "app_url")

    @app_url.setter
    def app_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_url", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreDelineaStoreArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the Delinea instance
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
        tenant_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tenant name to target
        * gcp_store:
        """
elif False:
    SecretStoreDelineaStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreDelineaStoreArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 server_url: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tenant_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_url: The URL of the Delinea instance
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        :param pulumi.Input[_builtins.str] tenant_name: The tenant name to target
               * gcp_store:
        """
        pulumi.set(__self__, "name", name)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the Delinea instance
        """
        return pulumi.get(self, "server_url")

    @server_url.setter
    def server_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_url", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tenant name to target
        * gcp_store:
        """
        return pulumi.get(self, "tenant_name")

    @tenant_name.setter
    def tenant_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_name", value)


if not MYPY:
    class SecretStoreGcpCertX509StoreArgsDict(TypedDict):
        ca_pool_id: pulumi.Input[_builtins.str]
        """
        The ID of the target CA pool
        """
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        location: pulumi.Input[_builtins.str]
        """
        The Region for the CA in GCP format e.g. us-west1
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        project_id: pulumi.Input[_builtins.str]
        """
        The GCP project ID to target.
        """
        ca_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the target CA
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreGcpCertX509StoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreGcpCertX509StoreArgs:
    def __init__(__self__, *,
                 ca_pool_id: pulumi.Input[_builtins.str],
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 location: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 ca_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] ca_pool_id: The ID of the target CA pool
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] location: The Region for the CA in GCP format e.g. us-west1
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] project_id: The GCP project ID to target.
        :param pulumi.Input[_builtins.str] ca_id: The ID of the target CA
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "ca_pool_id", ca_pool_id)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if ca_id is not None:
            pulumi.set(__self__, "ca_id", ca_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="caPoolId")
    def ca_pool_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the target CA pool
        """
        return pulumi.get(self, "ca_pool_id")

    @ca_pool_id.setter
    def ca_pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ca_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        """
        The Region for the CA in GCP format e.g. us-west1
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="caId")
    def ca_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the target CA
        """
        return pulumi.get(self, "ca_id")

    @ca_id.setter
    def ca_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreGcpStoreArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        project_id: pulumi.Input[_builtins.str]
        """
        The GCP project ID to target.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreGcpStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreGcpStoreArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] project_id: The GCP project ID to target.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The GCP project ID to target.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreKeyfactorSshStoreArgsDict(TypedDict):
        certificate_file_path: pulumi.Input[_builtins.str]
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        default_certificate_authority_name: pulumi.Input[_builtins.str]
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        default_certificate_profile_name: pulumi.Input[_builtins.str]
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        default_end_entity_profile_name: pulumi.Input[_builtins.str]
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        ca_file_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        enrollment_code_env_var: NotRequired[pulumi.Input[_builtins.str]]
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        enrollment_username_env_var: NotRequired[pulumi.Input[_builtins.str]]
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        key_file_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreKeyfactorSshStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreKeyfactorSshStoreArgs:
    def __init__(__self__, *,
                 certificate_file_path: pulumi.Input[_builtins.str],
                 default_certificate_authority_name: pulumi.Input[_builtins.str],
                 default_certificate_profile_name: pulumi.Input[_builtins.str],
                 default_end_entity_profile_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 ca_file_path: Optional[pulumi.Input[_builtins.str]] = None,
                 enrollment_code_env_var: Optional[pulumi.Input[_builtins.str]] = None,
                 enrollment_username_env_var: Optional[pulumi.Input[_builtins.str]] = None,
                 key_file_path: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param pulumi.Input[_builtins.str] default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param pulumi.Input[_builtins.str] default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param pulumi.Input[_builtins.str] default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param pulumi.Input[_builtins.str] enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param pulumi.Input[_builtins.str] enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param pulumi.Input[_builtins.str] key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> pulumi.Input[_builtins.str]:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @certificate_file_path.setter
    def certificate_file_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_file_path", value)

    @_builtins.property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @default_certificate_authority_name.setter
    def default_certificate_authority_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_certificate_authority_name", value)

    @_builtins.property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @default_certificate_profile_name.setter
    def default_certificate_profile_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_certificate_profile_name", value)

    @_builtins.property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> pulumi.Input[_builtins.str]:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @default_end_entity_profile_name.setter
    def default_end_entity_profile_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_end_entity_profile_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @ca_file_path.setter
    def ca_file_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_file_path", value)

    @_builtins.property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @enrollment_code_env_var.setter
    def enrollment_code_env_var(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enrollment_code_env_var", value)

    @_builtins.property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @enrollment_username_env_var.setter
    def enrollment_username_env_var(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enrollment_username_env_var", value)

    @_builtins.property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @key_file_path.setter
    def key_file_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_file_path", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreKeyfactorX509StoreArgsDict(TypedDict):
        certificate_file_path: pulumi.Input[_builtins.str]
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        default_certificate_authority_name: pulumi.Input[_builtins.str]
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        default_certificate_profile_name: pulumi.Input[_builtins.str]
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        default_end_entity_profile_name: pulumi.Input[_builtins.str]
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        ca_file_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        enrollment_code_env_var: NotRequired[pulumi.Input[_builtins.str]]
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        enrollment_username_env_var: NotRequired[pulumi.Input[_builtins.str]]
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        key_file_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreKeyfactorX509StoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreKeyfactorX509StoreArgs:
    def __init__(__self__, *,
                 certificate_file_path: pulumi.Input[_builtins.str],
                 default_certificate_authority_name: pulumi.Input[_builtins.str],
                 default_certificate_profile_name: pulumi.Input[_builtins.str],
                 default_end_entity_profile_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 ca_file_path: Optional[pulumi.Input[_builtins.str]] = None,
                 enrollment_code_env_var: Optional[pulumi.Input[_builtins.str]] = None,
                 enrollment_username_env_var: Optional[pulumi.Input[_builtins.str]] = None,
                 key_file_path: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_file_path: Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        :param pulumi.Input[_builtins.str] default_certificate_authority_name: Name of EJBCA certificate authority that will enroll CSR.
        :param pulumi.Input[_builtins.str] default_certificate_profile_name: Certificate profile name that EJBCA will enroll the CSR with.
        :param pulumi.Input[_builtins.str] default_end_entity_profile_name: End entity profile that EJBCA will enroll the CSR with.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] ca_file_path: Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        :param pulumi.Input[_builtins.str] enrollment_code_env_var: code used by EJBCA during enrollment. May be left blank if no code is required.
        :param pulumi.Input[_builtins.str] enrollment_username_env_var: username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        :param pulumi.Input[_builtins.str] key_file_path: Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "certificate_file_path", certificate_file_path)
        pulumi.set(__self__, "default_certificate_authority_name", default_certificate_authority_name)
        pulumi.set(__self__, "default_certificate_profile_name", default_certificate_profile_name)
        pulumi.set(__self__, "default_end_entity_profile_name", default_end_entity_profile_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if ca_file_path is not None:
            pulumi.set(__self__, "ca_file_path", ca_file_path)
        if enrollment_code_env_var is not None:
            pulumi.set(__self__, "enrollment_code_env_var", enrollment_code_env_var)
        if enrollment_username_env_var is not None:
            pulumi.set(__self__, "enrollment_username_env_var", enrollment_username_env_var)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="certificateFilePath")
    def certificate_file_path(self) -> pulumi.Input[_builtins.str]:
        """
        Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
        """
        return pulumi.get(self, "certificate_file_path")

    @certificate_file_path.setter
    def certificate_file_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_file_path", value)

    @_builtins.property
    @pulumi.getter(name="defaultCertificateAuthorityName")
    def default_certificate_authority_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of EJBCA certificate authority that will enroll CSR.
        """
        return pulumi.get(self, "default_certificate_authority_name")

    @default_certificate_authority_name.setter
    def default_certificate_authority_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_certificate_authority_name", value)

    @_builtins.property
    @pulumi.getter(name="defaultCertificateProfileName")
    def default_certificate_profile_name(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate profile name that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_certificate_profile_name")

    @default_certificate_profile_name.setter
    def default_certificate_profile_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_certificate_profile_name", value)

    @_builtins.property
    @pulumi.getter(name="defaultEndEntityProfileName")
    def default_end_entity_profile_name(self) -> pulumi.Input[_builtins.str]:
        """
        End entity profile that EJBCA will enroll the CSR with.
        """
        return pulumi.get(self, "default_end_entity_profile_name")

    @default_end_entity_profile_name.setter
    def default_end_entity_profile_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_end_entity_profile_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="caFilePath")
    def ca_file_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
        """
        return pulumi.get(self, "ca_file_path")

    @ca_file_path.setter
    def ca_file_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_file_path", value)

    @_builtins.property
    @pulumi.getter(name="enrollmentCodeEnvVar")
    def enrollment_code_env_var(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        code used by EJBCA during enrollment. May be left blank if no code is required.
        """
        return pulumi.get(self, "enrollment_code_env_var")

    @enrollment_code_env_var.setter
    def enrollment_code_env_var(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enrollment_code_env_var", value)

    @_builtins.property
    @pulumi.getter(name="enrollmentUsernameEnvVar")
    def enrollment_username_env_var(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
        """
        return pulumi.get(self, "enrollment_username_env_var")

    @enrollment_username_env_var.setter
    def enrollment_username_env_var(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enrollment_username_env_var", value)

    @_builtins.property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
        """
        return pulumi.get(self, "key_file_path")

    @key_file_path.setter
    def key_file_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_file_path", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreStrongVaultArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreStrongVaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreStrongVaultArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultApproleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultApproleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultApproleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultApproleCertSshArgsDict(TypedDict):
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        ssh_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the SSH engine configured with the desired CA
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultApproleCertSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultApproleCertSshArgs:
    def __init__(__self__, *,
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 ssh_mount_point: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @ssh_mount_point.setter
    def ssh_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ssh_mount_point", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultApproleCertX509ArgsDict(TypedDict):
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        pki_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the PKI engine configured with the desired CA
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultApproleCertX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultApproleCertX509Args:
    def __init__(__self__, *,
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 pki_mount_point: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @pki_mount_point.setter
    def pki_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pki_mount_point", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultAwsEc2ArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultAwsEc2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultAwsEc2Args:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultAwsEc2CertSshArgsDict(TypedDict):
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        ssh_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the SSH engine configured with the desired CA
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultAwsEc2CertSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultAwsEc2CertSshArgs:
    def __init__(__self__, *,
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 ssh_mount_point: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @ssh_mount_point.setter
    def ssh_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ssh_mount_point", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultAwsEc2CertX509ArgsDict(TypedDict):
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        pki_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the PKI engine configured with the desired CA
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultAwsEc2CertX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultAwsEc2CertX509Args:
    def __init__(__self__, *,
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 pki_mount_point: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @pki_mount_point.setter
    def pki_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pki_mount_point", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultAwsIamArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultAwsIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultAwsIamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultAwsIamCertSshArgsDict(TypedDict):
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        ssh_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the SSH engine configured with the desired CA
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultAwsIamCertSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultAwsIamCertSshArgs:
    def __init__(__self__, *,
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 ssh_mount_point: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @ssh_mount_point.setter
    def ssh_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ssh_mount_point", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultAwsIamCertX509ArgsDict(TypedDict):
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        pki_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the PKI engine configured with the desired CA
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultAwsIamCertX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultAwsIamCertX509Args:
    def __init__(__self__, *,
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 pki_mount_point: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @pki_mount_point.setter
    def pki_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pki_mount_point", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultTlsArgsDict(TypedDict):
        client_cert_path: pulumi.Input[_builtins.str]
        """
        A path to a client certificate file accessible by a Node
        """
        client_key_path: pulumi.Input[_builtins.str]
        """
        A path to a client key file accessible by a Node
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        ca_cert_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        A path to a CA file accessible by a Node
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultTlsArgs:
    def __init__(__self__, *,
                 client_cert_path: pulumi.Input[_builtins.str],
                 client_key_path: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 ca_cert_path: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_cert_path: A path to a client certificate file accessible by a Node
        :param pulumi.Input[_builtins.str] client_key_path: A path to a client key file accessible by a Node
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] ca_cert_path: A path to a CA file accessible by a Node
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "client_cert_path", client_cert_path)
        pulumi.set(__self__, "client_key_path", client_key_path)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> pulumi.Input[_builtins.str]:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @client_cert_path.setter
    def client_cert_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_cert_path", value)

    @_builtins.property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> pulumi.Input[_builtins.str]:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @client_key_path.setter
    def client_key_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_key_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @ca_cert_path.setter
    def ca_cert_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_cert_path", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultTlsCertSshArgsDict(TypedDict):
        client_cert_path: pulumi.Input[_builtins.str]
        """
        A path to a client certificate file accessible by a Node
        """
        client_key_path: pulumi.Input[_builtins.str]
        """
        A path to a client key file accessible by a Node
        """
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        ssh_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the SSH engine configured with the desired CA
        """
        ca_cert_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        A path to a CA file accessible by a Node
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultTlsCertSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultTlsCertSshArgs:
    def __init__(__self__, *,
                 client_cert_path: pulumi.Input[_builtins.str],
                 client_key_path: pulumi.Input[_builtins.str],
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 ssh_mount_point: pulumi.Input[_builtins.str],
                 ca_cert_path: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_cert_path: A path to a client certificate file accessible by a Node
        :param pulumi.Input[_builtins.str] client_key_path: A path to a client key file accessible by a Node
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param pulumi.Input[_builtins.str] ca_cert_path: A path to a CA file accessible by a Node
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "client_cert_path", client_cert_path)
        pulumi.set(__self__, "client_key_path", client_key_path)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> pulumi.Input[_builtins.str]:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @client_cert_path.setter
    def client_cert_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_cert_path", value)

    @_builtins.property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> pulumi.Input[_builtins.str]:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @client_key_path.setter
    def client_key_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_key_path", value)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @ssh_mount_point.setter
    def ssh_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ssh_mount_point", value)

    @_builtins.property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @ca_cert_path.setter
    def ca_cert_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_cert_path", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultTlsCertX509ArgsDict(TypedDict):
        client_cert_path: pulumi.Input[_builtins.str]
        """
        A path to a client certificate file accessible by a Node
        """
        client_key_path: pulumi.Input[_builtins.str]
        """
        A path to a client key file accessible by a Node
        """
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        pki_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the PKI engine configured with the desired CA
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        ca_cert_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        A path to a CA file accessible by a Node
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultTlsCertX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultTlsCertX509Args:
    def __init__(__self__, *,
                 client_cert_path: pulumi.Input[_builtins.str],
                 client_key_path: pulumi.Input[_builtins.str],
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 pki_mount_point: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 ca_cert_path: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_cert_path: A path to a client certificate file accessible by a Node
        :param pulumi.Input[_builtins.str] client_key_path: A path to a client key file accessible by a Node
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] ca_cert_path: A path to a CA file accessible by a Node
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "client_cert_path", client_cert_path)
        pulumi.set(__self__, "client_key_path", client_key_path)
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if ca_cert_path is not None:
            pulumi.set(__self__, "ca_cert_path", ca_cert_path)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clientCertPath")
    def client_cert_path(self) -> pulumi.Input[_builtins.str]:
        """
        A path to a client certificate file accessible by a Node
        """
        return pulumi.get(self, "client_cert_path")

    @client_cert_path.setter
    def client_cert_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_cert_path", value)

    @_builtins.property
    @pulumi.getter(name="clientKeyPath")
    def client_key_path(self) -> pulumi.Input[_builtins.str]:
        """
        A path to a client key file accessible by a Node
        """
        return pulumi.get(self, "client_key_path")

    @client_key_path.setter
    def client_key_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_key_path", value)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @pki_mount_point.setter
    def pki_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pki_mount_point", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter(name="caCertPath")
    def ca_cert_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A path to a CA file accessible by a Node
        """
        return pulumi.get(self, "ca_cert_path")

    @ca_cert_path.setter
    def ca_cert_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_cert_path", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultTokenArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultTokenArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultTokenCertSshArgsDict(TypedDict):
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        ssh_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the SSH engine configured with the desired CA
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultTokenCertSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultTokenCertSshArgs:
    def __init__(__self__, *,
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 ssh_mount_point: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] ssh_mount_point: The mount point of the SSH engine configured with the desired CA
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        pulumi.set(__self__, "ssh_mount_point", ssh_mount_point)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter(name="sshMountPoint")
    def ssh_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the SSH engine configured with the desired CA
        """
        return pulumi.get(self, "ssh_mount_point")

    @ssh_mount_point.setter
    def ssh_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ssh_mount_point", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SecretStoreVaultTokenCertX509ArgsDict(TypedDict):
        issued_cert_ttl_minutes: pulumi.Input[_builtins.int]
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique human-readable name of the SecretStore.
        """
        pki_mount_point: pulumi.Input[_builtins.str]
        """
        The mount point of the PKI engine configured with the desired CA
        """
        server_address: pulumi.Input[_builtins.str]
        """
        The URL of the Vault to target
        """
        signing_role: pulumi.Input[_builtins.str]
        """
        The signing role to be used for signing certificates
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to make requests within
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Tags is a map of key, value pairs.
        """
elif False:
    SecretStoreVaultTokenCertX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreVaultTokenCertX509Args:
    def __init__(__self__, *,
                 issued_cert_ttl_minutes: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 pki_mount_point: pulumi.Input[_builtins.str],
                 server_address: pulumi.Input[_builtins.str],
                 signing_role: pulumi.Input[_builtins.str],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] issued_cert_ttl_minutes: The lifetime of certificates issued by this CA represented in minutes.
        :param pulumi.Input[_builtins.str] name: Unique human-readable name of the SecretStore.
        :param pulumi.Input[_builtins.str] pki_mount_point: The mount point of the PKI engine configured with the desired CA
        :param pulumi.Input[_builtins.str] server_address: The URL of the Vault to target
        :param pulumi.Input[_builtins.str] signing_role: The signing role to be used for signing certificates
        :param pulumi.Input[_builtins.str] namespace: The namespace to make requests within
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Tags is a map of key, value pairs.
        """
        pulumi.set(__self__, "issued_cert_ttl_minutes", issued_cert_ttl_minutes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pki_mount_point", pki_mount_point)
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "signing_role", signing_role)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="issuedCertTtlMinutes")
    def issued_cert_ttl_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The lifetime of certificates issued by this CA represented in minutes.
        """
        return pulumi.get(self, "issued_cert_ttl_minutes")

    @issued_cert_ttl_minutes.setter
    def issued_cert_ttl_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "issued_cert_ttl_minutes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique human-readable name of the SecretStore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pkiMountPoint")
    def pki_mount_point(self) -> pulumi.Input[_builtins.str]:
        """
        The mount point of the PKI engine configured with the desired CA
        """
        return pulumi.get(self, "pki_mount_point")

    @pki_mount_point.setter
    def pki_mount_point(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pki_mount_point", value)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the Vault to target
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_address", value)

    @_builtins.property
    @pulumi.getter(name="signingRole")
    def signing_role(self) -> pulumi.Input[_builtins.str]:
        """
        The signing role to be used for signing certificates
        """
        return pulumi.get(self, "signing_role")

    @signing_role.setter
    def signing_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signing_role", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to make requests within
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetApprovalWorkflowApprovalStepArgsDict(TypedDict):
        approvers: Sequence['GetApprovalWorkflowApprovalStepApproverArgsDict']
        """
        The approvers for this approval step
        """
        quantifier: NotRequired[_builtins.str]
        """
        Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        """
        skip_after: NotRequired[_builtins.str]
        """
        Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
elif False:
    GetApprovalWorkflowApprovalStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApprovalWorkflowApprovalStepArgs:
    def __init__(__self__, *,
                 approvers: Sequence['GetApprovalWorkflowApprovalStepApproverArgs'],
                 quantifier: Optional[_builtins.str] = None,
                 skip_after: Optional[_builtins.str] = None):
        """
        :param Sequence['GetApprovalWorkflowApprovalStepApproverArgs'] approvers: The approvers for this approval step
        :param _builtins.str quantifier: Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        :param _builtins.str skip_after: Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        pulumi.set(__self__, "approvers", approvers)
        if quantifier is not None:
            pulumi.set(__self__, "quantifier", quantifier)
        if skip_after is not None:
            pulumi.set(__self__, "skip_after", skip_after)

    @_builtins.property
    @pulumi.getter
    def approvers(self) -> Sequence['GetApprovalWorkflowApprovalStepApproverArgs']:
        """
        The approvers for this approval step
        """
        return pulumi.get(self, "approvers")

    @approvers.setter
    def approvers(self, value: Sequence['GetApprovalWorkflowApprovalStepApproverArgs']):
        pulumi.set(self, "approvers", value)

    @_builtins.property
    @pulumi.getter
    def quantifier(self) -> Optional[_builtins.str]:
        """
        Whether any or all approvers are required to approve for this approval step (optional, defaults to any)
        """
        return pulumi.get(self, "quantifier")

    @quantifier.setter
    def quantifier(self, value: Optional[_builtins.str]):
        pulumi.set(self, "quantifier", value)

    @_builtins.property
    @pulumi.getter(name="skipAfter")
    def skip_after(self) -> Optional[_builtins.str]:
        """
        Duration after which this approval step will be skipped if no approval is given (optional, if not provided this step must be manually approved)
        """
        return pulumi.get(self, "skip_after")

    @skip_after.setter
    def skip_after(self, value: Optional[_builtins.str]):
        pulumi.set(self, "skip_after", value)


if not MYPY:
    class GetApprovalWorkflowApprovalStepApproverArgsDict(TypedDict):
        account_id: NotRequired[_builtins.str]
        """
        The account id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        group_id: NotRequired[_builtins.str]
        """
        The group id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        reference: NotRequired[_builtins.str]
        """
        A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        role_id: NotRequired[_builtins.str]
        """
        The role id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
elif False:
    GetApprovalWorkflowApprovalStepApproverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApprovalWorkflowApprovalStepApproverArgs:
    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.str] = None,
                 reference: Optional[_builtins.str] = None,
                 role_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_id: The account id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        :param _builtins.str group_id: The group id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        :param _builtins.str reference: A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, group id, or reference may be present for one approver)
        :param _builtins.str role_id: The role id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        The account id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        """
        The group id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter
    def reference(self) -> Optional[_builtins.str]:
        """
        A reference to an approver: 'manager-of-requester' or 'manager-of-manager-of-requester' (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        return pulumi.get(self, "reference")

    @reference.setter
    def reference(self, value: Optional[_builtins.str]):
        pulumi.set(self, "reference", value)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        The role id of the approver (only one of account_id, role_id, group id, or reference may be present for one approver)
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "role_id", value)


