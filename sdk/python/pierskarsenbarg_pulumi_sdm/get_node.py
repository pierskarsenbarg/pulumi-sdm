# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GetNodeResult',
    'AwaitableGetNodeResult',
    'get_node',
    'get_node_output',
]

@pulumi.output_type
class GetNodeResult:
    """
    A collection of values returned by getNode.
    """
    def __init__(__self__, bind_address=None, id=None, ids=None, listen_address=None, name=None, nodes=None, tags=None, type=None):
        if bind_address and not isinstance(bind_address, str):
            raise TypeError("Expected argument 'bind_address' to be a str")
        pulumi.set(__self__, "bind_address", bind_address)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if ids and not isinstance(ids, list):
            raise TypeError("Expected argument 'ids' to be a list")
        pulumi.set(__self__, "ids", ids)
        if listen_address and not isinstance(listen_address, str):
            raise TypeError("Expected argument 'listen_address' to be a str")
        pulumi.set(__self__, "listen_address", listen_address)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if nodes and not isinstance(nodes, list):
            raise TypeError("Expected argument 'nodes' to be a list")
        pulumi.set(__self__, "nodes", nodes)
        if tags and not isinstance(tags, dict):
            raise TypeError("Expected argument 'tags' to be a dict")
        pulumi.set(__self__, "tags", tags)
        if type and not isinstance(type, str):
            raise TypeError("Expected argument 'type' to be a str")
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> Optional[builtins.str]:
        """
        The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
        """
        return pulumi.get(self, "bind_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Unique identifier of the Relay.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ids(self) -> Sequence[builtins.str]:
        """
        a list of strings of ids of data sources that match the given arguments.
        """
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> Optional[builtins.str]:
        """
        The public hostname/port tuple at which the gateway will be accessible to clients.
        """
        return pulumi.get(self, "listen_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetNodeNodeResult']:
        """
        A single element list containing a map, where each key lists one of the following objects:
        * gateway:
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tags is a map of key, value pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


class AwaitableGetNodeResult(GetNodeResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetNodeResult(
            bind_address=self.bind_address,
            id=self.id,
            ids=self.ids,
            listen_address=self.listen_address,
            name=self.name,
            nodes=self.nodes,
            tags=self.tags,
            type=self.type)


def get_node(bind_address: Optional[builtins.str] = None,
             id: Optional[builtins.str] = None,
             listen_address: Optional[builtins.str] = None,
             name: Optional[builtins.str] = None,
             tags: Optional[Mapping[str, builtins.str]] = None,
             type: Optional[builtins.str] = None,
             opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetNodeResult:
    """
    Nodes make up the strongDM network, and allow your users to connect securely to your resources.
     There are two types of nodes:
     1. **Relay:** creates connectivity to your datasources, while maintaining the egress-only nature of your firewall
     2. **Gateways:** a relay that also listens for connections from strongDM clients
    ## Example Usage

    ```python
    import pulumi
    import pulumi_sdm as sdm

    gateway_query = sdm.get_node(tags={
            "env": "dev",
            "region": "us-west",
        },
        type="gateway")
    ```


    :param builtins.str bind_address: The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
    :param builtins.str id: Unique identifier of the Relay.
    :param builtins.str listen_address: The public hostname/port tuple at which the gateway will be accessible to clients.
    :param builtins.str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    :param Mapping[str, builtins.str] tags: Tags is a map of key, value pairs.
    :param builtins.str type: a filter to select all items of a certain subtype. See the [filter documentation](https://www.strongdm.com/docs/automation/getting-started/filters) for more information.
    """
    __args__ = dict()
    __args__['bindAddress'] = bind_address
    __args__['id'] = id
    __args__['listenAddress'] = listen_address
    __args__['name'] = name
    __args__['tags'] = tags
    __args__['type'] = type
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('sdm:index/getNode:getNode', __args__, opts=opts, typ=GetNodeResult).value

    return AwaitableGetNodeResult(
        bind_address=pulumi.get(__ret__, 'bind_address'),
        id=pulumi.get(__ret__, 'id'),
        ids=pulumi.get(__ret__, 'ids'),
        listen_address=pulumi.get(__ret__, 'listen_address'),
        name=pulumi.get(__ret__, 'name'),
        nodes=pulumi.get(__ret__, 'nodes'),
        tags=pulumi.get(__ret__, 'tags'),
        type=pulumi.get(__ret__, 'type'))
def get_node_output(bind_address: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                    id: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                    listen_address: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                    name: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                    tags: Optional[pulumi.Input[Optional[Mapping[str, builtins.str]]]] = None,
                    type: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                    opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetNodeResult]:
    """
    Nodes make up the strongDM network, and allow your users to connect securely to your resources.
     There are two types of nodes:
     1. **Relay:** creates connectivity to your datasources, while maintaining the egress-only nature of your firewall
     2. **Gateways:** a relay that also listens for connections from strongDM clients
    ## Example Usage

    ```python
    import pulumi
    import pulumi_sdm as sdm

    gateway_query = sdm.get_node(tags={
            "env": "dev",
            "region": "us-west",
        },
        type="gateway")
    ```


    :param builtins.str bind_address: The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
    :param builtins.str id: Unique identifier of the Relay.
    :param builtins.str listen_address: The public hostname/port tuple at which the gateway will be accessible to clients.
    :param builtins.str name: Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
    :param Mapping[str, builtins.str] tags: Tags is a map of key, value pairs.
    :param builtins.str type: a filter to select all items of a certain subtype. See the [filter documentation](https://www.strongdm.com/docs/automation/getting-started/filters) for more information.
    """
    __args__ = dict()
    __args__['bindAddress'] = bind_address
    __args__['id'] = id
    __args__['listenAddress'] = listen_address
    __args__['name'] = name
    __args__['tags'] = tags
    __args__['type'] = type
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('sdm:index/getNode:getNode', __args__, opts=opts, typ=GetNodeResult)
    return __ret__.apply(lambda __response__: GetNodeResult(
        bind_address=pulumi.get(__response__, 'bind_address'),
        id=pulumi.get(__response__, 'id'),
        ids=pulumi.get(__response__, 'ids'),
        listen_address=pulumi.get(__response__, 'listen_address'),
        name=pulumi.get(__response__, 'name'),
        nodes=pulumi.get(__response__, 'nodes'),
        tags=pulumi.get(__response__, 'tags'),
        type=pulumi.get(__response__, 'type')))
